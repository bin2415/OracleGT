Only in gold_2.27_modified: .clang_complete
Only in gold_2.27_modified: cscope.files
Only in gold_2.27_modified: .git
Only in gold_2.27_modified: .gitignore
diff -ru gold_origin/gold.cc gold_2.27_modified/gold.cc
--- gold_origin/gold.cc	2019-08-25 16:45:38.357425841 -0400
+++ gold_2.27_modified/gold.cc	2019-08-25 16:39:59.131037708 -0400
@@ -47,6 +47,12 @@
 #include "incremental.h"
 #include "timer.h"
 
+
+
+#include <cstring>
+#include <sstream>
+#include <fstream>
+#include <iostream>
 namespace gold
 {
 
@@ -232,6 +238,7 @@
 {
 // Normal link.  Queue a Read_symbols task for each input file
 // on the command line.
+// CCR: things start here
 for (Command_line::const_iterator p = cmdline.begin();
 p != cmdline.end();
 ++p)
@@ -773,6 +780,7 @@
 
 // When all those tasks are complete, we can start laying out the
 // output file.
+//CCR: here we adjusted the layout for .rand output section
 workqueue->queue(new Task_function(new Layout_task_runner(options,
 input_objects,
 symtab,
@@ -783,6 +791,9 @@
 "Task_function Layout_task_runner"));
 }
 
+
+
+
 // Queue up the final set of tasks.  This is called at the end of
 // Layout_task.
 
@@ -839,6 +850,8 @@
 of,
 final_blocker));
 
+
+
 // Queue a task to write out the output sections.
 workqueue->queue(new Write_sections_task(layout, of, output_sections_blocker,
 input_sections_blocker,
@@ -847,16 +860,38 @@
 // Queue a task to write out everything else.
 workqueue->queue(new Write_data_task(layout, symtab, of, final_blocker));
 
+
+
+
+//CCR: we assume the sequence of relocating the objects is the same of the one for laying out the objects
 // Queue a task for each input object to relocate the sections and
 // write out the local symbols.
 for (Input_objects::Relobj_iterator p = input_objects->relobj_begin();
 p != input_objects->relobj_end();
 ++p)
+{
 workqueue->queue(new Relocate_task(symtab, layout, *p, of,
 input_sections_blocker,
 output_sections_blocker,
 final_blocker));
+}
 
+//CCR: we find main symbol here
+Symbol *main_sym = symtab->lookup("main");
+
+if (main_sym != NULL) {
+#ifdef CCR_MSG_DETAILS
+Sized_symbol<64>* mssym;
+mssym = symtab->get_sized_symbol<64>(main_sym);
+gold_info("[CCR] Location of main(): VA=0x%x, Off=0x%x queue_final_tasks()@gold.cc",
+mssym->value(), layout->yarp_find_os_base_offset_by_name(".text"));
+#endif
+}
+else {
+gold_info("[CCR] main func does NOT exist (shared object?)");
+}
+
+// layout->yarp_set_main_addr_off(mssym->value()-layout->yarp_find_os_base_addr_by_name(".text"));
 // Queue a task to write out the output sections which depend on
 // input sections.  If there are any sections which require
 // postprocessing, then we need to do this last, since it may resize
@@ -899,7 +934,7 @@
 of, NULL, 0),
 final_blocker,
 "Task_function Close_task_runner"));
-}
+
 
 }
 
diff -ru gold_origin/layout.cc gold_2.27_modified/layout.cc
--- gold_origin/layout.cc	2019-08-25 16:46:08.861636596 -0400
+++ gold_2.27_modified/layout.cc	2019-08-25 16:41:27.239667363 -0400
@@ -54,9 +54,30 @@
 #include "incremental.h"
 #include "layout.h"
 
+//CCR
+#include "shuffleInfo.pb.h"
+#include <iostream>
+#include <fstream>
+#include <string>
+#include "output.h"
+
+#include <unordered_map>
+
+#define CCR_READ_FROM_SECTION
+// #define CCR_READ_FROM_FILE
+#define CCR_MSG_DETAILS
+
+// binpang, set unordered_map bucket size
+#define MIN_BUCKET_SIZE 10000
 namespace gold
 {
 
+
+// binpang
+// store the sections fixup based on the offset
+typedef std::unordered_map<uint32_t, ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple*> OffsetFixupMap;
+std::unordered_map<std::string,  OffsetFixupMap> ShuffleSectionFixups;
+//ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* bbinfo_tmp_fixup;
 // Class Free_list.
 
 // The total number of free lists used.
@@ -407,9 +428,11 @@
 of->resize(file_size);
 }
 
+
 // Queue up the final set of tasks.
 gold::queue_final_tasks(this->options_, this->input_objects_,
 this->symtab_, layout, workqueue, of);
+
 }
 
 // Layout methods.
@@ -569,6 +592,20 @@
 "gnu_pubtypes",
 };
 
+// [CCR] CCR: These sections contain the fixups that we want to handle
+static const char* lookup_fixup_sections[] = 
+{
+".text",
+".rodata",
+".data",
+".data.rel.ro",
+".init_array",
+// ".eh_frame",
+// ".gcc_except_table",
+};
+
+
+
 // Returns whether the given debug section is in the list of
 // debug-sections-used-by-some-version-of-gdb.  SUFFIX is the
 // portion of the name following ".debug_" or ".zdebug_".
@@ -838,8 +875,10 @@
 std::pair<Section_name_map::iterator, bool> ins(
 this->section_name_map_.insert(v));
 
-if (!ins.second)
+if (!ins.second){
+//we have seen it, insert failed
 return ins.first->second;
+}
 else
 {
 // This is the first time we've seen this name/type/flags
@@ -875,8 +914,9 @@
 }
 }
 
-if (os == NULL)
+if (os == NULL){
 os = this->make_output_section(name, type, flags, order, is_relro);
+}
 
 ins.first->second = os;
 return os;
@@ -1045,6 +1085,7 @@
 
 // Turn NAME from the name of the input section into the name of the
 // output section.
+//CCR: MARK, our .rand output section name is decided here
 if (is_input_section
 && !this->script_options_->saw_sections_clause()
 && !parameters->options().relocatable())
@@ -1152,11 +1193,71 @@
 if (!this->include_section(object, name, shdr))
 return NULL;
 
+//for layout, we don't care if there is a corresponding .rela.text for a .text.* section
+std::string obj_path = object->name();
+std::string obj_name = obj_path.substr(obj_path.find_last_of("/")+1);
+
+//this is to deal with layout 
+if(is_prefix_of(".text", name)) {
+#ifdef CCR_MSG_DETAILS
+gold_info("\t%s: %s[%d] layout()@layout.cc", obj_name.c_str(), name, shndx);
+#endif
+object->record_text_shndx(name, shndx);
+}
+
+if(is_prefix_of(".rodata", name)) {
+#ifdef CCR_MSG_DETAILS
+gold_info("\t%s: %s[%d] layout()@layout.cc", obj_name.c_str(), name, shndx);
+#endif
+object->record_rodata_shndx(name, shndx);
+}
+
+// Note that '.data.rel.ro' section has the prefix of '.data' as well
+if(is_prefix_of(".data", name))
+{
+if(is_prefix_of(".data.rel.ro", name)) {
+#ifdef CCR_MSG_DETAILS
+gold_info("\t%s: %s[%d] layout()@layout.cc", obj_name.c_str(), name, shndx);
+#endif
+object->record_datarel_shndx(name, shndx);
+}
+else {
+#ifdef CCR_MSG_DETAILS
+gold_info("\t%s: %s[%d] layout()@layout.cc", obj_name.c_str(), name, shndx);
+#endif
+object->record_data_shndx(name, shndx);
+}
+}
+
+if(is_prefix_of(".init_array", name)) {
+#ifdef CCR_MSG_DETAILS
+gold_info("\t%s: %s[%d] layout()@layout.cc", obj_name.c_str(), name, shndx);
+#endif
+object->record_initarray_shndx(name, shndx);
+}
+
+if(is_prefix_of(".rand", name)) {
+#ifdef CCR_MSG_DETAILS
+gold_info("\t%s: %s[%d] layout()@layout.cc", obj_name.c_str(), name, shndx);
+#endif
+object->record_rand_shndx(name, shndx);
+}
+
 elfcpp::Elf_Word sh_type = shdr.get_sh_type();
 
 // In a relocatable link a grouped section must not be combined with
 // any other sections.
 Output_section* os;
+
+//CCR: we don't let .rand section gets into output section list 
+//  But if we have seen such section we should try to read the .rand from file
+if(!strcmp(name, ".rand")){
+ShuffleInfo::ReorderInfo reorder_info;
+// gold_info("[CCR] in %s found .rand", this->name().c_str());
+object->set_yarp_defined_object();
+return NULL;
+}
+
 if (parameters->options().relocatable()
 && (shdr.get_sh_flags() & elfcpp::SHF_GROUP) != 0)
 {
@@ -1167,6 +1268,7 @@
 name = this->namepool_.add(name, true, NULL);
 os = this->make_output_section(name, sh_type, flags,
 ORDER_INVALID, false);
+
 }
 else
 {
@@ -1178,6 +1280,8 @@
 = this->section_segment_map_.find(Const_section_id(object, shndx));
 if (it == this->section_segment_map_.end())
 {
+//CCR: take this route
+// gold_info("print !@# %s[%s]", object->name().c_str(),name);
 os = this->choose_output_section(object, name, sh_type,
 shdr.get_sh_flags(), true,
 ORDER_INVALID, false);
@@ -1190,6 +1294,7 @@
 = this->get_output_section_flags(shdr.get_sh_flags());
 
 const char* os_name = it->second->name;
+
 Stringpool::Key name_key;
 os_name = this->namepool_.add(os_name, true, &name_key);
 os = this->get_output_section(os_name, name_key, sh_type, flags,
@@ -1253,6 +1358,12 @@
 
 *off = os->add_input_section(this, object, shndx, name, shdr, reloc_shndx,
 this->script_options_->saw_sections_clause());
+// //CCR: we don't let .rand section gets into output section list 
+// if(!strcmp(name, ".rand"))
+//   {
+//     //we direct each .rand from the input objects to output to offset 0 of the output .rand sections 
+//     *off = 0;
+//   }
 
 // If the flags changed, we may have to change the order.
 if ((orig_flags & elfcpp::SHF_ALLOC) != 0)
@@ -2396,6 +2507,1530 @@
 this->relax_output_list_.clear();
 }
 
+//CCR: use this API to obtain the start offset of the named output section
+elfcpp::Elf_types<64>::Elf_Addr
+Layout::yarp_find_os_base_offset_by_name(char *section_name)
+{
+const Output_section* os = this->find_output_section(section_name);
+if(!os)
+gold_info("[CCR-error] Can't find the section base offset for <%s>",
+const_cast<const char *>(section_name));
+return os?os->offset() : 0;
+}
+
+elfcpp::Elf_types<64>::Elf_Addr
+Layout::yarp_find_os_base_addr_by_name(const char *section_name)
+{
+const Output_section* os = this->find_output_section(section_name);
+if(!os)
+gold_info("[CCR-error] Can't find the section base offset for <%s>",
+const_cast<const char *>(section_name));
+return os?os->address() : 0;
+}
+
+//CCR: use this API to serialize reorderInfo into string
+std::string *
+Layout::serialize_shuffle_info()
+{
+ShuffleInfo::ReorderInfo& reorder_info = this->get_global_shuffleInfo();
+std::string *ret = this->get_serialized_shuffle_info();
+// if(!ret)
+// {
+std::string tmp;
+reorder_info.SerializeToString(&tmp); 
+ret = new std::string(tmp.c_str());
+this->ccr_shuffle_info_.pserialized_info = ret;
+// }
+return ret;
+}
+
+//CCR: helper functions for Layout::yarp_update_fixups()
+int
+get_fixup_section_id(std::string sec_name) {
+for (size_t i = 0; i < sizeof(lookup_fixup_sections)/sizeof(*lookup_fixup_sections); ++i)
+if (strcmp(sec_name.c_str(), lookup_fixup_sections[i]) == 0)
+return i;
+return -1;
+}
+
+bool
+is_fixup_section(std::string sec_name) {
+for (size_t i = 0; i < sizeof(lookup_fixup_sections)/sizeof(*lookup_fixup_sections); ++i)
+if (strcmp(sec_name.c_str(), lookup_fixup_sections[i]) == 0)
+return true;
+return false;
+}
+
+uint32_t
+decide_fixup_type(bool src, bool dst) {
+uint32_t fixup_ty = 3;
+if(src && dst)
+fixup_ty = 0; // c2c
+else if(src && !dst)
+fixup_ty = 1; // c2d
+else if(!src && dst)
+fixup_ty = 2; // d2c
+else if(!src && !dst)
+fixup_ty = 3; // d2d
+return fixup_ty;
+}
+
+uint32_t
+get_fixup_size(ShuffleInfo::ReorderInfo_FixupInfo* p_fixup_info, std::string sec_name) {
+switch (get_fixup_section_id(sec_name)) {
+case 0: return p_fixup_info->text_size();
+case 1: return p_fixup_info->rodata_size();
+case 2: return p_fixup_info->data_size();
+case 3: return p_fixup_info->datarel_size();
+case 4: return p_fixup_info->initarray_size();
+default: gold_unreachable();
+}
+}
+
+ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple*
+get_mutable_fixup(ShuffleInfo::ReorderInfo_FixupInfo* p_fixup_info, std::string sec_name, int idx) {
+switch (get_fixup_section_id(sec_name)) {
+case 0: return p_fixup_info->mutable_text(idx);
+case 1: return p_fixup_info->mutable_rodata(idx);
+case 2: return p_fixup_info->mutable_data(idx);
+case 3: return p_fixup_info->mutable_datarel(idx);
+case 4: return p_fixup_info->mutable_initarray(idx);
+default: gold_unreachable();
+}
+}
+
+
+
+void
+update_fixup_type(ShuffleInfo::ReorderInfo_FixupInfo* p_fixup_info, std::string sec_name, int fixup_offset,
+int64_t resolved_val_abs, int64_t resolved_value, int64_t text_base, int64_t text_size, bool src) {
+//for (uint32_t j = 0; j < get_fixup_size(p_fixup_info, sec_name); ++j) {
+std::unordered_map<std::string,OffsetFixupMap>::iterator map_iter = ShuffleSectionFixups.find(sec_name);
+if (map_iter == ShuffleSectionFixups.end()){
+#ifdef CCR_MSG_DETAILS
+gold_warning("[bbinfo]: don't record the fixups in sections %s", sec_name.c_str());
+#endif
+return;
+}
+OffsetFixupMap fixup_list = map_iter->second;
+std::unordered_map<uint32_t,ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple*>::iterator tmp_fixup_iter = 
+fixup_list.find((uint32_t)fixup_offset);
+if (tmp_fixup_iter == fixup_list.end()){
+#ifdef CCR_MSG_DETAILS
+gold_warning("[bbinfo]: can't find the finxup which offset 0x%x in section %s",
+fixup_offset, sec_name.c_str());
+#endif
+return;
+}
+
+ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* p_fixup_tuple = tmp_fixup_iter->second;
+int64_t tentative_value = p_fixup_tuple->is_rela() ? resolved_val_abs : resolved_value;
+bool dst = (tentative_value >= text_base) && (tentative_value <= text_base + text_size)? true: false;
+uint32_t fixup_ty = decide_fixup_type(src, dst);
+#ifdef CCR_MSG_DETAILS
+//gold_info("[CCR] (Fixup in %s) updated: OFF=0x%x, TY=%d, P_TY=%d,ResVal=0x%x @layout.cc",
+//      sec_name.c_str(), fixup_offset, fixup_ty, p_fixup_tuple->type(),tentative_value); // CCR
+#endif
+if ((int)p_fixup_tuple->type() != 5)
+p_fixup_tuple->set_type(fixup_ty);
+//CCR: if current fixup belongs to special text sections
+return;
+
+}
+
+// void
+//      update_fixup_type(ShuffleInfo::ReorderInfo_FixupInfo* p_fixup_info, std::string sec_name, int fixup_offset,
+//                        int64_t resolved_val_abs, int64_t resolved_value, int64_t text_base, int64_t text_size, bool src) {
+//                            return;
+// }
+
+
+// binpang: record the shuffleInfo fixups information in map according to its offset
+void record_shuffle_fixups(ShuffleInfo::ReorderInfo_FixupInfo* fixups){
+uint32_t num = 0;
+for (int i = 0; i < sizeof(lookup_fixup_sections) / sizeof(*lookup_fixup_sections); i++){
+std::string tmp_sec = std::string(lookup_fixup_sections[i]);
+OffsetFixupMap tmp_map = std::unordered_map<uint32_t, ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple*>();
+tmp_map.rehash(MIN_BUCKET_SIZE);
+for (uint32_t j = 0; j < get_fixup_size(fixups, tmp_sec); j++){
+ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* p_fixup_tuple = get_mutable_fixup(fixups, tmp_sec, j);
+tmp_map.insert(std::pair<uint32_t, ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple*>(
+p_fixup_tuple->offset(), p_fixup_tuple));
+//bbinfo_tmp_fixup = p_fixup_tuple;
+} 
+ShuffleSectionFixups.insert(std::pair<std::string, OffsetFixupMap>(tmp_sec, tmp_map));
+}
+}
+
+//CCR: use this API to update the type of those fixups done by linker
+void
+Layout::yarp_update_fixups(int fixup_offset, const Output_section *os,
+const Output_section *text , int64_t resolved_value)
+{
+int64_t text_base = (int64_t)text->address(); //to shut clang up
+int64_t text_size = (int64_t)text->data_size();//to shut clang up
+//CCR: we use strcmp here cuz there should only be one .text in output sections
+bool src_in_text = !strcmp(".text", os->name());
+// bool dst_in_text = false;
+// bool found_target_fixup = false;
+uint64_t os_base = this->yarp_find_os_base_addr_by_name(os->name());
+int64_t resolved_val_abs = os_base + fixup_offset + resolved_value;
+
+ShuffleInfo::ReorderInfo& reorder_info = this->get_global_shuffleInfo();
+//there should only be one large fixupInfo message
+ShuffleInfo::ReorderInfo_FixupInfo* p_fixup_info = reorder_info.mutable_fixup(0) ;
+
+if (is_fixup_section(os->name()))
+update_fixup_type(p_fixup_info, os->name(), fixup_offset, resolved_val_abs, resolved_value,
+text_base, text_size, src_in_text);
+}
+
+/*
+// CCR: define layout types
+static std::string
+Layout_Type_Translate(uint32_t type){
+std::string result;
+switch(type){
+case 2:
+result = "OBJ_BBL";
+break;
+case 1:
+result = "FUNC_BBL";
+break;
+case 0:
+result = "NORMAL_BBL";
+break;
+default:
+result = "UNKNOWN";
+}
+return result;
+}
+
+// CCR: define fixup types
+static std::string
+Fixup_Type_Translate(uint32_t type){
+std::string result;
+switch(type){
+case 0:
+result = "C2C";
+break;
+case 1:
+result = "C2D";
+break;
+case 2:
+result = "D2C";
+break;
+case 3:
+result = "D2D";
+break;
+case 4:
+result = "NewSectionStart";
+break;
+default:
+result = "UNKNOWN";
+}
+return result;
+}
+*/
+
+bool
+Layout::visited_shuffle_bin(std::string name){
+if (ccr_shuffle_info_.added_set.find(name) == ccr_shuffle_info_.added_set.end()){
+ccr_shuffle_info_.added_set.insert(name);
+return false;
+}
+return true;
+}
+
+// [CCR] Koo - Update the shuffleInfo at the end of finalizing layout
+//       Triggering it in reloction time (reloc.cc) sometimes does not guarantee the order
+//          of the shuffleInfo. Here we leverage the Section_list that contains 
+//          all Output_sections, which also including Input_section_list.
+//       A tricky part is to reinterpret the pointer of each object pointer 
+//          from Relobj* to Sized_relobj_file<size, big_endian>* to access 
+template<int size, bool big_endian>
+void
+Layout::update_shuffleInfo()
+{
+std::vector<std::string> obj_names;
+
+for (Section_list::const_iterator p = this->section_list_.begin();
+p != this->section_list_.end();
+++p)
+{
+Output_section* os = *p;
+Output_section::Input_section_list input_section_list = os->input_sections();
+if (!strcmp(os->name(), ".text")) {
+for (Output_section::Input_section_list::const_iterator q = input_section_list.begin();
+q != input_section_list.end(); q++) 
+{
+if (q->relobj() && q->relobj()->is_yarp_defined_object() && q->is_input_section()) 
+{
+ShuffleInfo::ReorderInfo reorder_info;
+section_size_type rand_sec_len;
+Sized_relobj_file<size, big_endian>* obj = reinterpret_cast<Sized_relobj_file<size, big_endian> *>(q->relobj());
+const unsigned char *my_contents = obj->section_contents(obj->get_rand_shndx(".rand"), &rand_sec_len, false);
+std::string rand_input(reinterpret_cast<const char *>(my_contents), rand_sec_len);
+if(rand_sec_len > 0 && (std::find(std::begin(obj_names), std::end(obj_names), obj->name()) == std::end(obj_names)))
+{
+reorder_info.ParseFromString(rand_input);
+this->add_shuffleInfo(reorder_info, obj);
+obj_names.push_back(obj->name());
+#ifdef CCR_MSG_DETAILS
+gold_info("\t>> %s", obj->name().c_str());
+#endif
+}
+}
+}
+}
+}
+}
+
+// binpang, add
+// check if the current section is our recorded section
+// TODO add more sections or modify ccr framework that don't consider the section name
+bool is_recorded_section(const char* sec_name){
+const char* const recorded_sections[] =
+{
+".text",
+".data",
+".rodata",
+".init_array"
+};
+for (unsigned i = 0; i < sizeof(recorded_sections) / sizeof(const char*); i++){
+if (is_prefix_of(recorded_sections[i], sec_name))
+return true;
+}
+return false;
+}
+
+// binpang, add. Add shuffle accourding to the output section
+//    template<int size, bool big_endian>
+//    void Layout::update_shuffleInfo_layout(){
+//
+//        std::vector<std::string> obj_names;
+//        std::map<Sized_relobj_file<size, big_endian>*, input2output> obj2input;
+//        typename std::map<Sized_relobj_file<size, big_endian>*, input2output>::iterator tmp_iter;
+//        for (Section_list::const_iterator p = this->section_list_.begin();
+//             p != this->section_list_.end();
+//             ++p){
+//            Output_section* os = *p;
+//            Output_section::Input_section_list input_section_list = os->input_sections();
+//            for (Output_section::Input_section_list::iterator q = input_section_list.begin();
+//                q != input_section_list.end(); q++){
+//                    if (q->is_input_section() && q->relobj() && q->relobj()->is_yarp_defined_object()){
+//                        const char* input_sec_name = q->get_input_section_name();
+//                        // check if this section name is in the recorded name
+//                        // Maybe we should record every section
+//                        // But it may change CCR framework....
+//                        if (!is_recorded_section(input_sec_name))
+//                            continue;
+//                        
+//                        ShuffleInfo::ReorderInfo reorder_info;
+//                        Sized_relobj_file<size, big_endian> *obj = reinterpret_cast<Sized_relobj_file<size, big_endian> *>(q->relobj());
+//                        tmp_iter = obj2input.find(obj);
+//                        if (tmp_iter == obj2input.end()){
+//                            input2output tmp_vec;
+//                            tmp_vec.insert(std::pair<std::string, std::string>(std::string(input_sec_name), os->name()));
+//                            obj2input.insert(std::pair<Sized_relobj_file<size, big_endian>*, input2output>(obj, tmp_vec));
+//                        }else{
+//                            std::pair<std::map<std::string, std::string>::iterator, bool> ret;
+//			    std::string tmp_str(input_sec_name);
+//                            ret = tmp_iter->second.insert(std::pair<std::string, std::string>(tmp_str, os->name()));
+//                            if (ret.second == false){
+//                                 gold_warning(_("[bbinfo]: Bug, has duplicate input section %s in obj %s"), 
+//                                 input_sec_name, obj->name().c_str());
+//                            }
+//                        }
+//                }
+//            }
+//        }
+//	
+//	section_size_type rand_sec_len;
+//	ShuffleInfo::ReorderInfo reorder_info;
+//	for(tmp_iter = obj2input.begin(); 
+//	    tmp_iter != obj2input.end(); tmp_iter++){
+//	  Sized_relobj_file<size, big_endian>* tmp_obj = tmp_iter->first;
+//	  const unsigned char *my_contents = tmp_obj->section_contents(tmp_obj->get_rand_shndx(".rand"), &rand_sec_len, false);
+//	  std::string rand_input(reinterpret_cast<const char *>(my_contents), rand_sec_len);
+//	  if(rand_sec_len > 0){
+//	    reorder_info.ParseFromString(rand_input);
+//	    this->add_shuffleInfo_obj(reorder_info, tmp_obj, tmp_iter->second);
+//#ifdef CCR_MSG_DETAILS
+//	    gold_info("\t>> %s", obj->name().c_str());
+//#endif
+//	    }
+//      }
+//    }
+//
+
+template<int size, bool big_endian>
+void Layout::update_shuffleInfo_layout(){
+
+std::vector<std::string> obj_names;
+std::map<std::string, input2output> obj2input_tmp;
+obj2input_tmp = this->get_obj2input();
+// binpang, debug
+for (Section_list::const_iterator p = this->section_list_.begin();
+p != this->section_list_.end();
+++p)
+{
+Output_section* os = *p;
+Output_section::Input_section_list input_section_list = os->input_sections();
+for (Output_section::Input_section_list::const_iterator q = input_section_list.begin();
+q != input_section_list.end(); q++) 
+{
+if (q->is_input_section() && q->relobj() && q->relobj()->is_yarp_defined_object()) 
+{
+
+ShuffleInfo::ReorderInfo reorder_info;
+section_size_type rand_sec_len;
+Sized_relobj_file<size, big_endian>* obj = reinterpret_cast<Sized_relobj_file<size, big_endian> *>(q->relobj());
+// we have handle this object, skip it.
+if (std::find(std::begin(obj_names), std::end(obj_names), obj->name()) != std::end(obj_names)){
+continue;
+}
+const unsigned char *my_contents = obj->section_contents(obj->get_rand_shndx(".rand"), &rand_sec_len, false);
+std::string rand_input(reinterpret_cast<const char *>(my_contents), rand_sec_len);
+if(rand_sec_len > 0)
+{
+std::map<std::string, input2output>::iterator tmp_iter;
+tmp_iter = obj2input_tmp.find(obj->name());
+if (tmp_iter == obj2input_tmp.end()){
+gold_error(_("bbinfo: In update_shuffle_layout function, obj2input map does not have object %s"), 
+obj->name().c_str());
+continue;
+}
+reorder_info.ParseFromString(rand_input);
+this->add_shuffleInfo_obj(reorder_info, obj, tmp_iter->second);
+obj_names.push_back(obj->name());
+#ifdef CCR_MSG_DETAILS
+gold_info("\t>> %s", obj->name().c_str());
+#endif
+}
+}
+}
+}
+
+}
+
+// binpang, add. Add shuffle accourding to the output section
+template<int size, bool big_endian>
+void Layout::add_shuffleInfo_obj(ShuffleInfo::ReorderInfo& to_add_info,
+Sized_relobj_file<size, big_endian> *pfrom_object, 
+input2output &input2output_list
+){
+input2output::iterator tmp_iter;
+// copy from add_shuffleInfo function
+ShuffleInfo::ReorderInfo& gsi = get_global_shuffleInfo();
+ShuffleInfo::ReorderInfo_FixupInfo* pfixupinfo = NULL;
+ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* pfixuptuple = NULL;
+bool found_discarded_section = false;
+int i, j;
+
+
+typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
+//even when section reordering is conducted, it is guaranteed we get the latest out_offset
+const std::vector<Address>& out_offsets(pfrom_object->section_offsets());
+///update the [bin = 1]
+ShuffleInfo::ReorderInfo_BinaryInfo* pbininfo = gsi.mutable_bin();
+if(is_first_reorder_info()){
+saw_first_reorder_info();
+if(this->get_yarp_adjusted_start_off() == 0)
+pbininfo->set_rand_obj_offset(INT32_MAX);
+else
+//we have special sections at the beggining, jump over them to the first rand obj
+pbininfo->set_rand_obj_offset(this->get_yarp_adjusted_start_off());
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Initialize the offset to the object for randomization: 0x%x", pbininfo->rand_obj_offset());
+#endif
+}
+
+uint64_t accum_obj_text = 0;
+uint64_t text_size = 0;
+
+//CCR: loop through all input .text section(s)
+//CCR: the obj_id_map is guranteed won't contain special sections, so their size won't be counted
+// CCR: FIXED HERE (failed compilation without a local variable in gcc > 5.x)
+std::list<std::tuple<uint64_t, std::string, bool>> obj_id_map = pfrom_object->get_yarp_obj_id_map();
+for (std::list<std::tuple<uint64_t, std::string, bool>>::iterator it = obj_id_map.begin(); 
+it!= obj_id_map.end(); ++it) {
+uint64_t id;
+std::string name;
+bool visited;
+std::tie(id, name, visited) = *it;
+
+if (name.length() == 0) {
+//gold_info("[CCR] Empty name at obj_id=%d??", id);
+continue;
+}
+
+//since there won't be speicial sections in obj_id_map, assuming rest of the the sections will not have doppelganger
+text_size = pfrom_object->section_size(pfrom_object->get_text_shndx(name));
+
+#ifdef CCR_MSG_DETAILS
+gold_info("[KOO] [%3d] %s@%s (0x%lx) on add_shuffleInfo()@layout.cc", \
+id, name.c_str(), pfrom_object->name().c_str(), text_size);
+#endif
+
+if((pbininfo->rand_obj_offset() > out_offsets[pfrom_object->get_text_shndx(name)])
+&& ( text_size > 0) && (Layout::special_ordering_of_input_section(name.c_str()) < 0)) {
+pbininfo->set_rand_obj_offset(out_offsets[pfrom_object->get_text_shndx(name)]);
+
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Set the offset to the object for randomization: 0x%x (%s ObjSz=0x%x)", \
+out_offsets[pfrom_object->get_text_shndx(name)],
+pfrom_object->name().c_str(), text_size);
+#endif
+}
+}
+
+///update the [layout = 2]
+uint32_t accum_removed_child_fixups = 0;
+uint32_t redundant_section_size = 0;
+
+for (i = 0; i < to_add_info.layout_size(); ++i) {
+//CCR: check if current BBL belongs to discarded section
+if(!pfrom_object->yarp_text_section_exist(to_add_info.layout(i).section_name())) {
+do{
+j = i; //record current i
+redundant_section_size += to_add_info.layout(j).bb_size(); 
+accum_removed_child_fixups += to_add_info.layout(j).num_fixups();
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s:%s BBL#[%3d], accu redundant section size: %lx,Total removed fixups: %2d (0x%xB)",
+pfrom_object->name().c_str(), to_add_info.layout(j).section_name().c_str(), redundant_section_size,
+j, accum_removed_child_fixups, redundant_section_size);
+#endif
+++i; //advance i to point to the first BBL of next section
+if(i == to_add_info.layout_size()){
+// gold_info("hit the end");
+break;
+}
+} while((to_add_info.layout(j).type() != OBJ_BBL && 
+to_add_info.layout(j).type() != OBJ_FUNC_BBL) //i is pointing to next section, but if the next sec also discarded
+|| !pfrom_object->yarp_text_section_exist(to_add_info.layout(i).section_name()));
+} // binpang, add.
+
+if (i < to_add_info.layout_size()){
+//we gurrantte that when code reach here, we are only gonna deal with legit BBLs
+ShuffleInfo::ReorderInfo_LayoutInfo *playoutinfo = gsi.add_layout();
+//.text was processed before .rand, so we can obtain the text_paddng info here
+playoutinfo->set_type(to_add_info.layout(i).type());
+playoutinfo->set_num_fixups(to_add_info.layout(i).num_fixups());
+playoutinfo->set_bb_fallthrough(to_add_info.layout(i).bb_fallthrough());
+playoutinfo->set_assemble_type(to_add_info.layout(i).assemble_type());
+
+// binpang, add
+tmp_iter = input2output_list.find(to_add_info.layout(i).section_name());
+if (tmp_iter == input2output_list.end()){
+gold_error(_("[bbinfo]: Bug, in add_shuffleInfo_obj function. input section %s doesn't have corrosponding output section.")
+,to_add_info.layout(i).section_name().c_str());
+}else{
+// set the section name to the corrosponding output section
+playoutinfo->set_section_name(tmp_iter->second);
+}
+int offset_tmp = to_add_info.layout(i).offset() + out_offsets[pfrom_object->get_text_shndx(to_add_info.layout(i).section_name(), 0)];
+
+playoutinfo->set_offset(offset_tmp);
+#ifdef CCR_MSG_DETAILS
+gold_info("[bbinfo]: update bb offset from 0x%x to 0x%x", to_add_info.layout(i).offset(), offset_tmp);
+#endif
+
+if (to_add_info.layout(i).type() == OBJ_BBL || to_add_info.layout(i).type() == OBJ_FUNC_BBL) {
+//if this bb is at the end of an input section in the object, add paddings
+uint64_t obj_text_padding = this->get_yarp_obj_text_padding_map(pfrom_object->yarp_object_id(to_add_info.layout(i).section_name()));
+playoutinfo->set_bb_size(to_add_info.layout(i).bb_size() + obj_text_padding);
+playoutinfo->set_padding_size(to_add_info.layout(i).padding_size() + obj_text_padding);
+accum_obj_text +=  to_add_info.layout(i).bb_size() + obj_text_padding;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Update obj %s[%d] bb[%d] @.%s with padding %lu", pfrom_object->name().c_str(),
+pfrom_object->yarp_object_id(to_add_info.layout(i).section_name()), i, to_add_info.layout(i).section_name().c_str() ,obj_text_padding);
+#endif
+} else {
+//else, don't add padding
+playoutinfo->set_bb_size(to_add_info.layout(i).bb_size());
+playoutinfo->set_padding_size(to_add_info.layout(i).padding_size());
+accum_obj_text +=  to_add_info.layout(i).bb_size();
+}
+}
+}
+
+//the incremental size would be [current_num + input_sz + alignment(s)]
+#ifdef CCR_MSG_DETAILS
+gold_info("rand size for %s is 0x%llx", pfrom_object->name().c_str(), accum_obj_text);
+#endif
+uint32_t object_size = pbininfo->obj_sz() + accum_obj_text;
+pbininfo->set_obj_sz(object_size);
+
+///update the [fixup = 3]
+unsigned dup_section_order = 0; //for non-special sections, this should always be 0
+std::map<std::string, unsigned int>name_ndx_map;
+name_ndx_map.clear();
+
+if (!gsi.fixup_size())
+pfixupinfo = gsi.add_fixup(); //if we don't have one such global field yet
+else
+pfixupinfo = gsi.mutable_fixup(0);//if we already have it
+
+//add all the fixup with their computed section offset in the output section
+// at this point, .text, .rodata, .data, .data.rel.ro, and .init_array
+// for the current object should've been decided
+std::string obj_name = pfrom_object->name();
+for (i = 0; i < to_add_info.fixup_size(); ++i) {
+gold_assert(i < 1 && "[CCR-Error] shouldn't have more than one fixup_info"); 
+const ShuffleInfo::ReorderInfo_FixupInfo& to_add_fixup_info = to_add_info.fixup(i);
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .text Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+found_discarded_section = false;
+dup_section_order = 0;
+for (int j_1 = 0; j_1 < to_add_fixup_info.text_size(); ++j_1) {
+if(!pfrom_object->yarp_text_section_exist(to_add_fixup_info.text(j_1).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s Fixups[%d]", to_add_fixup_info.text(j_1).section_name().c_str(),j_1);
+#endif      
+++j_1; //advance j_1 to point to the first Fixups of next section
+if(j_1 == to_add_fixup_info.text_size()){
+// gold_info("hit the end (.text)");
+break;
+}
+}while(to_add_fixup_info.text(j_1).type() != NEW_SECTION_START_FIXUP || 
+!pfrom_object->yarp_text_section_exist(to_add_fixup_info.text(j_1).section_name()));
+}
+
+if(j_1 < to_add_fixup_info.text_size()){
+// When code reaches here, we are guaranteed to deal with legit fixups
+if(found_discarded_section){
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Resume with Fixup[%d], cur_fixup_text is %s, total record %d",
+j_1, to_add_fixup_info.text(j_1).section_name().c_str(), pfrom_object->yarp_get_text_num());
+#endif      
+found_discarded_section = false;
+}
+
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& text_fixup_tuple = to_add_fixup_info.text(j_1);
+
+
+if(text_fixup_tuple.type() == NEW_SECTION_START_FIXUP){
+if(name_ndx_map.find(text_fixup_tuple.section_name()) != name_ndx_map.end()){
+//fixup belongs to new section, but with duplicate name
+dup_section_order = ++name_ndx_map[text_fixup_tuple.section_name()];
+#ifdef CCR_MSG_DETAILS
+gold_info("See dup new section start for %s[%s],increment dup_order to %d",
+pfrom_object->name().c_str(),text_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}else{
+dup_section_order = 0;
+name_ndx_map[text_fixup_tuple.section_name()]=0; 
+#ifdef CCR_MSG_DETAILS
+gold_info("See new section start for %s[%s], reset dup_order to %d",
+pfrom_object->name().c_str(),text_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] (Fixup in %s[%s]) TY=%d, OFF:0x%x->0x%x, JTE=%d @layout.cc",
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(), text_fixup_tuple.section_name().c_str(),
+text_fixup_tuple.type(),
+text_fixup_tuple.offset(), 
+text_fixup_tuple.offset()+out_offsets[pfrom_object->get_text_shndx(text_fixup_tuple.section_name(), dup_section_order)],
+text_fixup_tuple.num_jt_entries());
+#endif      
+pfixuptuple = pfixupinfo->add_text();
+
+// binpang, add
+tmp_iter = input2output_list.find(text_fixup_tuple.section_name());
+if (tmp_iter == input2output_list.end()){
+gold_error(_("[bbinfo]: Bug, in add_shuffleInfo_obj function. input section %s doesn't have corrosponding output section.")
+,text_fixup_tuple.section_name().c_str());
+}else{
+// set the section name to the corrosponding output section
+pfixuptuple->set_section_name(tmp_iter->second);
+}
+pfixuptuple->set_offset(text_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_text_shndx(text_fixup_tuple.section_name(), dup_section_order)]);
+pfixuptuple->set_deref_sz(text_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(text_fixup_tuple.is_rela());
+// binpang, comment it out for now
+/*if((is_special_section_by_name(text_fixup_tuple.section_name().c_str()))){
+#ifdef CCR_MSG_DETAILS
+gold_info("found special section %s fixup, add to central bin, offset %x, shn[%d] offset %x",
+text_fixup_tuple.section_name().c_str(), pfixuptuple->offset()
+,pfrom_object->get_text_shndx(text_fixup_tuple.section_name(), dup_section_order)
+,out_offsets[pfrom_object->get_text_shndx(text_fixup_tuple.section_name(), dup_section_order)]);
+#endif
+pfixuptuple->set_type(SPECIAL_FIXUP); //set to special section type
+#ifdef CCR_MSG_DETAILS
+pfixuptuple->set_section_name(to_add_fixup_info.text(j_1).section_name()
++std::string("@")+std::to_string(dup_section_order)
++std::string("@")+pfrom_object->name());
+#endif
+}
+else{*/
+pfixuptuple->set_type(0); //set to C2C by default, so we cover compiler resolved ones
+// binpang, May cause the error...
+assert(dup_section_order == 0 && "WTF dup_order for non-special section is non-zero@layout.cc:2916");
+// }
+
+// CCR: added two optional fields for JT information (for pic/pie option)
+//      a) # of JTEs (jump table entries), b) the size of each entry
+pfixuptuple->set_num_jt_entries(text_fixup_tuple.num_jt_entries());
+pfixuptuple->set_jt_entry_sz(text_fixup_tuple.jt_entry_sz());
+}
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .rodata Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+dup_section_order=0;
+name_ndx_map.clear();
+found_discarded_section = false;
+for (int j_2 = 0; j_2 < to_add_fixup_info.rodata_size(); ++j_2){
+
+//CCR: check if current Fixup belongs to discarded section
+if(!pfrom_object->yarp_rodata_section_exist(to_add_fixup_info.rodata(j_2).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR]rodata Discard %s Fixups[%d]", to_add_fixup_info.rodata(j_2).section_name().c_str(),j_2);
+#endif
+++j_2; //advance j_2 to point to the first Fixups of next section
+if(j_2 == to_add_fixup_info.rodata_size()){
+// gold_info("hit the end (.rodata)");
+break;
+}
+}while(to_add_fixup_info.rodata(j_2).type() != NEW_SECTION_START_FIXUP ||
+!pfrom_object->yarp_rodata_section_exist(to_add_fixup_info.rodata(j_2).section_name()));
+}
+
+if(j_2 < to_add_fixup_info.rodata_size()){
+
+//we gurrantte that when code reach here, we are only gonna deal with legit fixups
+if(found_discarded_section){
+found_discarded_section = false;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] rodata Resume with Fixup[%d], cur_fixup_rodata is %s, total record: %d",
+j_2, to_add_fixup_info.rodata(j_2).section_name().c_str(), pfrom_object->yarp_get_rodata_num());
+#endif
+}
+
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& rodata_fixup_tuple = to_add_fixup_info.rodata(j_2);
+if(rodata_fixup_tuple.type() == NEW_SECTION_START_FIXUP){
+if(name_ndx_map.find(rodata_fixup_tuple.section_name()) != name_ndx_map.end()){
+//fixup belongs to new section, but with duplicate name
+dup_section_order = ++name_ndx_map[rodata_fixup_tuple.section_name()];
+#ifdef CCR_MSG_DETAILS
+gold_info("rodata See dup new section start for %s[%s],increment dup_order to %d",
+pfrom_object->name().c_str(),rodata_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}else{
+dup_section_order = 0;
+name_ndx_map[rodata_fixup_tuple.section_name()]=0; 
+#ifdef CCR_MSG_DETAILS
+gold_info("rodata See new section start for %s[%s], reset dup_order to %d",
+pfrom_object->name().c_str(),rodata_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] (rodata Fixup in %s[%s]) TY=%d, OFF:0x%x->0x%x @layout.cc",
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(), 
+rodata_fixup_tuple.section_name().c_str(), rodata_fixup_tuple.type(),
+rodata_fixup_tuple.offset(), 
+rodata_fixup_tuple.offset()+out_offsets[pfrom_object->get_rodata_shndx(to_add_fixup_info.rodata(j_2).section_name(), dup_section_order)]);
+#endif
+pfixuptuple = pfixupinfo->add_rodata();
+tmp_iter = input2output_list.find(to_add_fixup_info.rodata(j_2).section_name());
+if (tmp_iter == input2output_list.end()){
+gold_error(_("[bbinfo]: Bug, in add_shuffleInfo_obj function. input section %s doesn't have corrosponding output section.")
+, to_add_fixup_info.rodata(j_2).section_name().c_str());
+}else{
+// set the section name to the corrosponding output section
+pfixuptuple->set_section_name(tmp_iter->second);
+//  gold_info(_("add output section name in .rodata %s"), tmp_iter->second.c_str());
+}
+pfixuptuple->set_offset(rodata_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_rodata_shndx(to_add_fixup_info.rodata(j_2).section_name(), dup_section_order)]);
+pfixuptuple->set_deref_sz(rodata_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(rodata_fixup_tuple.is_rela());
+pfixuptuple->set_type(3); //set to D2D by default
+}
+
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .data Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+dup_section_order=0;
+name_ndx_map.clear();
+found_discarded_section = false;
+for (int j_3 = 0; j_3 < to_add_fixup_info.data_size(); ++j_3){
+
+//CCR: check if current Fixup belongs to discarded section
+if(!pfrom_object->yarp_data_section_exist(to_add_fixup_info.data(j_3).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s Fixups[%d]", to_add_fixup_info.data(j_3).section_name().c_str(),j_3);
+#endif
+++j_3; //advance j_3 to point to the first Fixups of next section
+if(j_3 == to_add_fixup_info.data_size()){
+// gold_info("hit the end (.data)");
+break;
+}
+}while(to_add_fixup_info.data(j_3).type() != NEW_SECTION_START_FIXUP ||
+!pfrom_object->yarp_data_section_exist(to_add_fixup_info.data(j_3).section_name()));
+}
+
+if(j_3 < to_add_fixup_info.data_size()){
+
+//we gurrantte that when code reach here, we are only gonna deal with legit fixups
+if(found_discarded_section){
+found_discarded_section = false;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Resume with Fixup[%d], cur_fixup_data is %s, total record: %d"
+,j_3, to_add_fixup_info.data(j_3).section_name().c_str(), pfrom_object->yarp_get_data_num());
+#endif
+}
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& data_fixup_tuple = to_add_fixup_info.data(j_3);
+if(data_fixup_tuple.type() == NEW_SECTION_START_FIXUP){
+if(name_ndx_map.find(data_fixup_tuple.section_name()) != name_ndx_map.end()){
+//fixup belongs to new section, but with duplicate name
+dup_section_order = ++name_ndx_map[data_fixup_tuple.section_name()];
+#ifdef CCR_MSG_DETAILS
+gold_info("See dup new section start for %s[%s],increment dup_order to %d",
+pfrom_object->name().c_str(),data_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}else{
+dup_section_order = 0;
+name_ndx_map[data_fixup_tuple.section_name()]=0; 
+#ifdef CCR_MSG_DETAILS
+gold_info("See new section start for %s[%s], reset dup_order to %d",
+pfrom_object->name().c_str(),data_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] (Fixup in %s) TY=%d, OFF:0x%x->0x%x @layout.cc",
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(), data_fixup_tuple.type(),
+data_fixup_tuple.offset(), 
+data_fixup_tuple.offset()+out_offsets[pfrom_object->get_data_shndx(to_add_fixup_info.data(j_3).section_name(), dup_section_order)]);
+#endif
+// binpang, add
+// add output section name
+pfixuptuple = pfixupinfo->add_data();
+tmp_iter = input2output_list.find(to_add_fixup_info.data(j_3).section_name());
+if (tmp_iter == input2output_list.end()){
+gold_error(_("[bbinfo]: Bug, in add_shuffleInfo_obj function. input section %s doesn't have corrosponding output section.")
+, to_add_fixup_info.data(j_3).section_name().c_str());
+}else{
+// set the section name to the corrosponding output section
+pfixuptuple->set_section_name(tmp_iter->second);
+}
+pfixuptuple->set_offset(data_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_data_shndx(to_add_fixup_info.data(j_3).section_name(), dup_section_order)]);
+pfixuptuple->set_deref_sz(data_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(data_fixup_tuple.is_rela());
+pfixuptuple->set_type(3); //set to D2D by default
+
+}
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .data.rel Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+found_discarded_section = false;
+for (int j_4 = 0; j_4 < to_add_fixup_info.datarel_size(); ++j_4){
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& datarel_fixup_tuple = to_add_fixup_info.datarel(j_4);
+
+//CCR: check if current Fixup belongs to discarded section
+if(!pfrom_object->yarp_datarel_section_exist(to_add_fixup_info.datarel(j_4).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s Fixups[%d]", to_add_fixup_info.datarel(j_4).section_name().c_str(),j_4);
+#endif
+++j_4; //advance j_4 to point to the first Fixups of next section
+if(j_4 == to_add_fixup_info.datarel_size()){
+// gold_info("hit the end (.data.rel.ro)");
+break;
+}
+}while(to_add_fixup_info.datarel(j_4).type() != NEW_SECTION_START_FIXUP ||
+!pfrom_object->yarp_datarel_section_exist(to_add_fixup_info.datarel(j_4).section_name()));
+}
+
+if(j_4 < to_add_fixup_info.datarel_size()){
+
+//we gurrantte that when code reach here, we are only gonna deal with legit fixups
+if(found_discarded_section){
+found_discarded_section = false;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Resume with Fixup[%d], cur_fixup_data is %s, total record: %d"
+,j_4, to_add_fixup_info.datarel(j_4).section_name().c_str(), pfrom_object->yarp_get_datarel_num());
+#endif
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] (Fixup in %s) TY=%d, OFF:0x%x->0x%x @layout.cc",
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(), datarel_fixup_tuple.type(),
+datarel_fixup_tuple.offset(), 
+datarel_fixup_tuple.offset()+out_offsets[pfrom_object->get_datarel_shndx(to_add_fixup_info.datarel(j_4).section_name())]);
+#endif
+
+pfixuptuple = pfixupinfo->add_datarel();
+// binpang, add, update output section name
+tmp_iter = input2output_list.find(to_add_fixup_info.datarel(j_4).section_name());
+if (tmp_iter == input2output_list.end()){
+gold_error(_("[bbinfo]: Bug, in add_shuffleInfo_obj function. input section %s doesn't have corrosponding output section.")
+, to_add_fixup_info.datarel(j_4).section_name().c_str());
+}else{
+// set the section name to the corrosponding output section
+pfixuptuple->set_section_name(tmp_iter->second);
+}
+pfixuptuple->set_offset(datarel_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_datarel_shndx(to_add_fixup_info.datarel(j_4).section_name())]);
+pfixuptuple->set_deref_sz(datarel_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(datarel_fixup_tuple.is_rela());
+pfixuptuple->set_type(3); //set to D2D by default
+}
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .init_array Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+dup_section_order=0;
+name_ndx_map.clear();
+found_discarded_section = false;
+// .init_array section for adding fixups (Hopefully no discarding sections here) 
+for (int j_5 = 0; j_5 < to_add_fixup_info.initarray_size(); ++j_5) {
+//CCR: check if current Fixup belongs to discarded section
+if(!pfrom_object->yarp_initarray_section_exist(to_add_fixup_info.initarray(j_5).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s Fixups[%d]", to_add_fixup_info.initarray(j_5).section_name().c_str(),j_5);
+#endif
+++j_5; //advance j_5 to point to the first Fixups of next section
+if(j_5 == to_add_fixup_info.initarray_size()){
+// gold_info("hit the end (.init_array)");
+break;
+}
+}while(to_add_fixup_info.initarray(j_5).type() != NEW_SECTION_START_FIXUP ||
+!pfrom_object->yarp_initarray_section_exist(to_add_fixup_info.initarray(j_5).section_name()));
+}
+
+if(j_5 < to_add_fixup_info.initarray_size()){
+
+//we gurrantte that when code reach here, we are only gonna deal with legit fixups
+if(found_discarded_section){
+found_discarded_section = false;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Resume with Fixup[%d], cur_fixup_data is %s, total record: %d"
+,j_5, to_add_fixup_info.initarray(j_5).section_name().c_str(), pfrom_object->yarp_get_initarray_num());
+#endif
+}
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& initarray_fixup_tuple = to_add_fixup_info.initarray(j_5);
+if(initarray_fixup_tuple.type() == NEW_SECTION_START_FIXUP){
+if(name_ndx_map.find(initarray_fixup_tuple.section_name()) != name_ndx_map.end()){
+//fixup belongs to new section, but with duplicate name
+dup_section_order = ++name_ndx_map[initarray_fixup_tuple.section_name()];
+#ifdef CCR_MSG_DETAILS
+gold_info("See dup new section start for %s[%s],increment dup_order to %d",
+pfrom_object->name().c_str(),initarray_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}else{
+dup_section_order = 1;
+name_ndx_map[initarray_fixup_tuple.section_name()]=1; 
+gold_info("[CCR-warning] Fixup for .init_array does not start with type NewSectionStart, setting dup_section_order to %d", dup_section_order);
+#ifdef CCR_MSG_DETAILS
+gold_info("See new section start for %s[%s], reset dup_order to %d",
+pfrom_object->name().c_str(),initarray_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] ((order %d)Fixup in %s#%d[%s]) TY=%d, OFF:0x%x->0x%x @layout.cc", dup_section_order,
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(),
+pfrom_object->get_initarray_shndx(to_add_fixup_info.initarray(j_5).section_name(), dup_section_order) ,initarray_fixup_tuple.section_name().c_str(),initarray_fixup_tuple.type(), initarray_fixup_tuple.offset(), 
+initarray_fixup_tuple.offset()+out_offsets[pfrom_object->get_initarray_shndx(to_add_fixup_info.initarray(j_5).section_name(), dup_section_order)]);
+#endif
+// binpang, add
+// update output section name
+pfixuptuple = pfixupinfo->add_initarray();
+tmp_iter = input2output_list.find(to_add_fixup_info.initarray(j_5).section_name());
+if (tmp_iter == input2output_list.end()){
+gold_error(_("[bbinfo]: Bug, in add_shuffleInfo_obj function. input section %s doesn't have corrosponding output section.")
+, to_add_fixup_info.initarray(j_5).section_name().c_str());
+}else{
+// set the section name to the corrosponding output section
+pfixuptuple->set_section_name(tmp_iter->second);
+}
+
+pfixuptuple->set_offset(initarray_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_initarray_shndx(to_add_fixup_info.initarray(j_5).section_name(), dup_section_order)]);
+pfixuptuple->set_deref_sz(initarray_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(initarray_fixup_tuple.is_rela());
+pfixuptuple->set_type(3); //set to D2D by default
+}
+}
+}
+
+///update the [source = 4]
+//   Add the source type of object file
+//   [generalSource | inlineAssembly, standaloneAssembly] = (0-2)
+if (accum_obj_text > 0) {
+ShuffleInfo::ReorderInfo_SourceInfo* psrcinfo = gsi.mutable_source();
+psrcinfo->add_src_type(to_add_info.bin().src_type());
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Added source type for %s: %d + %d = %d", pfrom_object->name().c_str(), pbininfo->obj_sz(), accum_obj_text, object_size);
+#endif
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++AddShuffleInfo End+++");
+#endif
+}
+
+//CCR: use this API to collect the given reorderInfo into our global_reorderInfo
+//      since the input from_object is a template, this function is also made templated 
+//
+//NOTE: the syncronization and the order issue is taken cared by the upper layer Add_symbols Task
+//         here we are gurrantted to execute this function sequentially according to the input objects order
+//
+
+template<int size, bool big_endian>
+void
+Layout::add_shuffleInfo(ShuffleInfo::ReorderInfo& to_add_info,
+Sized_relobj_file<size, big_endian> *pfrom_object)
+{
+ShuffleInfo::ReorderInfo& gsi = get_global_shuffleInfo();
+ShuffleInfo::ReorderInfo_FixupInfo* pfixupinfo = NULL;
+ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* pfixuptuple = NULL;
+bool found_discarded_section = false;
+int i, j;
+
+typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;
+//even when section reordering is conducted, it is guaranteed we get the latest out_offset
+const std::vector<Address>& out_offsets(pfrom_object->section_offsets());
+///update the [bin = 1]
+ShuffleInfo::ReorderInfo_BinaryInfo* pbininfo = gsi.mutable_bin();
+if(is_first_reorder_info()){
+saw_first_reorder_info();
+if(this->get_yarp_adjusted_start_off() == 0)
+pbininfo->set_rand_obj_offset(INT32_MAX);
+else
+//we have special sections at the beggining, jump over them to the first rand obj
+pbininfo->set_rand_obj_offset(this->get_yarp_adjusted_start_off());
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Initialize the offset to the object for randomization: 0x%x", pbininfo->rand_obj_offset());
+#endif
+}
+
+uint64_t accum_obj_text = 0;
+uint64_t text_size = 0;
+
+//CCR: loop through all input .text section(s)
+//CCR: the obj_id_map is guranteed won't contain special sections, so their size won't be counted
+// CCR: FIXED HERE (failed compilation without a local variable in gcc > 5.x)
+std::list<std::tuple<uint64_t, std::string, bool>> obj_id_map = pfrom_object->get_yarp_obj_id_map();
+for (std::list<std::tuple<uint64_t, std::string, bool>>::iterator it = obj_id_map.begin(); 
+it!= obj_id_map.end(); ++it) {
+uint64_t id;
+std::string name;
+bool visited;
+std::tie(id, name, visited) = *it;
+
+if (name.length() == 0) {
+//gold_info("[CCR] Empty name at obj_id=%d??", id);
+continue;
+}
+
+//since there won't be speicial sections in obj_id_map, assuming rest of the the sections will not have doppelganger
+text_size = pfrom_object->section_size(pfrom_object->get_text_shndx(name));
+
+#ifdef CCR_MSG_DETAILS
+gold_info("[KOO] [%3d] %s@%s (0x%lx) on add_shuffleInfo()@layout.cc", \
+id, name.c_str(), pfrom_object->name().c_str(), text_size);
+#endif
+
+if((pbininfo->rand_obj_offset() > out_offsets[pfrom_object->get_text_shndx(name)])
+&& ( text_size > 0) && (Layout::special_ordering_of_input_section(name.c_str()) < 0)) {
+pbininfo->set_rand_obj_offset(out_offsets[pfrom_object->get_text_shndx(name)]);
+
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Set the offset to the object for randomization: 0x%x (%s ObjSz=0x%x)", \
+out_offsets[pfrom_object->get_text_shndx(name)],
+pfrom_object->name().c_str(), text_size);
+#endif
+}
+}
+
+///update the [layout = 2]
+uint32_t accum_removed_child_fixups = 0;
+uint32_t redundant_section_size = 0;
+
+for (i = 0; i < to_add_info.layout_size(); ++i) {
+//CCR: check if current BBL belongs to discarded section
+//    check if current BBL belongs to special section
+if(!pfrom_object->yarp_text_section_exist(to_add_info.layout(i).section_name()) ||
+(is_special_section_by_name(to_add_info.layout(i).section_name().c_str()))) {
+do{
+j = i; //record current i
+redundant_section_size += to_add_info.layout(j).bb_size(); 
+accum_removed_child_fixups += to_add_info.layout(j).num_fixups();
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s:%s BBL#[%3d], accu redundant section size: %lx,Total removed fixups: %2d (0x%xB)",
+pfrom_object->name().c_str(), to_add_info.layout(j).section_name().c_str(), redundant_section_size,
+j, accum_removed_child_fixups, redundant_section_size);
+#endif
+++i; //advance i to point to the first BBL of next section
+if(i == to_add_info.layout_size()){
+// gold_info("hit the end");
+break;
+}
+} while(to_add_info.layout(j).type() != OBJ_BBL //i is pointing to next section, but if the next sec also discarded
+|| !pfrom_object->yarp_text_section_exist(to_add_info.layout(i).section_name())
+|| is_special_section_by_name(to_add_info.layout(i).section_name().c_str()));
+}
+
+if (i < to_add_info.layout_size()){
+//we gurrantte that when code reach here, we are only gonna deal with legit BBLs
+ShuffleInfo::ReorderInfo_LayoutInfo *playoutinfo = gsi.add_layout();
+//.text was processed before .rand, so we can obtain the text_paddng info here
+playoutinfo->set_type(to_add_info.layout(i).type());
+playoutinfo->set_num_fixups(to_add_info.layout(i).num_fixups());
+playoutinfo->set_bb_fallthrough(to_add_info.layout(i).bb_fallthrough());
+
+if (to_add_info.layout(i).type() == OBJ_BBL || to_add_info.layout(i).type() == OBJ_FUNC_BBL) {
+//if this bb is at the end of an input section in the object, add paddings
+uint64_t obj_text_padding = this->get_yarp_obj_text_padding_map(pfrom_object->yarp_object_id(to_add_info.layout(i).section_name()));
+playoutinfo->set_bb_size(to_add_info.layout(i).bb_size() + obj_text_padding);
+playoutinfo->set_padding_size(to_add_info.layout(i).padding_size() + obj_text_padding);
+accum_obj_text +=  to_add_info.layout(i).bb_size() + obj_text_padding;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Update obj %s[%d] bb[%d] @.%s with padding %lu", pfrom_object->name().c_str(),
+pfrom_object->yarp_object_id(to_add_info.layout(i).section_name()), i, to_add_info.layout(i).section_name().c_str() ,obj_text_padding);
+#endif
+} else {
+//else, don't add padding
+playoutinfo->set_bb_size(to_add_info.layout(i).bb_size());
+playoutinfo->set_padding_size(to_add_info.layout(i).padding_size());
+accum_obj_text +=  to_add_info.layout(i).bb_size();
+}
+}
+}
+
+//the incremental size would be [current_num + input_sz + alignment(s)]
+#ifdef CCR_MSG_DETAILS
+gold_info("rand size for %s is 0x%llx", pfrom_object->name().c_str(), accum_obj_text);
+#endif
+uint32_t object_size = pbininfo->obj_sz() + accum_obj_text;
+pbininfo->set_obj_sz(object_size);
+
+///update the [fixup = 3]
+unsigned dup_section_order = 0; //for non-special sections, this should always be 0
+std::map<std::string, unsigned int>name_ndx_map;
+name_ndx_map.clear();
+
+if (!gsi.fixup_size())
+pfixupinfo = gsi.add_fixup(); //if we don't have one such global field yet
+else
+pfixupinfo = gsi.mutable_fixup(0);//if we already have it
+
+//add all the fixup with their computed section offset in the output section
+// at this point, .text, .rodata, .data, .data.rel.ro, and .init_array
+// for the current object should've been decided
+std::string obj_name = pfrom_object->name();
+for (i = 0; i < to_add_info.fixup_size(); ++i) {
+gold_assert(i < 1 && "[CCR-Error] shouldn't have more than one fixup_info"); 
+const ShuffleInfo::ReorderInfo_FixupInfo& to_add_fixup_info = to_add_info.fixup(i);
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .text Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+found_discarded_section = false;
+dup_section_order = 0;
+for (int j_1 = 0; j_1 < to_add_fixup_info.text_size(); ++j_1) {
+if(!pfrom_object->yarp_text_section_exist(to_add_fixup_info.text(j_1).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s Fixups[%d]", to_add_fixup_info.text(j_1).section_name().c_str(),j_1);
+#endif      
+++j_1; //advance j_1 to point to the first Fixups of next section
+if(j_1 == to_add_fixup_info.text_size()){
+// gold_info("hit the end (.text)");
+break;
+}
+}while(to_add_fixup_info.text(j_1).type() != NEW_SECTION_START_FIXUP || 
+!pfrom_object->yarp_text_section_exist(to_add_fixup_info.text(j_1).section_name()));
+}
+
+if(j_1 < to_add_fixup_info.text_size()){
+// When code reaches here, we are guaranteed to deal with legit fixups
+if(found_discarded_section){
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Resume with Fixup[%d], cur_fixup_text is %s, total record %d",
+j_1, to_add_fixup_info.text(j_1).section_name().c_str(), pfrom_object->yarp_get_text_num());
+#endif      
+found_discarded_section = false;
+}
+
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& text_fixup_tuple = to_add_fixup_info.text(j_1);
+
+if(text_fixup_tuple.type() == NEW_SECTION_START_FIXUP){
+if(name_ndx_map.find(text_fixup_tuple.section_name()) != name_ndx_map.end()){
+//fixup belongs to new section, but with duplicate name
+dup_section_order = ++name_ndx_map[text_fixup_tuple.section_name()];
+#ifdef CCR_MSG_DETAILS
+gold_info("See dup new section start for %s[%s],increment dup_order to %d",
+pfrom_object->name().c_str(),text_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}else{
+dup_section_order = 0;
+name_ndx_map[text_fixup_tuple.section_name()]=0; 
+#ifdef CCR_MSG_DETAILS
+gold_info("See new section start for %s[%s], reset dup_order to %d",
+pfrom_object->name().c_str(),text_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] (Fixup in %s[%s]) TY=%d, OFF:0x%x->0x%x, JTE=%d @layout.cc",
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(), text_fixup_tuple.section_name().c_str(),
+text_fixup_tuple.type(),
+text_fixup_tuple.offset(), 
+text_fixup_tuple.offset()+out_offsets[pfrom_object->get_text_shndx(text_fixup_tuple.section_name(), dup_section_order)],
+text_fixup_tuple.num_jt_entries());
+#endif      
+pfixuptuple = pfixupinfo->add_text();
+
+pfixuptuple->set_offset(text_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_text_shndx(text_fixup_tuple.section_name(), dup_section_order)]);
+pfixuptuple->set_deref_sz(text_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(text_fixup_tuple.is_rela());
+if((is_special_section_by_name(text_fixup_tuple.section_name().c_str()))){
+#ifdef CCR_MSG_DETAILS
+gold_info("found special section %s fixup, add to central bin, offset %x, shn[%d] offset %x",
+text_fixup_tuple.section_name().c_str(), pfixuptuple->offset()
+,pfrom_object->get_text_shndx(text_fixup_tuple.section_name(), dup_section_order)
+,out_offsets[pfrom_object->get_text_shndx(text_fixup_tuple.section_name(), dup_section_order)]);
+#endif
+pfixuptuple->set_type(SPECIAL_FIXUP); //set to special section type
+#ifdef CCR_MSG_DETAILS
+pfixuptuple->set_section_name(to_add_fixup_info.text(j_1).section_name()
++std::string("@")+std::to_string(dup_section_order)
++std::string("@")+pfrom_object->name());
+#endif
+}
+else{
+pfixuptuple->set_type(0); //set to C2C by default, so we cover compiler resolved ones
+assert(dup_section_order == 0 && "WTF dup_order for non-special section is non-zero@layout.cc:2916");
+}
+
+// CCR: added two optional fields for JT information (for pic/pie option)
+//      a) # of JTEs (jump table entries), b) the size of each entry
+pfixuptuple->set_num_jt_entries(text_fixup_tuple.num_jt_entries());
+pfixuptuple->set_jt_entry_sz(text_fixup_tuple.jt_entry_sz());
+}
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .rodata Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+dup_section_order=0;
+name_ndx_map.clear();
+found_discarded_section = false;
+for (int j_2 = 0; j_2 < to_add_fixup_info.rodata_size(); ++j_2){
+
+//CCR: check if current Fixup belongs to discarded section
+if(!pfrom_object->yarp_rodata_section_exist(to_add_fixup_info.rodata(j_2).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR]rodata Discard %s Fixups[%d]", to_add_fixup_info.rodata(j_2).section_name().c_str(),j_2);
+#endif
+++j_2; //advance j_2 to point to the first Fixups of next section
+if(j_2 == to_add_fixup_info.rodata_size()){
+// gold_info("hit the end (.rodata)");
+break;
+}
+}while(to_add_fixup_info.rodata(j_2).type() != NEW_SECTION_START_FIXUP ||
+!pfrom_object->yarp_rodata_section_exist(to_add_fixup_info.rodata(j_2).section_name()));
+}
+
+if(j_2 < to_add_fixup_info.rodata_size()){
+
+//we gurrantte that when code reach here, we are only gonna deal with legit fixups
+if(found_discarded_section){
+found_discarded_section = false;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] rodata Resume with Fixup[%d], cur_fixup_rodata is %s, total record: %d",
+j_2, to_add_fixup_info.rodata(j_2).section_name().c_str(), pfrom_object->yarp_get_rodata_num());
+#endif
+}
+
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& rodata_fixup_tuple = to_add_fixup_info.rodata(j_2);
+if(rodata_fixup_tuple.type() == NEW_SECTION_START_FIXUP){
+if(name_ndx_map.find(rodata_fixup_tuple.section_name()) != name_ndx_map.end()){
+//fixup belongs to new section, but with duplicate name
+dup_section_order = ++name_ndx_map[rodata_fixup_tuple.section_name()];
+#ifdef CCR_MSG_DETAILS
+gold_info("rodata See dup new section start for %s[%s],increment dup_order to %d",
+pfrom_object->name().c_str(),rodata_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}else{
+dup_section_order = 0;
+name_ndx_map[rodata_fixup_tuple.section_name()]=0; 
+#ifdef CCR_MSG_DETAILS
+gold_info("rodata See new section start for %s[%s], reset dup_order to %d",
+pfrom_object->name().c_str(),rodata_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] (rodata Fixup in %s[%s]) TY=%d, OFF:0x%x->0x%x @layout.cc",
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(), 
+rodata_fixup_tuple.section_name().c_str(), 
+rodata_fixup_tuple.type(),
+rodata_fixup_tuple.offset(), 
+rodata_fixup_tuple.offset()+out_offsets[pfrom_object->get_rodata_shndx(to_add_fixup_info.rodata(j_2).section_name(), dup_section_order)]);
+#endif
+pfixuptuple = pfixupinfo->add_rodata();
+pfixuptuple->set_offset(rodata_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_rodata_shndx(to_add_fixup_info.rodata(j_2).section_name(), dup_section_order)]);
+pfixuptuple->set_deref_sz(rodata_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(rodata_fixup_tuple.is_rela());
+pfixuptuple->set_type(3); //set to D2D by default
+#ifdef CCR_MSG_DETAILS
+pfixuptuple->set_section_name(rodata_fixup_tuple.section_name()
++std::string("@")+std::to_string(dup_section_order)
++std::string("@")+pfrom_object->name());
+#endif
+}
+
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .data Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+dup_section_order=0;
+name_ndx_map.clear();
+found_discarded_section = false;
+for (int j_3 = 0; j_3 < to_add_fixup_info.data_size(); ++j_3){
+
+//CCR: check if current Fixup belongs to discarded section
+if(!pfrom_object->yarp_data_section_exist(to_add_fixup_info.data(j_3).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s Fixups[%d]", to_add_fixup_info.data(j_3).section_name().c_str(),j_3);
+#endif
+++j_3; //advance j_3 to point to the first Fixups of next section
+if(j_3 == to_add_fixup_info.data_size()){
+// gold_info("hit the end (.data)");
+break;
+}
+}while(to_add_fixup_info.data(j_3).type() != NEW_SECTION_START_FIXUP ||
+!pfrom_object->yarp_data_section_exist(to_add_fixup_info.data(j_3).section_name()));
+}
+
+if(j_3 < to_add_fixup_info.data_size()){
+
+//we gurrantte that when code reach here, we are only gonna deal with legit fixups
+if(found_discarded_section){
+found_discarded_section = false;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Resume with Fixup[%d], cur_fixup_data is %s, total record: %d"
+,j_3, to_add_fixup_info.data(j_3).section_name().c_str(), pfrom_object->yarp_get_data_num());
+#endif
+}
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& data_fixup_tuple = to_add_fixup_info.data(j_3);
+if(data_fixup_tuple.type() == NEW_SECTION_START_FIXUP){
+if(name_ndx_map.find(data_fixup_tuple.section_name()) != name_ndx_map.end()){
+//fixup belongs to new section, but with duplicate name
+dup_section_order = ++name_ndx_map[data_fixup_tuple.section_name()];
+#ifdef CCR_MSG_DETAILS
+gold_info("See dup new section start for %s[%s],increment dup_order to %d",
+pfrom_object->name().c_str(),data_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}else{
+dup_section_order = 0;
+name_ndx_map[data_fixup_tuple.section_name()]=0; 
+#ifdef CCR_MSG_DETAILS
+gold_info("See new section start for %s[%s], reset dup_order to %d",
+pfrom_object->name().c_str(),data_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] (Fixup in %s) TY=%d, OFF:0x%x->0x%x @layout.cc",
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(), data_fixup_tuple.type(),
+data_fixup_tuple.offset(), 
+data_fixup_tuple.offset()+out_offsets[pfrom_object->get_data_shndx(to_add_fixup_info.data(j_3).section_name(), dup_section_order)]);
+#endif
+pfixuptuple = pfixupinfo->add_data();
+pfixuptuple->set_offset(data_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_data_shndx(to_add_fixup_info.data(j_3).section_name(), dup_section_order)]);
+pfixuptuple->set_deref_sz(data_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(data_fixup_tuple.is_rela());
+pfixuptuple->set_type(3); //set to D2D by default
+
+#ifdef CCR_MSG_DETAILS
+pfixuptuple->set_section_name(data_fixup_tuple.section_name()
++std::string("@")+std::to_string(dup_section_order)
++std::string("@")+pfrom_object->name());
+#endif
+}
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .data.rel Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+found_discarded_section = false;
+for (int j_4 = 0; j_4 < to_add_fixup_info.datarel_size(); ++j_4){
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& datarel_fixup_tuple = to_add_fixup_info.datarel(j_4);
+
+//CCR: check if current Fixup belongs to discarded section
+if(!pfrom_object->yarp_datarel_section_exist(to_add_fixup_info.datarel(j_4).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s Fixups[%d]", to_add_fixup_info.datarel(j_4).section_name().c_str(),j_4);
+#endif
+++j_4; //advance j_4 to point to the first Fixups of next section
+if(j_4 == to_add_fixup_info.datarel_size()){
+// gold_info("hit the end (.data.rel.ro)");
+break;
+}
+}while(to_add_fixup_info.datarel(j_4).type() != NEW_SECTION_START_FIXUP ||
+!pfrom_object->yarp_datarel_section_exist(to_add_fixup_info.datarel(j_4).section_name()));
+}
+
+if(j_4 < to_add_fixup_info.datarel_size()){
+
+//we gurrantte that when code reach here, we are only gonna deal with legit fixups
+if(found_discarded_section){
+found_discarded_section = false;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Resume with Fixup[%d], cur_fixup_data is %s, total record: %d"
+,j_4, to_add_fixup_info.datarel(j_4).section_name().c_str(), pfrom_object->yarp_get_datarel_num());
+#endif
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] (Fixup in %s) TY=%d, OFF:0x%x->0x%x @layout.cc",
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(), datarel_fixup_tuple.type(),
+datarel_fixup_tuple.offset(), 
+datarel_fixup_tuple.offset()+out_offsets[pfrom_object->get_datarel_shndx(to_add_fixup_info.datarel(j_4).section_name())]);
+#endif
+pfixuptuple = pfixupinfo->add_datarel();
+pfixuptuple->set_offset(datarel_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_datarel_shndx(to_add_fixup_info.datarel(j_4).section_name())]);
+pfixuptuple->set_deref_sz(datarel_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(datarel_fixup_tuple.is_rela());
+pfixuptuple->set_type(3); //set to D2D by default
+}
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++ .init_array Start (%s)+++", obj_name.substr(obj_name.find_last_of("/")+1).c_str());
+#endif
+dup_section_order=0;
+name_ndx_map.clear();
+found_discarded_section = false;
+// .init_array section for adding fixups (Hopefully no discarding sections here) 
+for (int j_5 = 0; j_5 < to_add_fixup_info.initarray_size(); ++j_5) {
+//CCR: check if current Fixup belongs to discarded section
+if(!pfrom_object->yarp_initarray_section_exist(to_add_fixup_info.initarray(j_5).section_name())){
+found_discarded_section = true;
+//CCR: we have Fixups from redundant and discarded section
+do{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Discard %s Fixups[%d]", to_add_fixup_info.initarray(j_5).section_name().c_str(),j_5);
+#endif
+++j_5; //advance j_5 to point to the first Fixups of next section
+if(j_5 == to_add_fixup_info.initarray_size()){
+// gold_info("hit the end (.init_array)");
+break;
+}
+}while(to_add_fixup_info.initarray(j_5).type() != NEW_SECTION_START_FIXUP ||
+!pfrom_object->yarp_initarray_section_exist(to_add_fixup_info.initarray(j_5).section_name()));
+}
+
+if(j_5 < to_add_fixup_info.initarray_size()){
+
+//we gurrantte that when code reach here, we are only gonna deal with legit fixups
+if(found_discarded_section){
+found_discarded_section = false;
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Resume with Fixup[%d], cur_fixup_data is %s, total record: %d"
+,j_5, to_add_fixup_info.initarray(j_5).section_name().c_str(), pfrom_object->yarp_get_initarray_num());
+#endif
+}
+const ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& initarray_fixup_tuple = to_add_fixup_info.initarray(j_5);
+if(initarray_fixup_tuple.type() == NEW_SECTION_START_FIXUP){
+if(name_ndx_map.find(initarray_fixup_tuple.section_name()) != name_ndx_map.end()){
+//fixup belongs to new section, but with duplicate name
+dup_section_order = ++name_ndx_map[initarray_fixup_tuple.section_name()];
+#ifdef CCR_MSG_DETAILS
+gold_info("See dup new section start for %s[%s],increment dup_order to %d",
+pfrom_object->name().c_str(),initarray_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}else{
+dup_section_order = 1;
+name_ndx_map[initarray_fixup_tuple.section_name()]=1; 
+gold_info("[CCR-warning] Fixup for .init_array does not start with type NewSectionStart, setting dup_section_order to %d", dup_section_order);
+#ifdef CCR_MSG_DETAILS
+gold_info("See new section start for %s[%s], reset dup_order to %d",
+pfrom_object->name().c_str(),initarray_fixup_tuple.section_name().c_str(),dup_section_order);
+#endif
+}
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] ((order %d)Fixup in %s#%d[%s]) TY=%d, OFF:0x%x->0x%x @layout.cc", dup_section_order,
+obj_name.substr(obj_name.find_last_of("/")+1).c_str(),
+pfrom_object->get_initarray_shndx(to_add_fixup_info.initarray(j_5).section_name(), dup_section_order) ,initarray_fixup_tuple.section_name().c_str(),initarray_fixup_tuple.type(), initarray_fixup_tuple.offset(), 
+initarray_fixup_tuple.offset()+out_offsets[pfrom_object->get_initarray_shndx(to_add_fixup_info.initarray(j_5).section_name(), dup_section_order)]);
+#endif
+pfixuptuple = pfixupinfo->add_initarray();
+pfixuptuple->set_offset(initarray_fixup_tuple.offset()
++ out_offsets[pfrom_object->get_initarray_shndx(to_add_fixup_info.initarray(j_5).section_name(), dup_section_order)]);
+pfixuptuple->set_deref_sz(initarray_fixup_tuple.deref_sz());
+pfixuptuple->set_is_rela(initarray_fixup_tuple.is_rela());
+pfixuptuple->set_type(3); //set to D2D by default
+pfixuptuple->set_section_name(initarray_fixup_tuple.section_name()
++std::string("@")+std::to_string(dup_section_order)
++std::string("@")+pfrom_object->name());
+}
+}
+}
+
+///update the [source = 4]
+//   Add the source type of object file
+//   [generalSource | inlineAssembly, standaloneAssembly] = (0-2)
+if (accum_obj_text > 0) {
+ShuffleInfo::ReorderInfo_SourceInfo* psrcinfo = gsi.mutable_source();
+psrcinfo->add_src_type(to_add_info.bin().src_type());
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Added source type for %s: %d + %d = %d", pfrom_object->name().c_str(), pbininfo->obj_sz(), accum_obj_text, object_size);
+#endif
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("+++AddShuffleInfo End+++");
+#endif
+}
 // Prepare for relaxation.
 
 void
@@ -2776,6 +4411,13 @@
 while (target->may_relax()
 && target->relax(pass, input_objects, symtab, this, task));
 
+// [CCR] Koo - update all shuffleInfo at this point when layout is almost finalized
+//this->update_shuffleInfo<64, false>();
+this->update_shuffleInfo_layout<64, false>();
+ShuffleInfo::ReorderInfo& reorder_info = this->get_global_shuffleInfo();
+ShuffleInfo::ReorderInfo_FixupInfo* p_fixup_info = reorder_info.mutable_fixup(0) ;
+record_shuffle_fixups(p_fixup_info);
+
 // If there is a load segment that contains the file and program headers,
 // provide a symbol __ehdr_start pointing there.
 // A program can use this to examine itself robustly.
@@ -2841,12 +4483,16 @@
 
 file_header->set_section_info(this->section_headers_, shstrtab_section);
 
+// binpang, add
+//this->update_shuffleInfo_layout<64, false>();
+
 // Now we know exactly where everything goes in the output file
 // (except for non-allocated sections which require postprocessing).
 Output_data::layout_complete();
 
 this->output_file_size_ = off;
 
+
 return off;
 }
 
@@ -3774,6 +5420,15 @@
 // Set the file offset of all the sections not associated with a
 // segment.
 
+//CCR: the most hack of all the modification is here
+//we hook this function such that when processing .rand section,
+//  we only write to the output .rand once
+//  at the same time we need to adjust the output offset and length etc.
+//  FIXME: if possible, our design should be following the concatenation nature of linking sections
+//               instead of interleving the input object sections into the output section 
+
+//the instrumented code all start with:
+//    "if(is_rand_section)"
 off_t
 Layout::set_section_offsets(off_t off, Layout::Section_offset_pass pass)
 {
@@ -3784,6 +5439,20 @@
 p != this->unattached_section_list_.end();
 ++p)
 {
+
+//CCR:we only process .rand once 
+// bool is_rand_section = !strcmp((*p)->name(), ".rand");
+// if(is_rand_section && this->shuffleInfo_has_adjusted_offset())
+//   continue;
+
+// std::string *pserialized_shuffle_info = NULL;
+// if(is_rand_section)
+// {
+//     pserialized_shuffle_info = this->serialize_shuffle_info();
+//     this->saw_shuffleInfo_adjusted_offset();
+// }
+
+
 // The symtab section is handled in create_symtab_sections.
 if (*p == this->symtab_section_)
 continue;
@@ -3815,7 +5484,18 @@
 {
 off = align_address(off, (*p)->addralign());
 (*p)->set_file_offset(off);
+
+//CCR: update the size of the .rand section
+// if(is_rand_section)
+// {
+//     (*p)->yarp_set_data_size(pserialized_shuffle_info->length());
+// }
+// else
+// {
 (*p)->finalize_data_size();
+// }
+//CCR: we need to record os .text's base address in order to
+//           calculate the final main off from .text
 }
 else
 {
@@ -3849,6 +5529,7 @@
 ? (*p)->output_section()->name() : "(special)"));
 }
 
+//CCR: we have adjusted the data_size_ above, so here it will apply the new data size
 off += (*p)->data_size();
 if (off > maxoff)
 maxoff = off;
@@ -5650,6 +7331,7 @@
 unsigned char* array_of_hashes = NULL;
 size_t size_of_hashes = 0;
 
+
 if (strcmp(this->options_->build_id(), "tree") == 0
 && this->options_->build_id_chunk_size_for_treehash() > 0
 && filesize > 0
@@ -5693,6 +7375,25 @@
 void
 Close_task_runner::run(Workqueue*, const Task*)
 {
+// CCR: we only care about 64 bit main symbol here
+Layout * my_layout = const_cast<Layout *>(this->layout_);
+if(my_layout->get_global_shuffleInfo().has_bin())
+{
+// CCR: writing the complete shuffleinfo into file 
+std::string fileName = std::string(this->of_->filename());
+fileName += ".shuffle.bin";
+std::fstream output(fileName.c_str(), std::ios::out | std::ios::trunc | std::ios::binary);
+
+//CCR:write_out
+if (!my_layout->get_global_shuffleInfo().SerializeToOstream(&output)) {
+gold_info( "Failed to write the ShuffleInfo to %s", fileName.c_str());
+}
+else {
+//gold_info( "Successfully wrote the ShuffleInfo to %s", fileName.c_str());
+gold_info( "Successfully wrote the ShuffleInfo to the .rand section!");
+}
+}
+
 // At this point the multi-threaded part of the build ID computation,
 // if any, is done.  See Build_id_task_runner.
 this->layout_->write_build_id(this->of_, this->array_of_hashes_,
@@ -5980,4 +7681,115 @@
 unsigned int reloc_type);
 #endif
 
+//CCR: instantiate the template function
+#ifdef HAVE_TARGET_32_LITTLE
+template
+void 
+Layout::add_shuffleInfo<32, false>(ShuffleInfo::ReorderInfo& to_add_info,
+Sized_relobj_file<32, false>* object);
+#endif
+
+#ifdef HAVE_TARGET_32_BIG
+template
+void 
+Layout::add_shuffleInfo<32, true>(ShuffleInfo::ReorderInfo& to_add_info,
+Sized_relobj_file<32, true>* object);
+#endif
+
+#ifdef HAVE_TARGET_64_LITTLE
+template
+void 
+Layout::add_shuffleInfo<64, false>(ShuffleInfo::ReorderInfo& to_add_info,
+Sized_relobj_file<64, false>* object);
+#endif
+
+#ifdef HAVE_TARGET_64_BIG
+template
+void 
+Layout::add_shuffleInfo<64, true>(ShuffleInfo::ReorderInfo& to_add_info,
+Sized_relobj_file<64, true>* object);
+#endif
+
+#ifdef HAVE_TARGET_32_LITTLE
+template
+void 
+Layout::update_shuffleInfo<32, false>();
+#endif
+
+
+#ifdef HAVE_TARGET_32_BIG
+template
+void 
+Layout::update_shuffleInfo<32, true>();
+#endif
+
+#ifdef HAVE_TARGET_64_LITTLE
+template
+void 
+Layout::update_shuffleInfo<64, false>();
+#endif
+
+#ifdef HAVE_TARGET_64_BIG
+template
+void 
+Layout::update_shuffleInfo<64, true>();
+#endif
+
+// binpang, instantitate the template function 
+#ifdef HAVE_TARGET_32_LITTLE
+template
+void 
+Layout::add_shuffleInfo_obj<32, false>(ShuffleInfo::ReorderInfo &,
+Sized_relobj_file<32, false> *,
+input2output &);
+#endif
+
+#ifdef HAVE_TARGET_32_BIG
+template
+void 
+Layout::add_shuffleInfo_obj<32, true>(ShuffleInfo::ReorderInfo&,
+Sized_relobj_file<32, true>*,
+input2output &);
+#endif
+
+#ifdef HAVE_TARGET_64_LITTLE
+template
+void 
+Layout::add_shuffleInfo_obj<64, false>(ShuffleInfo::ReorderInfo&,
+Sized_relobj_file<64, false>*,
+input2output &);
+#endif
+
+#ifdef HAVE_TARGET_64_BIG
+template
+void 
+Layout::add_shuffleInfo_obj<64, true>(ShuffleInfo::ReorderInfo&,
+Sized_relobj_file<64, true>*,
+input2output &);
+#endif
+
+#ifdef HAVE_TARGET_32_LITTLE
+template
+void 
+Layout::update_shuffleInfo_layout<32, false>();
+#endif
+
+#ifdef HAVE_TARGET_32_BIG
+template
+void 
+Layout::update_shuffleInfo_layout<32, true>();
+#endif
+
+#ifdef HAVE_TARGET_64_LITTLE
+template
+void 
+Layout::update_shuffleInfo_layout<64, false>();
+#endif
+
+#ifdef HAVE_TARGET_64_BIG
+template
+void 
+Layout::update_shuffleInfo_layout<64, true>();
+#endif
+
 } // End namespace gold.
diff -ru gold_origin/layout.h gold_2.27_modified/layout.h
--- gold_origin/layout.h	2019-08-25 16:46:09.065638004 -0400
+++ gold_2.27_modified/layout.h	2019-08-25 16:41:27.431668727 -0400
@@ -26,6 +26,7 @@
 #include <cstring>
 #include <list>
 #include <map>
+#include <set>
 #include <string>
 #include <utility>
 #include <vector>
@@ -36,6 +37,9 @@
 #include "dynobj.h"
 #include "stringpool.h"
 
+//CCR
+#include "shuffleInfo.pb.h"
+
 namespace gold
 {
 
@@ -62,6 +66,12 @@
 class Target;
 struct Timespec;
 
+
+
+//void record_shuffle_fixups(ShuffleInfo::ReorderInfo_FixupInfo* fixups);
+
+// binpang, add
+typedef std::map<std::string, std::string> input2output;
 // Return TRUE if SECNAME is the name of a compressed debug section.
 extern bool
 is_compressed_debug_section(const char* secname);
@@ -504,6 +514,10 @@
 void
 set_incremental_base(Incremental_binary* base);
 
+// binpang, add. 
+// this is the map that the object input section to final binary output section
+
+
 Incremental_binary*
 incremental_base()
 { return this->incremental_base_; }
@@ -856,6 +870,7 @@
 write_sections_after_input_sections(Output_file* of);
 
 // Return an output section named NAME, or NULL if there is none.
+// CCR: could be useful to locate base address of the output section
 Output_section*
 find_output_section(const char* name) const;
 
@@ -975,6 +990,7 @@
 }
 
 // Return section list.
+// CCR: could be useful to locate output section
 const Section_list&
 section_list() const
 { return this->section_list_; }
@@ -994,6 +1010,208 @@
 void
 reset_relax_output();
 
+//CCR: handle special sections differently during shuffleInfo collection
+
+bool
+is_special_section_by_name(const char* secname)
+{
+static const char* const special_text_section[] =
+{
+".text.unlikely",
+".text.exit",
+".text.startup",
+".text.hot"
+};
+
+for (size_t i = 0; i < sizeof(special_text_section) / sizeof(special_text_section[0]); i++)
+if (is_prefix_of(special_text_section[i], secname))
+return true;
+return false;
+}
+
+//CCR: use this API to parse and print the given shuffleInfo
+void
+read_shuffleInfo(ShuffleInfo::ReorderInfo& reorder_info);
+
+//CCR: use this API to collect the given reorderInfo into our global_reorderInfo
+// containing_object is the object that provides the processing reorderInfo
+template<int size, bool big_endian>
+void
+add_shuffleInfo(ShuffleInfo::ReorderInfo& reorder_info,
+Sized_relobj_file<size, big_endian> *containing_object);
+
+// binpang, add. add output section name and basic block offset in final protobuf.
+template<int size, bool big_endian>
+void update_shuffleInfo_layout();
+
+template<int size, bool big_endian>
+void add_shuffleInfo_obj(ShuffleInfo::ReorderInfo& to_add_info,
+Sized_relobj_file<size, big_endian> *pfrom_object, 
+input2output &input2output_list);      
+
+// binpang, add
+// get obj2input
+std::map<std::string, input2output> get_obj2input(){
+return obj2input;
+}
+
+template<int size, bool big_endian>
+void insert_obj2input(Sized_relobj_file<size, big_endian>* obj, 
+std::string& input_sec_name, std::string& output_sec_name){
+typename std::map<std::string, input2output>::iterator tmp_iter;
+tmp_iter = obj2input.find(obj->name());
+if (tmp_iter == obj2input.end()){
+input2output tmp_vec;
+tmp_vec.insert(std::pair<std::string, std::string>(input_sec_name, output_sec_name));
+obj2input.insert(std::pair<std::string, input2output>(obj->name(), tmp_vec));
+}else{
+std::pair<std::map<std::string, std::string>::iterator, bool> ret;
+ret = tmp_iter->second.insert(std::pair<std::string, std::string>(input_sec_name, output_sec_name));
+if (ret.second == false){
+gold_warning(_("[bbinfo]: bug, has duplicate input section on %s in obj %s"), 
+input_sec_name.c_str(), obj->name().c_str());
+}
+}
+}
+
+//CCR [Koo]: use this API for final update of all shuffleInfo
+template<int size, bool big_endian>
+void
+update_shuffleInfo();
+
+//CCR: use this API to get the global_reorderInfo
+// NOTE: maybe this can be moved to private category
+ShuffleInfo::ReorderInfo&
+get_global_shuffleInfo()
+{return this->ccr_shuffle_info_.global_reorder_info;}
+
+//CCR: use this API to get the pserialized_info
+// NOTE: maybe this can be moved to private category
+std::string * 
+get_serialized_shuffle_info()
+{return this->ccr_shuffle_info_.pserialized_info;}
+
+unsigned char * 
+get_serialized_shuffle_info_for_view()
+{
+if(this->ccr_shuffle_info_.pserialized_info)
+this->serialize_shuffle_info();
+
+if(!this->ccr_shuffle_info_.pmy_rand_section && this->ccr_shuffle_info_.pserialized_info){
+this->ccr_shuffle_info_.pmy_rand_section =
+reinterpret_cast<unsigned char *>(
+const_cast<char *>(
+this->ccr_shuffle_info_.pserialized_info->c_str())
+);
+}
+return  this->ccr_shuffle_info_.pmy_rand_section;
+}
+
+void
+set_serialized_shuffle_info(std::string *p)
+{this->ccr_shuffle_info_.pserialized_info = p;}
+
+//CCR: check if our combined shuffleInfo has been written to output
+bool
+shuffleInfo_has_been_written_to_output()
+{return ccr_shuffle_info_.has_been_written_to_output;}
+
+//CCR: mark we have written out the combined .rand section 
+void
+saw_shuffleInfo_written_to_output()
+{ccr_shuffle_info_.has_been_written_to_output = true;}
+
+//CCR: check if we have adjusted the layout of the .rand section 
+bool
+shuffleInfo_has_adjusted_offset()
+{return ccr_shuffle_info_.has_adjusted_offsets;}
+
+//CCR: mark we we have adjusted the layout of the .rand section
+void
+saw_shuffleInfo_adjusted_offset()
+{ccr_shuffle_info_.has_adjusted_offsets = true;}
+//CCR: serialize reorderInfo into string
+std::string *
+serialize_shuffle_info();
+
+//CCR: record output .text section start address
+void
+set_os_text_address(unsigned long long addr)
+{ccr_shuffle_info_.text_section_start_addr = addr;}
+//CCR: retrive output .text section start address
+unsigned long long 
+get_os_text_address()
+{return ccr_shuffle_info_.text_section_start_addr;}
+
+
+//assume it is atomically called, will change the counter to atomic variable if later things go wrong 
+uint64_t
+get_and_increase_yarp_obj_id()
+{return ccr_shuffle_info_.yarp_obj_counter++;}
+void
+reset_yarp_obj_id()
+{ccr_shuffle_info_.yarp_obj_counter = 0;}
+
+void
+set_yarp_obj_text_padding_map(uint64_t id, uint64_t prev_padding_size)
+{ccr_shuffle_info_.yarp_obj_text_padding_map[id] = prev_padding_size;}
+void reset_yarp_obj_text_padding_map()
+{ccr_shuffle_info_.yarp_obj_text_padding_map.clear(); }
+
+// FIXME: any better implementation for this instead of finding the right padding on demand?
+uint64_t
+get_yarp_obj_text_padding_map(int64_t id)
+{
+int32_t padding_size = 0;
+uint64_t next_id = id;
+if(id < 0 || is_zero_object(id))
+return 0;
+else{
+do{
+next_id += 1; 
+padding_size += ccr_shuffle_info_.yarp_obj_text_padding_map[next_id];
+}while(is_zero_object(next_id));
+
+}
+return padding_size;
+}
+
+void 
+yarp_set_main_addr_off(int off)
+{ccr_shuffle_info_.global_reorder_info.mutable_bin()->set_main_addr_offset(off);}
+
+//CCR:
+elfcpp::Elf_types<64>::Elf_Addr
+yarp_find_os_base_offset_by_name(char *section_name);
+
+//CCR:
+elfcpp::Elf_types<64>::Elf_Addr
+yarp_find_os_base_addr_by_name(const char *section_name);
+
+//CCR: use this API to update the type of those Fixups done by linker
+void yarp_update_fixups(int fixup_offset, const Output_section *os,
+const Output_section *text , int64_t resolved_value);
+
+
+
+void record_zero_object(uint64_t object_id)
+{ccr_shuffle_info_.zero_obj_ids.insert(object_id); }
+
+void reset_zero_object_set()
+{ccr_shuffle_info_.zero_obj_ids.clear(); }
+
+bool is_zero_object(uint64_t object_id)
+{return ccr_shuffle_info_.zero_obj_ids.find(object_id) != ccr_shuffle_info_.zero_obj_ids.end();}
+
+//CCR: use these getter/setter to record the first non-special text section offset 
+void set_yarp_adjusted_start_off(uint64_t n_off)
+{ccr_shuffle_info_.yarp_adjusted_start_off = n_off;}
+uint64_t get_yarp_adjusted_start_off()
+{return ccr_shuffle_info_.yarp_adjusted_start_off;}
+
+//CCR: this could be removed, as we are directly reading from .rand section now
+bool visited_shuffle_bin(std::string name);
+
 private:
 Layout(const Layout&);
 Layout& operator=(const Layout&);
@@ -1242,6 +1460,18 @@
 Output_segment*, Output_segment_headers*,
 Output_file_header*, unsigned int*);
 
+//CCR: check if this is the first reorderInfo we have seen
+bool
+is_first_reorder_info()
+{return ccr_shuffle_info_.first_reorder_info;}
+
+//CCR: mark we have seen the first reorderInfo 
+void
+saw_first_reorder_info()
+{ccr_shuffle_info_.first_reorder_info = false;}
+
+
+
 // A mapping used for kept comdats/.gnu.linkonce group signatures.
 typedef Unordered_map<std::string, Kept_section> Signatures;
 
@@ -1444,6 +1674,59 @@
 Incremental_binary* incremental_base_;
 // For incremental links, a list of free space within the file.
 Free_list free_list_;
+
+enum CCR_BBL_TYPE
+{
+NORMAL_BBL,
+FUNC_BBL,
+OBJ_BBL,
+OBJ_FUNC_BBL // binpang, add. Represents that it's both the end of function and object
+// sometimes, a function may cross different sections. such as .text and .text.unlikely sections.
+};
+
+enum CCR_FIXUP_TYPE
+{
+C2C_FIXUP,
+C2D_FIXUP,
+D2C_FIXUP,
+D2D_FIXUP,
+NEW_SECTION_START_FIXUP,
+SPECIAL_FIXUP
+};
+
+//CCR: the global ReorderInfo used to combine all reorderInfos from the linking objects
+struct CCR_Shuffle_Info{
+CCR_Shuffle_Info() : first_reorder_info(true),
+has_been_written_to_output(false),
+has_adjusted_offsets(false), 
+pserialized_info(NULL),
+pmy_rand_section(NULL),
+text_section_start_addr(0),
+yarp_adjusted_start_off(0),
+yarp_obj_counter(0){}
+ShuffleInfo::ReorderInfo global_reorder_info; 
+bool first_reorder_info;
+bool has_been_written_to_output;
+bool has_adjusted_offsets;
+std::string *pserialized_info;
+unsigned char *pmy_rand_section;
+unsigned long long text_section_start_addr;
+// offset of the first non-special text section
+uint64_t yarp_adjusted_start_off;
+
+uint64_t yarp_obj_counter;
+// MAP(obj_id, prev_objtext_padding_size)
+std::map<uint64_t, uint64_t> yarp_obj_text_padding_map;
+
+//CCR: this could be removed, as we are directly reading from .rand section now
+std::set<std::string> added_set;//so when an obj got revisited by linker we won't add duplicated shuffle.bin
+std::set<uint64_t> zero_obj_ids;
+
+} ccr_shuffle_info_;
+
+// binpang, add 
+// store global maps that input object's input section => output section
+std::map<std::string, input2output> obj2input;
 };
 
 // This task handles writing out data in output sections which is not
Only in gold_2.27_modified: libshuffleInfo.so
diff -ru gold_origin/main.cc gold_2.27_modified/main.cc
--- gold_origin/main.cc	2019-08-25 16:45:34.525399330 -0400
+++ gold_2.27_modified/main.cc	2019-08-25 16:39:51.542983099 -0400
@@ -50,6 +50,13 @@
 #include "gdb-index.h"
 #include "timer.h"
 
+#define CCR_NEW_RAND_SECTION
+
+#ifdef CCR_NEW_RAND_SECTION
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#endif 
 using namespace gold;
 
 // This function emits the commandline to a hard-coded file in temp.
@@ -197,8 +204,10 @@
 // permit symbols to be forced local with -r, though, as it would
 // permit some linker optimizations.  Perhaps we need yet another
 // option to control this.  FIXME.
-if (parameters->options().relocatable())
+if (parameters->options().relocatable()){
 command_line.script_options().version_script_info()->clear();
+gold_info("[CCR-error]incremental linking with -r is not supported");
+}
 
 // The work queue.
 Workqueue workqueue(command_line.options());
@@ -210,12 +219,12 @@
 Garbage_collection gc;
 
 // The Identical Code Folding (ICF, --icf) Object.
-Icf icf;
-
+Icf icf;  
 // The symbol table.  We're going to guess here how many symbols
 // we're going to see based on the number of input files.  Even when
 // this is off, it means at worst we don't quite optimize hashtable
 // resizing as well as we could have (perhaps using more memory).
+//CCR: num_objs
 Symbol_table symtab(command_line.number_of_input_files() * 1024,
 command_line.version_script());
 
@@ -251,6 +260,10 @@
 // Run the main task processing loop.
 workqueue.process(0);
 
+// gold_info("process done!");
+// exit(-1); 
+
+
 if (command_line.options().print_output_format())
 print_output_format();
 
@@ -323,6 +336,53 @@
 && errors.error_count() == 0)
 gold_error("treating warnings as errors");
 
+#ifdef CCR_NEW_RAND_SECTION
+//use objcopy to integrate the newly generated .shuffle.bin in to the final elf
+std::string target(command_line.options().output_file_name());
+std::string shuffle_bin(target+std::string(".shuffle.bin"));
+
+std::string shuffle_bin_gz(shuffle_bin+std::string(".gz"));
+// #define CCR_MSG_DETAILS
+
+//compress shufflebin first
+char * const compress_bin[] = {"gzip", const_cast<char *>(shuffle_bin.c_str()),(char *)NULL};
+if(fork()){
+int status;
+wait(&status);
+}else{
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR]Compressing %s to %s", shuffle_bin.c_str(), shuffle_bin_gz.c_str());
+#endif
+execvp(compress_bin[0], compress_bin);
+_exit(0);
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("target: %s, shufflebin: %s", target.c_str(), shuffle_bin.c_str());
+#endif
+std::string rand(".rand=");
+std::string opt_2 = rand+shuffle_bin_gz;
+char * const add_section[] = {"objcopy", "--add-section", (char *)opt_2.c_str(), (char *)target.c_str(), (char*)NULL};
+if(fork()){
+int status;
+wait(&status);
+}else{
+//child exec the objcopy to integrate shufflebin into target
+execvp("objcopy", add_section);
+_exit(0);
+}
+
+//remove the compressed bin after objcopy
+char * const rm_bin[] = {"rm", const_cast<char*>(shuffle_bin_gz.c_str()), (char*)NULL};
+if(fork()){
+int status;
+wait(&status);
+}else {
+execvp("rm", rm_bin);
+_exit(0);
+}
+#endif//CCR_NEW_RAND_SECTION
+
 // If the user used --noinhibit-exec, we force the exit status to be
 // successful.  This is compatible with GNU ld.
 gold_exit((errors.error_count() == 0
diff -ru gold_origin/Makefile.in gold_2.27_modified/Makefile.in
--- gold_origin/Makefile.in	2019-08-25 16:45:36.213411009 -0400
+++ gold_2.27_modified/Makefile.in	2019-08-25 16:39:53.398996462 -0400
@@ -349,7 +349,7 @@
 CXX = @CXX@
 CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
+CXXFLAGS = @CXXFLAGS@ -std=c++11
 CYGPATH_W = @CYGPATH_W@
 DATADIRNAME = @DATADIRNAME@
 DEFAULT_TARGET = @DEFAULT_TARGET@
@@ -365,6 +365,7 @@
 GMSGFMT = @GMSGFMT@
 GOLD_LDADD = @GOLD_LDADD@
 GOLD_LDFLAGS = @GOLD_LDFLAGS@
+YARP_LDFLAGS = -I/usr/local/include -L/usr/local/lib -L./ 
 GREP = @GREP@
 INCINTL = @INCINTL@
 INSTALL = @INSTALL@
@@ -373,12 +374,13 @@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 INSTOBJEXT = @INSTOBJEXT@
-LDFLAGS = @LDFLAGS@
+LDFLAGS = @LDFLAGS@ $(YARP_LDFLAGS)
 LFS_CFLAGS = @LFS_CFLAGS@
 LIBINTL = @LIBINTL@
 LIBINTL_DEP = @LIBINTL_DEP@
 LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
+YARP_PROTOBUF = -lprotobuf -lshuffleInfo
+LIBS = @LIBS@ $(YARP_PROTOBUF)
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
 MAINT = @MAINT@
@@ -408,7 +410,7 @@
 TARGETOBJS = @TARGETOBJS@
 USE_NLS = @USE_NLS@
 VERSION = @VERSION@
-WARN_CFLAGS = @WARN_CFLAGS@
+WARN_CFLAGS = @WARN_CFLAGS@ -Wno-write-strings 
 WARN_CXXFLAGS = @WARN_CXXFLAGS@
 WARN_WRITE_STRINGS = @WARN_WRITE_STRINGS@
 XGETTEXT = @XGETTEXT@
@@ -621,9 +623,9 @@
 sources_var = main.cc
 deps_var = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(LIBINTL_DEP)
 ldadd_var = $(TARGETOBJS) libgold.a $(LIBIBERTY) $(GOLD_LDADD) $(LIBINTL) \
-$(THREADSLIB) $(LIBDL) $(ZLIB)
+$(THREADSLIB) $(LIBDL) $(ZLIB) 
 
-ldflags_var = $(GOLD_LDFLAGS)
+ldflags_var = $(GOLD_LDFLAGS) 
 ld_new_SOURCES = $(sources_var)
 ld_new_DEPENDENCIES = $(deps_var)
 ld_new_LDADD = $(ldadd_var)
diff -ru gold_origin/object.cc gold_2.27_modified/object.cc
--- gold_origin/object.cc	2019-08-25 16:46:07.781629143 -0400
+++ gold_2.27_modified/object.cc	2019-08-25 16:41:26.155659662 -0400
@@ -43,6 +43,9 @@
 #include "incremental.h"
 #include "merge.h"
 
+
+// //CCR
+// #include "shuffleInfo.pb.h"
 namespace gold
 {
 
@@ -1261,11 +1264,14 @@
 reloc_shndx, reloc_type, &offset);
 
 this->output_sections()[shndx] = os;
+
 if (offset == -1)
 this->section_offsets()[shndx] = invalid_address;
 else
 this->section_offsets()[shndx] = convert_types<Address, off_t>(offset);
 
+// gold_info("[CCR]%s laying out section %s, addr 0x%lx",
+// this->name().c_str(),name,this->section_offsets()[shndx]);
 // If this section requires special handling, and if there are
 // relocs that apply to it, then we must do the special handling
 // before we apply the relocs.
@@ -1374,7 +1380,7 @@
 if (parameters->options().gc_sections())
 gold_assert(symtab->gc()->is_worklist_ready());
 if (parameters->options().icf_enabled())
-gold_assert(symtab->icf()->is_icf_ready()); 
+gold_assert(symtab->icf()->is_icf_ready());
 is_pass_two = true;
 }
 }
@@ -1547,6 +1553,7 @@
 omit[i] = true;
 }
 
+
 // The .note.GNU-stack section is special.  It gives the
 // protection flags that this object file requires for the stack
 // in memory.
@@ -1767,6 +1774,7 @@
 {
 // When garbage collection is switched on the actual layout
 // only happens in the second call.
+// CCR: MARK
 this->layout_section(layout, i, name, shdr, reloc_shndx[i],
 reloc_type[i]);
 
@@ -1862,6 +1870,7 @@
 
 Output_section* os = layout->layout_reloc(this, i, shdr, data_section,
 rr);
+
 out_sections[i] = os;
 out_section_offsets[i] = invalid_address;
 }
diff -ru gold_origin/object.h gold_2.27_modified/object.h
--- gold_origin/object.h	2019-08-25 16:45:34.309397834 -0400
+++ gold_2.27_modified/object.h	2019-08-25 16:39:51.350981717 -0400
@@ -25,13 +25,19 @@
 
 #include <string>
 #include <vector>
+#include <set>
+#include <tuple>
+#include <list>
 
+#include <assert.h>
 #include "elfcpp.h"
 #include "elfcpp_file.h"
 #include "fileread.h"
 #include "target.h"
 #include "archive.h"
 
+//#define CCR_MSG_DETAILS
+
 namespace gold
 {
 
@@ -549,6 +555,7 @@
 
 // Return a view of the contents of a section.  Set *PLEN to the
 // size.  CACHE is a hint as in File_read::get_view.
+// CCR: used
 const unsigned char*
 section_contents(unsigned int shndx, section_size_type* plen, bool cache);
 
@@ -576,11 +583,13 @@
 }
 
 // Return the size of a section given a section index.
+// CCR: used
 uint64_t
 section_size(unsigned int shndx)
 { return this->do_section_size(shndx); }
 
 // Return the name of a section given a section index.
+// CCR: used
 std::string
 section_name(unsigned int shndx) const
 { return this->do_section_name(shndx); }
@@ -616,6 +625,7 @@
 { return this->do_section_info(shndx); }
 
 // Return the required section alignment given a section index.
+// CCR: used
 uint64_t
 section_addralign(unsigned int shndx)
 { return this->do_section_addralign(shndx); }
@@ -635,6 +645,7 @@
 // Given a section index, return the offset in the Output_section.
 // The return value will be -1U if the section is specially mapped,
 // such as a merge section.
+// CCR: used
 uint64_t
 output_section_offset(unsigned int shndx) const
 { return this->do_output_section_offset(shndx); }
@@ -720,6 +731,7 @@
 { return View(this->get_view(loc.file_offset, loc.data_size, true, true)); }
 
 // Get a view into the underlying file.
+// CCR: used
 const unsigned char*
 get_view(off_t start, section_size_type size, bool aligned, bool cache)
 {
@@ -1298,6 +1310,7 @@
 }
 
 // Set the offset of an input section within its output section.
+// CCR: we can get the offset by hooking this API
 void
 set_section_offset(unsigned int shndx, uint64_t off)
 { this->do_set_section_offset(shndx, off); }
@@ -1375,12 +1388,94 @@
 is_big_endian() const
 { return this->do_is_big_endian(); }
 
-protected:
+// CCR: moved from protected area
 // The output section to be used for each input section, indexed by
 // the input section number.  The output section is NULL if the
+
 // input section is to be discarded.
 typedef std::vector<Output_section*> Output_sections;
 
+// Return the vector mapping input sections to output sections.
+Output_sections&
+output_sections()
+{ return this->output_sections_; }
+
+const Output_sections&
+output_sections() const
+{ return this->output_sections_; }
+
+//CCR: this is the getter and setter for yarp_obj_identifies
+//     we can use this together with Layout::text_padding_map
+//            to retrive the text padding for current section
+//
+//     we use objid to denote specific input .text section now, not assuming only one .text per obj
+void reset_yarp_object_id_map()
+{yarp_obj_id_map.clear();}
+void
+set_yarp_object_id_map(uint64_t obj_id, const char *text_name)
+{
+std::string sec_name(text_name);
+yarp_obj_id_map.push_back(make_tuple(obj_id, sec_name, false));
+}
+
+uint64_t // return nth id for the section among multiple input .text sections
+yarp_object_id(uint64_t id, std::string text_name)
+{
+uint64_t obj_id;
+std::string sec_name;
+bool visited;
+for (std::list<std::tuple<uint64_t, std::string, bool>>::iterator it = this->yarp_obj_id_map.begin(); 
+it!=this->yarp_obj_id_map.end(); ++it) {
+std::tie(obj_id, sec_name, visited) = *it;
+// gold_info("checking %s", sec_name.c_str());
+if (sec_name.compare(text_name) == 0 && id == obj_id)
+return obj_id;
+}
+
+// text_name should be able to be found at all times, something went wrong otherwise
+gold_info("[CCR-ERROR] Was not able to find the offset@%s [%lu]", text_name.c_str(), id);
+gold_unreachable();
+}
+
+// Hack: if we do not know obj_id, then use the 'visited' flag
+uint64_t 
+yarp_object_id(std::string text_name)
+{
+uint64_t obj_id;
+std::string sec_name;
+bool visited;
+for (std::list<std::tuple<uint64_t, std::string, bool>>::iterator it = this->yarp_obj_id_map.begin(); 
+it!=this->yarp_obj_id_map.end(); ++it) {
+std::tie(obj_id, sec_name, visited) = *it;
+//gold_info("checking %s", sec_name.c_str());
+if (sec_name.compare(text_name) == 0) {
+std::get<2>(*it) = true;
+return obj_id;
+}
+}
+
+// text_name should be able to be found at all times, something went wrong otherwise
+gold_info("[CCR-ERROR] Was not able to find the offset@%s for %s", text_name.c_str(), this->name().c_str());
+assert(0);
+gold_unreachable();
+}
+
+//Hack, better way to let Layout class method enumerate the obj_id_map here?
+//std::map<std::string, uint64_t>
+std::list<std::tuple<uint64_t, std::string, bool>>
+get_yarp_obj_id_map()
+{return this->yarp_obj_id_map;}
+
+//CCR: we use these two functions to express if this object is randomizable
+//      they are getter and setter respectively
+bool
+is_yarp_defined_object()
+{return this->is_yarp_defined_;}
+void
+set_yarp_defined_object()
+{this->is_yarp_defined_ = true;}
+protected:
+
 // Read the relocs--implemented by child class.
 virtual void
 do_read_relocs(Read_relocs_data*) = 0;
@@ -1476,14 +1571,6 @@
 return this->output_sections_[shndx];
 }
 
-// Return the vector mapping input sections to output sections.
-Output_sections&
-output_sections()
-{ return this->output_sections_; }
-
-const Output_sections&
-output_sections() const
-{ return this->output_sections_; }
 
 // Set the size of the relocatable relocs array.
 void
@@ -1576,6 +1663,13 @@
 unsigned int first_dyn_reloc_;
 // Count of dynamic relocations for this object.
 unsigned int dyn_reloc_count_;
+//CCR: here we reuse the term "objid" to refer to each input .text section in the same obj
+//    - Due to possibly redundant section names, a list of tuples looks better data structure
+//      Tuples are <obj_id, section_name, has_visited>
+//    - The 'has_visited' flag allows for finding obj_id even with identical section_name
+std::list<std::tuple<uint64_t, std::string, bool>> yarp_obj_id_map;
+//CCR: this object contains section .rand, and is able to be randomized
+bool is_yarp_defined_ = false;
 };
 
 // This class is used to handle relocations against a section symbol
@@ -2028,6 +2122,7 @@
 // This is -1 if the input section requires a special mapping, such
 // as a merge section.  The output section can be found in the
 // output_sections_ field of the parent class Relobj.
+// CCR: used
 Address
 get_output_section_offset(unsigned int shndx) const
 {
@@ -2040,6 +2135,11 @@
 void
 do_for_all_local_got_entries(Got_offset_list::Visitor* v) const;
 
+
+// Return the vector of section offsets.
+std::vector<Address>&
+section_offsets()
+{ return this->section_offsets_; }
 protected:
 typedef Relobj::Output_sections Output_sections;
 
@@ -2048,10 +2148,6 @@
 clear_got_offsets()
 { this->local_got_offsets_.clear(); }
 
-// Return the vector of section offsets.
-std::vector<Address>&
-section_offsets()
-{ return this->section_offsets_; }
 
 // Get the address of an output section.
 uint64_t
@@ -2150,6 +2246,7 @@
 // output section.  This is INVALID_ADDRESS if the input section requires a
 // special mapping.
 std::vector<Address> section_offsets_;
+
 };
 
 // A regular object file.  This is size and endian specific.
@@ -2326,6 +2423,221 @@
 bool is_deferred_layout() const
 { return this->is_deferred_layout_; }
 
+
+// [CCR] METADATA (shuffle.bin) accessors
+//text section meta info accessors
+void
+record_text_shndx(const char *secname, unsigned int ndx)
+{
+std::string str(secname);
+#ifdef CCR_MSG_DETAILS
+gold_info("%s recording section name: %s, ndx: %d", this->name().c_str(), secname, ndx);
+#endif
+if(this->text_shndx_map.find(str) != this->text_shndx_map.end()){
+this->text_shndx_map[str]->push_back(ndx);
+}
+else{
+ndxvec_ty *vec = new std::vector<unsigned int>;
+vec->push_back(ndx);
+this->text_shndx_map[str] = vec;
+}
+
+this->yarp_textos_seed = ndx;
+}
+
+int//this seed can allow us to find the output .text section in relocation stage
+get_textos_seed(){
+assert(this->yarp_textos_seed > 0 && "text os seed is not set");
+return this->yarp_textos_seed;
+}
+
+bool
+is_textos_seed_valid(){
+return this->yarp_textos_seed != -1;
+}
+
+unsigned int //input .text section number
+yarp_get_text_num()
+{
+int count = 0;
+for(auto iter = text_shndx_map.begin(); iter != text_shndx_map.end(); ++iter ){
+count+= iter->second->size();
+}
+return count;
+}
+int //input section index, order used when there are duplicated sec names 
+get_text_shndx(std::string secname, int order=0)
+{
+if(this->text_shndx_map.find(secname) != this->text_shndx_map.end())
+return this->text_shndx_map[secname]->at(order);
+else
+gold_info("[CCR-warning] couldn't find %s", secname.c_str());
+return -1;
+}
+
+//rodata section meta info accessors
+void
+record_rodata_shndx(const char *secname, unsigned int ndx)
+{
+if(!secname)
+exit(1);
+std::string str(secname);
+#ifdef CCR_MSG_DETAILS
+gold_info("%s recording section name: %s, ndx: %d", this->name().c_str(), str.c_str(), ndx);
+#endif
+if(this->rodata_shndx_map.find(str) != this->rodata_shndx_map.end()){
+gold_info("duplicate rodata section %s[%s] %d", this->name().c_str(), str.c_str(), ndx);
+this->rodata_shndx_map[str]->push_back(ndx);
+}
+else{
+ndxvec_ty *vec = new std::vector<unsigned int>;
+vec->push_back(ndx);
+this->rodata_shndx_map[str] = vec;
+}
+}
+unsigned int //input .rodata section number
+yarp_get_rodata_num()
+{
+int count = 0;
+for(auto iter = rodata_shndx_map.begin(); iter != rodata_shndx_map.end(); ++iter ){
+count+= iter->second->size();
+}
+return count;
+}
+int //input section index of the nth rodata section
+get_rodata_shndx(std::string secname, int order = 0)
+{
+if(this->rodata_shndx_map.find(secname) != this->rodata_shndx_map.end())
+return this->rodata_shndx_map[secname]->at(order);
+else
+return -1;
+}
+
+//data section meta info accessors
+void
+record_data_shndx(const char *secname, unsigned int ndx)
+{
+if(!secname)
+exit(1);
+std::string str(secname);
+if(this->data_shndx_map.find(str) != this->data_shndx_map.end()){
+this->data_shndx_map[str]->push_back(ndx);
+}
+else{
+ndxvec_ty *vec = new std::vector<unsigned int>;
+vec->push_back(ndx);
+this->data_shndx_map[str] = vec;
+}
+}
+unsigned int //input .data section number
+yarp_get_data_num()
+{
+int count = 0;
+for(auto iter = data_shndx_map.begin(); iter != data_shndx_map.end(); ++iter ){
+count+= iter->second->size();
+}
+return count;
+}
+int //input section index of the nth data section
+get_data_shndx(std::string secname, int order = 0)
+{
+if(this->data_shndx_map.find(secname) != this->data_shndx_map.end())
+return this->data_shndx_map[secname]->at(order);
+else
+return -1;
+}
+
+// data.rel.ro section meta info accessors
+void
+record_datarel_shndx(const char *secname, unsigned int ndx)
+{
+std::string str(secname);
+this->datarel_shndx_map[str] = ndx;
+}
+unsigned int //input .data.rel.ro section number
+yarp_get_datarel_num()
+{return this->datarel_shndx_map.size();}
+int //input section index of the nth data section
+get_datarel_shndx(std::string secname)
+{
+if(this->datarel_shndx_map.find(secname) != this->datarel_shndx_map.end())
+return this->datarel_shndx_map[secname];
+else
+return -1;
+}
+
+// .init_array section meta info accessors
+void
+record_initarray_shndx(const char *secname, unsigned int ndx)
+{
+if(!secname)
+exit(1);
+std::string str(secname);
+if(this->initarray_shndx_map.find(str) != this->initarray_shndx_map.end()){
+this->initarray_shndx_map[str]->push_back(ndx);
+}
+else{
+ndxvec_ty *vec = new std::vector<unsigned int>;
+vec->push_back(ndx);
+this->initarray_shndx_map[str] = vec;
+}
+}
+unsigned int //input .init_array section number
+yarp_get_initarray_num()
+{
+int count = 0;
+for(auto iter = initarray_shndx_map.begin(); iter != initarray_shndx_map.end(); ++iter ){
+count+= iter->second->size();
+}
+return count;
+}
+int //input section index of the nth data section
+get_initarray_shndx(std::string secname, int order=0)
+{
+if(this->initarray_shndx_map.find(secname) != this->initarray_shndx_map.end())
+return this->initarray_shndx_map[secname]->at(order);
+else
+return -1;
+}
+
+// .rand section meta info accessors (a special section to contain shuffle information)
+void
+record_rand_shndx(const char *secname, unsigned int ndx)
+{
+std::string str(secname);
+this->rand_shndx_map[str] = ndx;
+}
+int
+get_rand_shndx(std::string secname)
+{
+if(this->rand_shndx_map.find(secname) != this->rand_shndx_map.end())
+return this->rand_shndx_map[secname];
+else
+return -1;
+}
+
+bool yarp_text_section_exist(std::string secname){
+return this->text_shndx_map.find(secname) != this->text_shndx_map.end();
+}
+
+bool yarp_rodata_section_exist(std::string secname){
+return this->rodata_shndx_map.find(secname) != this->rodata_shndx_map.end();
+}
+
+bool yarp_data_section_exist(std::string secname){
+return this->data_shndx_map.find(secname) != this->data_shndx_map.end(); 
+}
+
+bool yarp_datarel_section_exist(std::string secname){
+return this->datarel_shndx_map.find(secname) != this->datarel_shndx_map.end(); 
+}
+
+bool yarp_initarray_section_exist(std::string secname){
+return this->initarray_shndx_map.find(secname) != this->initarray_shndx_map.end(); 
+}
+
+
+
 protected:
 typedef typename Sized_relobj<size, big_endian>::Output_sections
 Output_sections;
@@ -2847,6 +3159,13 @@
 std::vector<Deferred_layout> deferred_layout_relocs_;
 // Pointer to the list of output views; valid only during do_relocate().
 const Views* output_views_;
+typedef unsigned int shndx_ty;
+typedef std::vector<shndx_ty> ndxvec_ty;
+std::map<std::string, ndxvec_ty*> initarray_shndx_map, text_shndx_map,
+rodata_shndx_map, data_shndx_map;//TODO:generalize to other sections
+std::map<std::string, shndx_ty>  datarel_shndx_map,  rand_shndx_map;
+// ehframe_shndx_map, exceptbl_shndx_map;
+int yarp_textos_seed = -1;
 };
 
 // A class to manage the list of all objects.
diff -ru gold_origin/output.cc gold_2.27_modified/output.cc
--- gold_origin/output.cc	2019-08-25 16:46:06.829622572 -0400
+++ gold_2.27_modified/output.cc	2019-08-25 16:41:25.319653724 -0400
@@ -46,6 +46,10 @@
 #include "layout.h"
 #include "output.h"
 
+//CCR
+#include "shuffleInfo.pb.h"
+#define CCR_MSG_DETAILS
+
 // For systems without mmap support.
 #ifndef HAVE_MMAP
 # define mmap gold_mmap
@@ -601,6 +605,7 @@
 if (!ssym->is_defined() && should_issue_warning)
 gold_warning("entry symbol '%s' exists but is not defined", entry);
 v = ssym->value();
+
 }
 else
 {
@@ -616,6 +621,9 @@
 }
 }
 
+
+
+
 return v;
 }
 
@@ -1287,7 +1295,6 @@
 }
 
 // class Output_data_group.
-
 template<int size, bool big_endian>
 Output_data_group<size, big_endian>::Output_data_group(
 Sized_relobj_file<size, big_endian>* relobj,
@@ -2203,7 +2210,8 @@
 else if (this->is_relaxed_input_section())
 return this->u2_.poris->relobj();
 else
-gold_unreachable();
+return NULL;
+//gold_unreachable();
 }
 
 // Return the input section index for an input section.
@@ -2435,7 +2443,12 @@
 unsigned int reloc_shndx,
 bool have_sections_script)
 {
-elfcpp::Elf_Xword addralign = shdr.get_sh_addralign();
+if (this->yarp_get_layout() == NULL){
+this->yarp_record_layout(layout);
+}
+
+
+elfcpp::Elf_Xword addralign = shdr.get_sh_addralign();   //input section header alignment
 if ((addralign & (addralign - 1)) != 0)
 {
 object->error(_("invalid alignment %lu for section \"%s\""),
@@ -2449,6 +2462,7 @@
 typename elfcpp::Elf_types<size>::Elf_WXword sh_flags = shdr.get_sh_flags();
 uint64_t entsize = shdr.get_sh_entsize();
 
+
 // .debug_str is a mergeable string section, but is not always so
 // marked by compilers.  Mark manually here so we can optimize.
 if (strcmp(secname, ".debug_str") == 0)
@@ -2492,7 +2506,7 @@
 
 off_t offset_in_section;
 
-if (this->has_fixed_layout())
+if(this->has_fixed_layout())
 {
 // For incremental updates, find a chunk of unused space in the section.
 offset_in_section = this->free_list_.allocate(input_section_size,
@@ -2507,6 +2521,51 @@
 offset_in_section = this->current_data_size_for_child();
 off_t aligned_offset_in_section = align_address(offset_in_section,
 addralign);
+
+// binpang, add
+// add object's input section => output section
+std::string tmp_sec_name = std::string(secname);
+std::string tmp_output_sec_name = std::string(this->name());
+if (tmp_sec_name !=  "" && tmp_output_sec_name != ""){
+layout->insert_obj2input(object, tmp_sec_name, tmp_output_sec_name);
+}
+
+
+//CCR: we should record the per obj PREVIOUS .text section alignment/padding here
+if(is_prefix_of(".text", secname))
+{
+uint64_t obj_id = layout->get_and_increase_yarp_obj_id();
+std::string obj_name = object->name();
+std::string sec_name(secname);
+
+// The following keeps track of section sizes for special sections
+//   due to redundant section names (looks a corner case; i.e., dealII binary in SEPC2006)
+if (layout->is_special_section_by_name(secname)) {
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR-CHECK] %s@%s: %dB (previous padding: %dB)", secname, obj_name.c_str(),
+input_section_size, aligned_offset_in_section - offset_in_section);
+#endif
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("[lala]setting object_id_map[%s->%d] for %s", secname, obj_id, object->name().c_str());
+#endif
+object->set_yarp_object_id_map(obj_id, secname);
+layout->set_yarp_obj_text_padding_map(obj_id, aligned_offset_in_section-offset_in_section);
+//layout->set_yarp_obj_section_offset(obj_name + sec_name, aligned_offset_in_section);
+
+if(input_section_size == 0){
+layout->record_zero_object(obj_id);
+// gold_info("\t%s[%lld] is zero_object/isecn", object->name().c_str(), obj_id);
+}
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] [%3d] %s@%s [0x%x:0x%x](=0x%xB) (HeadingAlign: 0x%x) add_input_section()@output.cc", 
+obj_id, secname, obj_name.substr(obj_name.find_last_of("/")+1).c_str(),
+aligned_offset_in_section, aligned_offset_in_section + input_section_size,
+input_section_size, aligned_offset_in_section - offset_in_section);
+#endif
+}
+
 this->set_current_data_size_for_child(aligned_offset_in_section
 + input_section_size);
 
@@ -2525,8 +2584,7 @@
 this->generate_code_fills_at_write_ = true;
 }
 
-if (aligned_offset_in_section > offset_in_section
-&& !this->generate_code_fills_at_write_
+if (aligned_offset_in_section > offset_in_section && !this->generate_code_fills_at_write_
 && !have_sections_script
 && (sh_flags & elfcpp::SHF_EXECINSTR) != 0
 && parameters->target().has_code_fill())
@@ -2564,6 +2622,8 @@
 /* If section ordering is requested by specifying a ordering file,
 using --section-ordering-file, match the section name with
 a pattern.  */
+
+isecn.record_input_section_name(secname);
 if (parameters->options().section_ordering_file())
 {
 unsigned int section_order_index =
@@ -3132,10 +3192,11 @@
 return;
 
 if (this->must_sort_attached_input_sections()
-|| this->input_section_order_specified())
+|| this->input_section_order_specified()) 
 this->sort_attached_input_sections();
 
 off_t off = this->first_input_offset_;
+
 for (Input_section_list::iterator p = this->input_sections_.begin();
 p != this->input_sections_.end();
 ++p)
@@ -3154,6 +3215,9 @@
 Output_section::set_final_data_size()
 {
 off_t data_size;
+bool yarp_has_reorder = false;
+Layout *my_layout = yarp_get_layout();
+//assert(my_layout && "[lala]WTF layout is NULL");
 
 if (this->input_sections_.empty())
 data_size = this->current_data_size_for_child();
@@ -3161,19 +3225,89 @@
 {
 if (this->must_sort_attached_input_sections()
 || this->input_section_order_specified())
+{
+yarp_has_reorder = true;
 this->sort_attached_input_sections();
+}
 
 uint64_t address = this->address();
 off_t startoff = this->offset();
 off_t off = startoff + this->first_input_offset_;
+
+// CCR variables
+const char* insecname;
+off_t prev_raw_off = 0;
+if (is_prefix_of(".text", this->name())){
+for (Input_section_list::iterator p = this->input_sections_.begin();
+p != this->input_sections_.end();
+++p)
+{
+if(p->is_input_section() && yarp_has_reorder){
+#ifdef CCR_MSG_DETAILS
+gold_info("[lala]resetting object_id_map for %s[sec:%s]", p->relobj()->name().c_str(), this->name());
+#endif
+p->relobj()->reset_yarp_object_id_map();
+}
+}
+}
+
 for (Input_section_list::iterator p = this->input_sections_.begin();
 p != this->input_sections_.end();
 ++p)
 {
+if (yarp_has_reorder && !strcmp(this->name(),".text") && p->is_input_section()){
+insecname = p->get_input_section_name();
+assert(insecname && "[lala]WTF input section name is NULL");
+
+//yarp:
+// populate the obj_text_padding_map and record the offset of first
+// non-special text section
+// we are gurranteed that obj_id, id_padding_map, object_id_map
+//   and zero_obj are already reset
+//   and the adjusted_start_off is set to MAXIMUM value
+// binpang. comment it out for now
+//if (!my_layout->is_special_section_by_name(insecname)) {
+uint64_t obj_id = my_layout->get_and_increase_yarp_obj_id();
+#ifdef CCR_MSG_DETAILS
+gold_info("[lala]repopulating object_id_map[%s->%d] (total: %d) for %s[%p]", 
+insecname, obj_id, p->relobj()->get_yarp_obj_id_map().size(), p->relobj()->name().c_str(), p->relobj());
+#endif
+p->relobj()->set_yarp_object_id_map(obj_id, insecname);
+#ifdef CCR_MSG_DETAILS
+gold_info("[lala]recomputing %s section: %s", p->relobj()->name().c_str(), insecname);
+gold_info("\t\tbefore  off: %x, size: %x, req: %x", off,p->data_size(), p->addralign());
+#endif
+off_t aligned_off= align_address(off, p->addralign());
+#ifdef CCR_MSG_DETAILS
+gold_info("\t\tafter   off: %x, aligned off: %x, off: %x, size: %x, padding: %x, prev raw: %x",
+aligned_off , aligned_off, off,p->data_size(), prev_raw_off?aligned_off-prev_raw_off:0, prev_raw_off);
+#endif
+my_layout->set_yarp_obj_text_padding_map(obj_id, prev_raw_off?aligned_off - prev_raw_off:0);
+if(p->data_size() == 0){
+my_layout->record_zero_object(obj_id);
+}
+
+#ifdef CCR_MSG_DETAILS
+gold_info("[lala]WTH candidate new startoff: %x for %s[%s]", aligned_off-startoff, p->relobj()->name().c_str(), insecname);
+#endif
+if(p->relobj()->is_yarp_defined_object() && p->data_size() !=0 &&
+(uint64_t)(aligned_off - startoff) < my_layout->get_yarp_adjusted_start_off()){
+#ifdef CCR_MSG_DETAILS
+gold_info("[lala]WTH setting new startoff: %x for %s[.%s]", aligned_off-startoff, p->relobj()->name().c_str(), insecname);
+#endif
+my_layout->set_yarp_adjusted_start_off(aligned_off - startoff);
+}
+prev_raw_off = aligned_off + p->data_size();
+// }
+}
 off = align_address(off, p->addralign());
 p->set_address_and_file_offset(address + (off - startoff), off,
 startoff);
 off += p->data_size();
+#ifdef CCR_MSG_DETAILS
+if(yarp_has_reorder && !strcmp(this->name(),".text") && p->is_input_section())
+gold_info("\t\t last off: %x, sname:%s, data_size: %x", off, p->get_input_section_name(),p->data_size());
+#endif
 }
 data_size = off - startoff;
 }
@@ -3619,11 +3753,13 @@
 // We start by building a larger vector holding a copy of each
 // Input_section, plus its current index in the list and its name.
 std::vector<Input_section_sort_entry> sort_list;
+Layout *my_layout = yarp_get_layout();
+//assert(my_layout && "WTF layout is NULL");
 
 unsigned int i = 0;
 for (Input_section_list::iterator p = this->input_sections_.begin();
 p != this->input_sections_.end();
-++p, ++i)
+++p, ++i) 
 sort_list.push_back(Input_section_sort_entry(*p, i,
 this->must_sort_attached_input_sections(),
 this->name()));
@@ -3639,9 +3775,16 @@
 else if (strcmp(parameters->options().sort_section(), "name") == 0)
 std::sort(sort_list.begin(), sort_list.end(),
 Input_section_sort_section_name_compare());
-else if (strcmp(this->name(), ".text") == 0)
+else if (strcmp(this->name(), ".text") == 0){
 std::sort(sort_list.begin(), sort_list.end(),
 Input_section_sort_section_prefix_special_ordering_compare());
+//in the case of reordering input text sections
+//  reset obj_id, obj_text_padding_map and zero_obj_set  
+my_layout->reset_yarp_obj_id();
+my_layout->reset_zero_object_set();
+my_layout->reset_yarp_obj_text_padding_map();
+my_layout->set_yarp_adjusted_start_off(__UINT64_MAX__);
+}
 else
 std::sort(sort_list.begin(), sort_list.end(),
 Input_section_sort_compare());
@@ -3657,8 +3800,9 @@
 this->input_sections_.clear();
 for (std::vector<Input_section_sort_entry>::iterator p = sort_list.begin();
 p != sort_list.end();
-++p)
+++p) 
 this->input_sections_.push_back(p->input_section());
+
 sort_list.clear();
 
 // Remember that we sorted the input sections, since we might get
diff -ru gold_origin/output.h gold_2.27_modified/output.h
--- gold_origin/output.h	2019-08-25 16:45:35.301404699 -0400
+++ gold_2.27_modified/output.h	2019-08-25 16:39:52.374989090 -0400
@@ -116,7 +116,7 @@
 // buffer to the file, passing in the offset and the size.
 void
 write_output_view(off_t, size_t, unsigned char*)
-{ }
+{}
 
 // Get a read/write buffer.  This is used when we want to write part
 // of the file, read it in, and write it again.
@@ -221,6 +221,8 @@
 // Return the file offset.  This is only valid after
 // Layout::finalize is finished.  For some non-allocated sections,
 // it may not be valid until near the end of the link.
+
+// CCR: we are gonna call it at relocation time, which is way over layout::finalize
 off_t
 offset() const
 {
@@ -414,6 +416,14 @@
 print_to_mapfile(Mapfile* mapfile) const
 { return this->do_print_to_mapfile(mapfile); }
 
+//CCR: force to set .rand data size
+//   CAUTION: only use it on .rand section!
+void
+yarp_set_data_size(off_t data_size)
+{
+this->data_size_ = data_size;
+this->is_data_size_valid_ = true;
+}
 protected:
 // Functions that child classes may or in some cases must implement.
 
@@ -3268,6 +3278,11 @@
 unsigned int shndx, const char* name,
 const elfcpp::Shdr<size, big_endian>& shdr,
 unsigned int reloc_shndx, bool have_sections_script);
+void yarp_record_layout(Layout *layout)
+{this->p_yarp_layout = layout;}
+Layout *
+yarp_get_layout()
+{return this->p_yarp_layout;}
 
 // Add generated data POSD to this output section.
 void
@@ -3961,6 +3976,14 @@
 this->u2_.posd->print_merge_stats(section_name);
 }
 
+//yarp: accessor to insecname;
+void
+record_input_section_name(const char * inname)
+{this->insname_ = new std::string(inname);}
+const char *
+get_input_section_name()
+{return this->insname_->c_str();};
+
 private:
 // Code values which appear in shndx_.  If the value is not one of
 // these codes, it is the input section index in the object file.
@@ -4009,6 +4032,9 @@
 // The line number of the pattern it matches in the --section-ordering-file
 // file.  It is 0 if does not match any pattern.
 unsigned int section_order_index_;
+
+//yarp: we need to record the input section name as well
+std::string *insname_;
 };
 
 // Store the list of input sections for this Output_section into the
@@ -4623,6 +4649,8 @@
 Output_fill* free_space_fill_;
 // Amount added as patch space for incremental linking.
 off_t patch_space_;
+// FIXME: only used by yarp, should use a better way to get the layout pointer
+Layout* p_yarp_layout = NULL;
 };
 
 // An output segment.  PT_LOAD segments are built from collections of
Only in gold_2.27_modified: README.md
diff -ru gold_origin/readsyms.cc gold_2.27_modified/readsyms.cc
--- gold_origin/readsyms.cc	2019-08-25 16:46:05.637614346 -0400
+++ gold_2.27_modified/readsyms.cc	2019-08-25 16:41:24.179645623 -0400
@@ -396,7 +396,7 @@
 }
 return false;
 }
-
+//YH: Read_symbols_data is initialized here
 Read_symbols_data* sd = new Read_symbols_data;
 elf_obj->read_symbols(sd);
 
@@ -589,7 +589,7 @@
 }
 
 // Add the symbols in the object to the symbol table.
-
+// YH: This method works on one object/lib at a time
 void
 Add_symbols::run(Workqueue*)
 {
diff -ru gold_origin/reloc.cc gold_2.27_modified/reloc.cc
--- gold_origin/reloc.cc	2019-08-25 16:46:09.133638473 -0400
+++ gold_2.27_modified/reloc.cc	2019-08-25 16:41:27.491669153 -0400
@@ -36,6 +36,12 @@
 #include "compressed_output.h"
 #include "incremental.h"
 
+//#define CCR_READ_FROM_SECTION
+//#define CCR_READ_FROM_FILE
+//#include "shuffleInfo.pb.h"
+#include <iostream>
+#include <fstream>
+#include <string>
 namespace gold
 {
 
@@ -594,7 +600,6 @@
 const unsigned char* pshdrs = this->get_view(this->elf_file_.shoff(),
 shnum * This::shdr_size,
 true, true);
-
 Views views;
 views.resize(shnum);
 
@@ -648,11 +653,15 @@
 views[i].view_size,
 views[i].view);
 else
+{
+// gold_info("[wrting] offset: %lx, size: %lx", views[i].offset, views[i].view_size);
+// gold_info("rand view: %s", views[i].view);
 of->write_output_view(views[i].offset, views[i].view_size,
 views[i].view);
 }
 }
 }
+}
 
 // Write out the local symbols.
 this->write_local_symbols(of, layout->sympool(), layout->dynpool(),
@@ -692,11 +701,17 @@
 {
 View_size* pvs = &(*pviews)[i];
 
-pvs->view = NULL;
+//[obsolte]CCR: since the output_section is done for every linking object
+//   our .rand section can be written referenced multiple times
+//   after we set up the output bytes for the first time, we don't
+//   want future references from other objects to overwrite our setting before
+//   so here, we move the nullification initialization of pvs->view after our check below
 
 const Output_section* os = out_sections[i];
 if (os == NULL)
 continue;
+
+pvs->view = NULL;
 Address output_offset = out_offsets[i];
 
 typename This::Shdr shdr(p);
@@ -750,6 +765,9 @@
 // buffer, and the output section is responsible for writing the
 // final data to the output file.
 
+
+
+
 off_t output_section_offset;
 Address output_section_size;
 if (!os->requires_postprocessing())
@@ -764,6 +782,8 @@
 convert_types<Address, off_t>(os->postprocessing_buffer_size());
 }
 
+
+
 off_t view_start;
 section_size_type view_size;
 bool must_decompress = false;
@@ -784,9 +804,17 @@
 view_size = convert_to_section_size_type(output_section_size);
 }
 
+
 if (view_size == 0)
 continue;
 
+// gold_info("CCR: %s-%s, output_section_offset: %lx, output_section_size: %lx, output_offset: %lx, view size: %lx",
+//           this->name().c_str(), os->name(), output_section_offset, output_section_size, output_offset, view_size);
+// if(is_rand_section)
+// {
+//     output_offset = 0;
+//     view_size = my_layout->serialize_shuffle_info()->length();
+// }
 gold_assert(output_offset == invalid_address
 || output_offset + view_size <= output_section_size);
 
@@ -819,9 +847,17 @@
 rm.push_back(File_read::Read_multiple_entry(sh_offset,
 view_size, view));
 }
+// CCR: we switch the view to our new serialized google protobuf data
+// if(is_rand_section)
+// {
+//   // gold_info("before : %s", view);
+//   view = my_layout->get_serialized_shuffle_info_for_view();
+//   // gold_info("after : %s", view);
+// }
 }
 }
 
+
 if (must_decompress)
 {
 // Read and decompress the section.
@@ -834,12 +870,13 @@
 this->section_name(i).c_str());
 }
 
+
 pvs->view = view;
 pvs->address = os->address();
 if (output_offset != invalid_address)
 pvs->address += output_offset;
 pvs->offset = view_start;
-pvs->view_size = view_size;
+pvs->view_size = view_size; 
 pvs->is_input_output_view = output_offset == invalid_address;
 pvs->is_postprocessing_view = os->requires_postprocessing();
 pvs->is_ctors_reverse_view =
@@ -848,8 +885,12 @@
 && (strcmp(os->name(), ".init_array") == 0
 || strcmp(os->name(), ".fini_array") == 0)
 && layout->is_ctors_in_init_array(this, i));
-}
 
+// if(is_rand_section){
+//     my_layout->read_shuffleInfo(my_layout->get_global_shuffleInfo());
+//     gold_info("[CCR] my view: length %x, offset: %x, address: %x, view: %s", my_layout->get_serialized_shuffle_info()->length(), pvs->offset, pvs->address, pvs->view);
+// }
+}
 // Actually read the data.
 if (!rm.empty())
 {
@@ -876,6 +917,8 @@
 parameters->sized_target<size, big_endian>();
 
 const Output_sections& out_sections(this->output_sections());
+
+//yh: map for each input section to which offset in its output section
 const std::vector<Address>& out_offsets(this->section_offsets());
 
 Relocate_info<size, big_endian> relinfo;
@@ -883,11 +926,64 @@
 relinfo.layout = layout;
 relinfo.object = this;
 
+/* The following add_shuffleInfo() is obsolete, which moved to update_shuffleInfo() in layout.cc
+// In some cases (particularly with -lto), the order of relocation differs from that of output. (Why?)
+if(this->is_yarp_defined_object()){
+//const std::string sec_name = this->name().data();
+const char* sec_name = this->name().c_str();
+// gold_info("OUTSIDE %s .text[%d] final offset in output section 0x%lx", sec_name,this->get_text_shndx(sec_name),
+// out_offsets[this->get_text_shndx(sec_name)]);
+// gold_info(" .rodata[%d] final offset in output section 0x%lx", this->get_rodata_shndx(sec_name),
+// out_offsets[this->get_rodata_shndx(sec_name)]);
+// gold_info(" .data[%d] final offset in output section 0x%lx", this->get_data_shndx(sec_name),
+// out_offsets[this->get_data_shndx(sec_name)]);
+Layout *my_layout = const_cast<Layout *>(layout);
+#ifdef CCR_READ_FROM_SECTION
+section_size_type rand_sec_len;
+const unsigned char *my_contents = this->section_contents(this->get_rand_shndx(".rand"), &rand_sec_len, false);
+std::string rand_input(reinterpret_cast<const char *>(my_contents), rand_sec_len);
+if(rand_sec_len > 0){
+ShuffleInfo::ReorderInfo reorder_info;
+reorder_info.ParseFromString(rand_input);
+my_layout->add_shuffleInfo(reorder_info, this);
+}
+#endif
+#ifdef CCR_READ_FROM_FILE
+std::string filename = this->name().substr(0, this->name().find_last_of("."));
+std::string pathname;
+bool has_dir = strstr(filename.c_str(), "/");
+if(has_dir){
+pathname = filename.substr(0, filename.find_last_of("/")); //stop uitil the last '/'
+filename = filename.substr(filename.find_last_of("/")+1);
+}
+if(strstr(filename.c_str(), ".a(")){
+filename = filename.substr(filename.find_first_of("(") + 1); //start from after the first '('
+}
+if(has_dir){
+filename = pathname +"/" +filename;
+}
+
+if(!my_layout->visited_shuffle_bin(filename)){
+std::string shuffle_info_name = filename + ".o.shuffle.bin";
+std::fstream input(shuffle_info_name.c_str(), std::ios::in | std::ios::binary);
+if (!reorder_info.ParseFromIstream(&input)) {
+gold_info("[CCR] ERROR: can't find shuffle.bin file for object: %s", this->name().c_str());
+gold_info("filename: %s, objectname: %s", filename.c_str(), shuffle_info_name.c_str());
+}
+my_layout->add_shuffleInfo(reorder_info, this);
+// assert(!std::remove(shuffle_info_name.c_str()));
+// gold_info("[CCR]removing %s", filename.c_str());
+}else{
+gold_info("[CCR]pitfall#5 we are revisting same object %s", filename.c_str());
+}
+#endif
+}
+*/
+
 const unsigned char* p = pshdrs + This::shdr_size;
 for (unsigned int i = 1; i < shnum; ++i, p += This::shdr_size)
 {
 typename This::Shdr shdr(p);
-
 unsigned int sh_type = shdr.get_sh_type();
 if (sh_type != elfcpp::SHT_REL && sh_type != elfcpp::SHT_RELA)
 continue;
@@ -911,6 +1007,7 @@
 // discarded.
 continue;
 }
+
 Address output_offset = out_offsets[index];
 
 gold_assert((*pviews)[index].view != NULL);
@@ -964,6 +1061,7 @@
 Reloc_symbol_changes* reloc_map = NULL;
 if (this->uses_split_stack() && output_offset != invalid_address)
 {
+gold_info("[CCR-error] can't handle incremental linking with -fsplit-stack option");
 typename This::Shdr data_shdr(pshdrs + index * This::shdr_size);
 if ((data_shdr.get_sh_flags() & elfcpp::SHF_EXECINSTR) != 0)
 this->split_stack_adjust(symtab, pshdrs, sh_type, index,
@@ -977,10 +1075,22 @@
 rr = this->relocatable_relocs(i);
 relinfo.rr = rr;
 
+std::string obj_name = relinfo.object->name();
+
+// CCR: Mark the VA and its size of the section in an object file
+// gold_info("[CCR] [%3d]%s@%s [0x%x:0x%x](=0x%xB) (SecOff=0x%x) do_relocate_sections()@reloc.cc", 
+// index, os->name(), obj_name.substr(obj_name.find_last_of("/")+1).c_str(), 
+// os->address(), os->address() + view_size, view_size, os->offset(), os->address());
+
 if (!parameters->options().relocatable())
 {
 target->relocate_section(&relinfo, sh_type, prelocs, reloc_count, os,
+//yh: output_offset is the offset of the obj section (in terms of final section offset)  
+// output_offset + reloc_off = reference SRC offset we need(relative to output section base)
 output_offset == invalid_address,
+//yh: view ->point to begin of obj section being patched
+//yh: address is the address of the obj section (in terms of final mem address)being patched
+//yh: view_size is the size of the patched obj section
 view, address, view_size, reloc_map);
 if (parameters->options().emit_relocs())
 target->relocate_relocs(&relinfo, sh_type, prelocs, reloc_count,
@@ -992,7 +1102,7 @@
 this->incremental_relocs_write(&relinfo, sh_type, prelocs,
 reloc_count, os, output_offset, of);
 }
-else
+else{
 target->relocate_relocs(&relinfo, sh_type, prelocs, reloc_count,
 os, output_offset,
 view, address, view_size,
@@ -1000,6 +1110,7 @@
 (*pviews)[i].view_size);
 }
 }
+}
 
 // Return the output view for section SHNDX.
 
diff -ru gold_origin/reloc.h gold_2.27_modified/reloc.h
--- gold_origin/reloc.h	2019-08-25 16:46:05.493613352 -0400
+++ gold_2.27_modified/reloc.h	2019-08-25 16:41:24.003644374 -0400
@@ -31,6 +31,8 @@
 #include "elfcpp.h"
 #include "workqueue.h"
 
+#include "object.h"
+#include "layout.h"
 namespace gold
 {
 
@@ -394,6 +396,281 @@
 }
 }
 
+// yh: make counterpart of these functions, so that we don't mess with the relocation routines for other architectures.
+// CCR: begin of the yarp rel calculations
+// Do a simple relocation with the addend in the section contents.
+// VALSIZE is the size of the value.
+template<int valsize>
+static inline Reloc_status
+yarp_rel(unsigned char* view, Address value, Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+Valtype addend = elfcpp::Swap<valsize, big_endian>::readval(wv);
+value += addend;
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<valsize, big_endian>::
+writeval(wv, static_cast<Valtype>(value));
+return check_overflow<valsize>(value, check);
+}
+
+// Like the above but for relocs at unaligned addresses.
+template<int valsize>
+static inline Reloc_status
+yarp_rel_unaligned(unsigned char* view, Address value, Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo)
+{
+typedef typename elfcpp::Swap_unaligned<valsize, big_endian>::Valtype
+Valtype;
+Valtype addend = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
+value += addend;
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap_unaligned<valsize, big_endian>::
+writeval(view, static_cast<Valtype>(value));
+return check_overflow<valsize>(value, check);
+}
+
+// Do a simple relocation using a Symbol_value with the addend in
+// the section contents.  VALSIZE is the size of the value to
+// relocate.
+template<int valsize>
+static inline Reloc_status
+yarp_rel(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+Valtype addend = elfcpp::Swap<valsize, big_endian>::readval(wv);
+Address value = psymval->value(object, addend);
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<valsize, big_endian>::
+writeval(wv, static_cast<Valtype>(value));
+return check_overflow<valsize>(value, check);
+}
+
+// Like the above but for relocs at unaligned addresses.
+template<int valsize>
+static inline Reloc_status
+yarp_rel_unaligned(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap_unaligned<valsize, big_endian>::Valtype
+Valtype;
+Valtype addend = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
+Address value = psymval->value(object, addend);
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, value);
+return check_overflow<valsize>(value, check);
+}
+
+// Do a simple relocation with the addend in the relocation.
+// VALSIZE is the size of the value.
+template<int valsize>
+static inline Reloc_status
+yarp_rela(unsigned char* view, Address value, Addendtype addend,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+value += addend;
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
+return check_overflow<valsize>(value, check);
+}
+
+// Do a simple relocation using a symbol value with the addend in
+// the relocation.  VALSIZE is the size of the value.
+template<int valsize>
+static inline Reloc_status
+yarp_rela(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+Address value = psymval->value(object, addend);
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+// gold_info("		Resolved Value: %x,  obj: %s, textos:%d", value,  object->name().c_str(), p_relinfo->object->get_textos_seed());
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
+return check_overflow<valsize>(value, check);
+}
+
+// Do a simple PC relative relocation with the addend in the section
+// contents.  VALSIZE is the size of the value.
+template<int valsize>
+static inline Reloc_status
+yarp_pcrel(unsigned char* view, Address value, Address address,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+Valtype addend = elfcpp::Swap<valsize, big_endian>::readval(wv);
+value = value + addend - address;
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
+return check_overflow<valsize>(value, check);
+}
+
+// Like the above but for relocs at unaligned addresses.
+template<int valsize>
+static inline Reloc_status
+yarp_pcrel_unaligned(unsigned char* view, Address value, Address address,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype addend = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
+value = value + addend - address;
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, value);
+return check_overflow<valsize>(value, check);
+}
+
+// Do a simple PC relative relocation with a Symbol_value with the
+// addend in the section contents.  VALSIZE is the size of the
+// value.
+template<int valsize>
+static inline Reloc_status
+yarp_pcrel(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Address address,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+Valtype addend = elfcpp::Swap<valsize, big_endian>::readval(wv);
+Address value = psymval->value(object, addend) - address;
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
+return check_overflow<valsize>(value, check);
+}
+
+// Do a simple PC relative relocation with the addend in the
+// relocation.  VALSIZE is the size of the value.
+template<int valsize>
+static inline Reloc_status
+yarp_pcrela(unsigned char* view, Address value, Addendtype addend, Address address,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+value = value + addend - address;
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
+return check_overflow<valsize>(value, check);
+}
+
+// Do a simple PC relative relocation with a Symbol_value with the
+// addend in the relocation.  VALSIZE is the size of the value.
+template<int valsize>
+static inline Reloc_status
+yarp_pcrela(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+Address address,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+Address value = psymval->value(object, addend) - address;
+//gold_info("		Resolved Value: %x", value);
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
+return check_overflow<valsize>(value, check);
+}
+
+// CCR: begin of the normal rel calculations
 // Do a simple relocation with the addend in the section contents.
 // VALSIZE is the size of the value.
 template<int valsize>
@@ -404,6 +681,7 @@
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 Valtype addend = elfcpp::Swap<valsize, big_endian>::readval(wv);
 value += addend;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<valsize, big_endian>::
 writeval(wv, static_cast<Valtype>(value));
 return check_overflow<valsize>(value, check);
@@ -418,6 +696,7 @@
 Valtype;
 Valtype addend = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
 value += addend;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap_unaligned<valsize, big_endian>::
 writeval(view, static_cast<Valtype>(value));
 return check_overflow<valsize>(value, check);
@@ -437,6 +716,7 @@
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 Valtype addend = elfcpp::Swap<valsize, big_endian>::readval(wv);
 Address value = psymval->value(object, addend);
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<valsize, big_endian>::
 writeval(wv, static_cast<Valtype>(value));
 return check_overflow<valsize>(value, check);
@@ -454,6 +734,7 @@
 Valtype;
 Valtype addend = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
 Address value = psymval->value(object, addend);
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, value);
 return check_overflow<valsize>(value, check);
 }
@@ -468,6 +749,7 @@
 typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 value += addend;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
 return check_overflow<valsize>(value, check);
 }
@@ -485,6 +767,7 @@
 typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 Address value = psymval->value(object, addend);
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
 return check_overflow<valsize>(value, check);
 }
@@ -500,6 +783,7 @@
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 Valtype addend = elfcpp::Swap<valsize, big_endian>::readval(wv);
 value = value + addend - address;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
 return check_overflow<valsize>(value, check);
 }
@@ -513,6 +797,7 @@
 typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
 Valtype addend = elfcpp::Swap_unaligned<valsize, big_endian>::readval(view);
 value = value + addend - address;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap_unaligned<valsize, big_endian>::writeval(view, value);
 return check_overflow<valsize>(value, check);
 }
@@ -532,6 +817,7 @@
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 Valtype addend = elfcpp::Swap<valsize, big_endian>::readval(wv);
 Address value = psymval->value(object, addend) - address;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
 return check_overflow<valsize>(value, check);
 }
@@ -546,6 +832,7 @@
 typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 value = value + addend - address;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
 return check_overflow<valsize>(value, check);
 }
@@ -564,6 +851,7 @@
 typedef typename elfcpp::Swap<valsize, big_endian>::Valtype Valtype;
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 Address value = psymval->value(object, addend) - address;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<valsize, big_endian>::writeval(wv, value);
 return check_overflow<valsize>(value, check);
 }
@@ -571,6 +859,135 @@
 typedef Relocate_functions<size, big_endian> This;
 
 public:
+// CCR: duplicated relocation prototype
+static inline void
+yarp_rela64(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_rela<64>(view, object, psymval, addend, CHECK_NONE,
+fixup_offset, p_relinfo); }
+
+static inline void
+yarp_pcrela64(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+Address address,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_pcrela<64>(view, object, psymval, addend, address,
+CHECK_NONE, fixup_offset, p_relinfo); }
+
+// CCR: added to handle the following relocation types in Relocate::relocate()@x86_64.cc
+//      R_X86_64_GOTPCREL, R_X86_64_GOTPCRELX and R_X86_64_REX_GOTPCRELX
+static inline void
+yarp_pcrela32(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+Address address,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_pcrela<32>(view, object, psymval, addend, address,
+CHECK_NONE, fixup_offset, p_relinfo); }
+
+static inline Reloc_status
+yarp_rela32_check(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ return This::template yarp_rela<32>(view, object, psymval, addend, check,
+fixup_offset, p_relinfo); }
+
+static inline Reloc_status
+yarp_pcrela32_check(unsigned char* view, Address value, Addendtype addend,
+Address address, Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ return This::template yarp_pcrela<32>(view, value, addend, address, check,fixup_offset, p_relinfo); }
+
+
+static inline void
+yarp_rela16(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_rela<16>(view, object, psymval, addend, CHECK_NONE,fixup_offset, p_relinfo); }
+
+
+static inline void
+yarp_pcrela16(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+Address address,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_pcrela<16>(view, object, psymval, addend, address,
+CHECK_NONE,fixup_offset, p_relinfo); }
+
+static inline void
+yarp_rela8(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_rela<8>(view, object, psymval, addend, CHECK_NONE,fixup_offset, p_relinfo); }
+
+
+static inline void
+yarp_pcrela8(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+Address address,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_pcrela<8>(view, object, psymval, addend, address,
+CHECK_NONE,fixup_offset, p_relinfo); }
+
+static inline Reloc_status
+yarp_pcrela32_check(unsigned char* view,
+const Sized_relobj_file<size, big_endian>* object,
+const Symbol_value<size>* psymval,
+Addendtype addend,
+Address address,
+Overflow_check check,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ return This::template yarp_pcrela<32>(view, object, psymval, addend, address,
+check,fixup_offset, p_relinfo); }
+
+static inline void
+yarp_rela32(unsigned char* view, Address value, Addendtype addend,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_rela<32>(view, value, addend, CHECK_NONE,fixup_offset, p_relinfo); }
+
+static inline void
+yarp_rela64(unsigned char* view, Address value, Addendtype addend,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_rela<64>(view, value, addend, CHECK_NONE,fixup_offset, p_relinfo); }
+
+static inline void
+yarp_pcrela64(unsigned char* view, Address value, Addendtype addend,
+Address address,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{ This::template yarp_pcrela<64>(view, value, addend, address, CHECK_NONE,fixup_offset, p_relinfo); }
+
+
+// CCR: normal relocation rountines start from here
 // Do a simple 8-bit REL relocation with the addend in the section
 // contents.
 static inline void
Only in gold_2.27_modified: shuffleInfo.pb.cc
Only in gold_2.27_modified: shuffleInfo.pb.h
Only in gold_2.27_modified: shuffleInfo.proto
Only in gold_2.27_modified: shuffleInfo.so
diff -ru gold_origin/symtab.cc gold_2.27_modified/symtab.cc
--- gold_origin/symtab.cc	2019-08-25 16:46:07.425626686 -0400
+++ gold_2.27_modified/symtab.cc	2019-08-25 16:41:25.803657162 -0400
@@ -1196,7 +1196,9 @@
 orig_st_shndx = elfcpp::SHN_UNDEF;
 
 if (st_shndx != elfcpp::SHN_UNDEF)
+{
 ++*defined;
+}
 
 // A symbol defined in a section which we are not including must
 // be treated as an undefined symbol.
diff -ru gold_origin/target-reloc.h gold_2.27_modified/target-reloc.h
--- gold_origin/target-reloc.h	2019-08-25 16:45:38.629427723 -0400
+++ gold_2.27_modified/target-reloc.h	2019-08-25 16:39:59.391039578 -0400
@@ -267,9 +267,9 @@
 Output_section* output_section,
 bool needs_special_offset_handling,
 unsigned char* view,
-typename elfcpp::Elf_types<size>::Elf_Addr view_address,
+typename elfcpp::Elf_types<size>::Elf_Addr view_address, 
 section_size_type view_size,
-const Reloc_symbol_changes* reloc_symbol_changes)
+const Reloc_symbol_changes* reloc_symbol_changes) //yh: assume the last argument is null
 {
 typedef typename Classify_reloc::Reltype Reltype;
 const int reloc_size = Classify_reloc::reloc_size;
@@ -277,6 +277,15 @@
 Relocate_comdat_behavior relocate_comdat_behavior;
 
 Sized_relobj_file<size, big_endian>* object = relinfo->object;
+// const char *yarp_data_secname = relinfo->object->section_name(relinfo->data_shndx).c_str();
+// if(!strcmp(yarp_data_secname, ".text"))
+//     gold_info("[yarp more info] <%s>-----patching <%s>[%d] (refs from code)",
+//               object->name().c_str(), 
+//               yarp_data_secname, relinfo->data_shndx);
+// else
+//     gold_info("[CCR more info] <%s>-----patching <%s>[%d] (refs from DATA)",
+//                 object->name().c_str(), 
+//                 yarp_data_secname, relinfo->data_shndx);
 unsigned int local_count = object->local_symbol_count();
 
 Comdat_behavior comdat_behavior = CB_UNDETERMINED;
@@ -290,11 +299,15 @@
 
 if (needs_special_offset_handling)
 {
+// gold_info("   [relocation]special fixup offset before <0x%x>",
+//           static_cast<int>(offset));
 offset = output_section->output_offset(relinfo->object,
 relinfo->data_shndx,
 offset);
 if (offset == -1)
 continue;
+// gold_info("   [relocation]special fixup offset after <0x%x>",
+//           static_cast<int>(offset));
 }
 
 unsigned int r_sym = Classify_reloc::get_r_sym(&reloc);
@@ -312,6 +325,7 @@
 sym = NULL;
 psymval = object->local_symbol(r_sym);
 
+// gold_info("  [local sym]");
 // If the local symbol belongs to a section we are discarding,
 // and that section is a debug section, try to find the
 // corresponding kept section and map this symbol to its
@@ -327,6 +341,7 @@
 }
 else
 {
+// gold_info("  [global sym]");
 const Symbol* gsym;
 if (reloc_symbol_changes != NULL
 && (*reloc_symbol_changes)[i] != NULL)
@@ -336,8 +351,10 @@
 gsym = object->global_symbol(r_sym);
 gold_assert(gsym != NULL);
 if (gsym->is_forwarder())
+{
 gsym = relinfo->symtab->resolve_forwards(gsym);
 }
+}
 
 sym = static_cast<const Sized_symbol<size>*>(gsym);
 if (sym->has_symtab_index() && sym->symtab_index() != -1U)
@@ -355,11 +372,23 @@
 (gsym->is_defined_in_discarded_section()
 && gsym->is_undefined());
 shndx = 0;
+
+//yh: to locate the placeholder for this reference
+if(!strcmp("main", sym->name())){
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR] Ptr to main(): 0x%lx relocate_section()@target-reloc.h", view_address + offset);
+#endif
+Layout *my_layout = const_cast<Layout *>(relinfo->layout);
+my_layout->yarp_set_main_addr_off(view_address + offset - my_layout->yarp_find_os_base_addr_by_name(".text"));
+}
 }
 
 Symbol_value<size> symval2;
 if (is_defined_in_discarded_section)
 {
+#ifdef CCR_MSG_DETAILS
+gold_info("[CCR Error]not handle--defined in discarded section");
+#endif
 if (comdat_behavior == CB_UNDETERMINED)
 {
 std::string name = object->section_name(relinfo->data_shndx);
@@ -396,10 +425,12 @@
 // ignore the relocation.  Pass in NULL as the VIEW argument so
 // that it can return quickly without trashing an invalid memory
 // address.
+
 unsigned char *v = view + offset;
 if (offset < 0 || static_cast<section_size_type>(offset) >= view_size)
 v = NULL;
 
+// gold_info("[Relocating real offset]0x%lx, 0x%lx", offset, view_address + offset);
 if (!relocate.relocate(relinfo, Classify_reloc::sh_type, target,
 output_section, i, prelocs, sym, psymval,
 v, view_address + offset, view_size))
diff -ru gold_origin/x86_64.cc gold_2.27_modified/x86_64.cc
--- gold_origin/x86_64.cc	2019-08-25 16:46:07.009623815 -0400
+++ gold_2.27_modified/x86_64.cc	2019-08-25 16:41:25.443654605 -0400
@@ -43,6 +43,7 @@
 #include "gc.h"
 #include "icf.h"
 
+// #define CCR_MSG_DETAILS
 namespace
 {
 
@@ -3437,6 +3438,66 @@
 public:
 typedef Relocate_functions<size, false> Base;
 
+// CCR: the relocation duplicate we use
+static inline typename Base::Reloc_status
+yarp_pcrela32_check(unsigned char* view,
+typename elfcpp::Elf_types<64>::Elf_Addr value,
+typename elfcpp::Elf_types<64>::Elf_Swxword addend,
+typename elfcpp::Elf_types<64>::Elf_Addr address,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<32, false>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+value = value + addend - address;
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Output_section *os_text = p_relinfo->object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = p_relinfo->object->output_sections()[p_relinfo->data_shndx];
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+//gold_info("		Resolved Value: %x", value);
+elfcpp::Swap<32, false>::writeval(wv, value);
+return (Bits<32>::has_overflow(value)
+? Base::RELOC_OVERFLOW : Base::RELOC_OK);
+}
+
+static inline typename Base::Reloc_status
+yarp_pcrela32_check(unsigned char* view,
+const Sized_relobj_file<size, false>* object,
+const Symbol_value<size>* psymval,
+typename elfcpp::Elf_types<64>::Elf_Swxword addend,
+typename elfcpp::Elf_types<64>::Elf_Addr address,
+int fixup_offset, const Relocate_info<size, false>*p_relinfo
+)
+{
+typedef typename elfcpp::Swap<32, false>::Valtype Valtype;
+Valtype* wv = reinterpret_cast<Valtype*>(view);
+typename elfcpp::Elf_types<64>::Elf_Addr value;
+if (addend >= 0)
+value = psymval->value(object, addend);
+else
+{
+// For negative addends, get the symbol value without
+// the addend, then add the addend using 64-bit arithmetic.
+value = psymval->value(object, 0);
+value += addend;
+}
+value -= address;
+if(p_relinfo->object->is_yarp_defined_object() && p_relinfo->object->is_textos_seed_valid()){
+Output_section *os_text = object->output_sections()[p_relinfo->object->get_textos_seed()];
+Output_section *os = object->output_sections()[p_relinfo->data_shndx];
+// gold_info("		Resolved Value: %x,  obj: %s, sec: %s, os: %p[%d], text: %p[%d], num:%d", value,  object->name().c_str(),os->name(), os, p_relinfo->data_shndx,os_text, p_relinfo->object->get_textos_seed(), p_relinfo->object->yarp_get_text_num());
+Layout *my_layout = const_cast<Layout *>(p_relinfo->layout);
+my_layout->yarp_update_fixups(fixup_offset, os, os_text, value);
+}
+elfcpp::Swap<32, false>::writeval(wv, value);
+return (Bits<32>::has_overflow(value)
+? Base::RELOC_OVERFLOW : Base::RELOC_OK);
+}
+
+
+// CCR: the normal relocations start here
 // Do a simple PC relative relocation with the addend in the
 // relocation.
 static inline typename Base::Reloc_status
@@ -3448,6 +3509,7 @@
 typedef typename elfcpp::Swap<32, false>::Valtype Valtype;
 Valtype* wv = reinterpret_cast<Valtype*>(view);
 value = value + addend - address;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<32, false>::writeval(wv, value);
 return (Bits<32>::has_overflow(value)
 ? Base::RELOC_OVERFLOW : Base::RELOC_OK);
@@ -3475,6 +3537,7 @@
 value += addend;
 }
 value -= address;
+//gold_info("		Resolved Value: %x", value);
 elfcpp::Swap<32, false>::writeval(wv, value);
 return (Bits<32>::has_overflow(value)
 ? Base::RELOC_OVERFLOW : Base::RELOC_OK);
@@ -3489,13 +3552,13 @@
 const Relocate_info<size, false>* relinfo,
 unsigned int,
 Target_x86_64<size>* target,
-Output_section*,
+Output_section* os,
 size_t relnum,
 const unsigned char* preloc,
 const Sized_symbol<size>* gsym,
 const Symbol_value<size>* psymval,
 unsigned char* view,
-typename elfcpp::Elf_types<size>::Elf_Addr address,
+typename elfcpp::Elf_types<size>::Elf_Addr address, //yh:  final address of the placeholder, address-os_base=offset we need  
 section_size_type view_size)
 {
 typedef X86_64_relocate_functions<size> Reloc_funcs;
@@ -3504,6 +3567,7 @@
 
 if (this->skip_call_tls_get_addr_)
 {
+//gold_info("[CCR-error] don't handle skip_call_tls_get_addr_");
 if ((r_type != elfcpp::R_X86_64_PLT32
 && r_type != elfcpp::R_X86_64_GOTPCRELX
 && r_type != elfcpp::R_X86_64_PLT32_BND
@@ -3527,6 +3591,12 @@
 
 const Sized_relobj_file<size, false>* object = relinfo->object;
 
+//yarp-begin
+// gold_info("		SRC--Final Fixup_offset: %x",
+//           static_cast<int>(address));
+int yarp_fixup_src_offset = static_cast<int>(address) - os->address();
+//yarp-end
+
 // Pick the value to use for symbols defined in the PLT.
 Symbol_value<size> symval;
 if (gsym != NULL
@@ -3589,49 +3659,81 @@
 case elfcpp::R_X86_64_GNU_VTENTRY:
 break;
 
+//yh: start handling from here
 case elfcpp::R_X86_64_64:
-Reloc_funcs::rela64(view, object, psymval, addend);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_64");
+#endif
+Reloc_funcs::yarp_rela64(view, object, psymval, addend, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_PC64:
-Reloc_funcs::pcrela64(view, object, psymval, addend,
-address);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_PC64");
+#endif
+Reloc_funcs::yarp_pcrela64(view, object, psymval, addend,
+address, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_32:
-rstatus = Reloc_funcs::rela32_check(view, object, psymval, addend,
-Reloc_funcs::CHECK_UNSIGNED);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_32");
+#endif
+rstatus = Reloc_funcs::yarp_rela32_check(view, object, psymval, addend,
+Reloc_funcs::CHECK_UNSIGNED, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_32S:
-rstatus = Reloc_funcs::rela32_check(view, object, psymval, addend,
-Reloc_funcs::CHECK_SIGNED);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_32S");
+#endif
+rstatus = Reloc_funcs::yarp_rela32_check(view, object, psymval, addend,
+Reloc_funcs::CHECK_SIGNED, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_PC32:
 case elfcpp::R_X86_64_PC32_BND:
-rstatus = Reloc_funcs::pcrela32_check(view, object, psymval, addend,
-address);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_PC32");
+#endif
+// gold_info("myobj: %s",object->name().c_str());
+rstatus = Reloc_funcs::yarp_pcrela32_check(view, object, psymval, addend,
+address, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_16:
-Reloc_funcs::rela16(view, object, psymval, addend);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_16");
+#endif
+Reloc_funcs::yarp_rela16(view, object, psymval, addend, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_PC16:
-Reloc_funcs::pcrela16(view, object, psymval, addend, address);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_PC16");
+#endif
+Reloc_funcs::yarp_pcrela16(view, object, psymval, addend, address, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_8:
-Reloc_funcs::rela8(view, object, psymval, addend);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_8");
+#endif
+Reloc_funcs::yarp_rela8(view, object, psymval, addend, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_PC8:
-Reloc_funcs::pcrela8(view, object, psymval, addend, address);
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_PC8");
+#endif
+Reloc_funcs::yarp_pcrela8(view, object, psymval, addend, address, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_PLT32:
 case elfcpp::R_X86_64_PLT32_BND:
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_PLT32");
+#endif
 gold_assert(gsym == NULL
 || gsym->has_plt_offset()
 || gsym->final_value_is_known()
@@ -3641,33 +3743,42 @@
 // Note: while this code looks the same as for R_X86_64_PC32, it
 // behaves differently because psymval was set to point to
 // the PLT entry, rather than the symbol, in Scan::global().
-rstatus = Reloc_funcs::pcrela32_check(view, object, psymval, addend,
-address);
+rstatus = Reloc_funcs::yarp_pcrela32_check(view, object, psymval, addend,
+address, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_PLTOFF64:
 {
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_PLTOFF64");
+#endif
 gold_assert(gsym);
 gold_assert(gsym->has_plt_offset()
 || gsym->final_value_is_known());
 typename elfcpp::Elf_types<size>::Elf_Addr got_address;
 // This is the address of GLOBAL_OFFSET_TABLE.
 got_address = target->got_plt_section()->address();
-Reloc_funcs::rela64(view, object, psymval, addend - got_address);
+Reloc_funcs::yarp_rela64(view, object, psymval, addend - got_address, yarp_fixup_src_offset, relinfo);
 }
 break;
 
 case elfcpp::R_X86_64_GOT32:
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_GOT32");
+#endif
 gold_assert(have_got_offset);
-Reloc_funcs::rela32(view, got_offset, addend);
+Reloc_funcs::yarp_rela32(view, got_offset, addend, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_GOTPC32:
 {
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_GOTPC32");
+#endif
 gold_assert(gsym);
 typename elfcpp::Elf_types<size>::Elf_Addr value;
 value = target->got_plt_section()->address();
-Reloc_funcs::pcrela32_check(view, value, addend, address);
+Reloc_funcs::yarp_pcrela32_check(view, value, addend, address, yarp_fixup_src_offset, relinfo);
 }
 break;
 
@@ -3675,25 +3786,34 @@
 case elfcpp::R_X86_64_GOTPLT64:
 // R_X86_64_GOTPLT64 is obsolete and treated the the same as
 // GOT64.
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_GOT64");
+#endif
 gold_assert(have_got_offset);
-Reloc_funcs::rela64(view, got_offset, addend);
+Reloc_funcs::yarp_rela64(view, got_offset, addend, yarp_fixup_src_offset, relinfo);
 break;
 
 case elfcpp::R_X86_64_GOTPC64:
 {
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_GOTPC64");
+#endif
 gold_assert(gsym);
 typename elfcpp::Elf_types<size>::Elf_Addr value;
 value = target->got_plt_section()->address();
-Reloc_funcs::pcrela64(view, value, addend, address);
+Reloc_funcs::yarp_pcrela64(view, value, addend, address, yarp_fixup_src_offset, relinfo);
 }
 break;
 
 case elfcpp::R_X86_64_GOTOFF64:
 {
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_GOTOFF64");
+#endif
 typename elfcpp::Elf_types<size>::Elf_Addr value;
 value = (psymval->value(object, 0)
 - target->got_plt_section()->address());
-Reloc_funcs::rela64(view, value, addend);
+Reloc_funcs::yarp_rela64(view, value, addend, yarp_fixup_src_offset, relinfo);
 }
 break;
 
@@ -3715,7 +3835,11 @@
 0, &view)))
 {
 view[-2] = 0x8d;
-Reloc_funcs::pcrela32(view, object, psymval, addend, address);
+// CCR: added yarp_pcrela32()
+// Reloc_funcs::pcrela32(view, object, psymval, addend, address);
+Reloc_funcs::yarp_pcrela32(view, object, psymval, addend, address, 
+yarp_fixup_src_offset, relinfo);
+// gold_info("[CCR-error] don't handle linker optimization!");
 }
 // Convert
 // callq *foo@GOTPCRELX(%rip) to
@@ -3736,7 +3860,11 @@
 view[-2] = 0x67;
 view[-1] = 0xe8;
 // Convert GOTPCRELX to 32-bit pc relative reloc.
-Reloc_funcs::pcrela32(view, object, psymval, addend, address);
+// CCR: added yarp_pcrela32()
+//Reloc_funcs::pcrela32(view, object, psymval, addend, address);
+Reloc_funcs::yarp_pcrela32(view, object, psymval, addend, address,
+yarp_fixup_src_offset, relinfo);
+//gold_info("[CCR-error] don't handle linker optimization!");
 }
 else
 {
@@ -3751,8 +3879,11 @@
 // relative and since the instruction following the jmpq is now
 // the nop, offset the address by 1 byte.  The start of the
 // relocation also moves ahead by 1 byte.
-Reloc_funcs::pcrela32(&view[-1], object, psymval, addend,
-address - 1);
+// CCR: added yarp_pcrela32()
+Reloc_funcs::yarp_pcrela32(view, object, psymval, addend, address,
+yarp_fixup_src_offset, relinfo);
+// Reloc_funcs::pcrela32(&view[-1], object, psymval, addend,
+// address - 1);
 }
 }
 else
@@ -3771,19 +3902,25 @@
 }
 typename elfcpp::Elf_types<size>::Elf_Addr value;
 value = target->got_plt_section()->address() + got_offset;
-Reloc_funcs::pcrela32_check(view, value, addend, address);
+// CCR: update the following check with yarp_*()
+Reloc_funcs::yarp_pcrela32_check(view, value, addend, address, yarp_fixup_src_offset, relinfo);
+//Reloc_funcs::pcrela32_check(view, value, addend, address);
 }
 }
 break;
 
 case elfcpp::R_X86_64_GOTPCREL64:
 {
+#ifdef CCR_MSG_DETAILS
+gold_info("		Reloc Type: R_X86_64_GOTPCREL64");
+#endif
 gold_assert(have_got_offset);
 typename elfcpp::Elf_types<size>::Elf_Addr value;
 value = target->got_plt_section()->address() + got_offset;
-Reloc_funcs::pcrela64(view, value, addend, address);
+Reloc_funcs::yarp_pcrela64(view, value, addend, address, yarp_fixup_src_offset, relinfo);
 }
 break;
+//yh: end handling here
 
 case elfcpp::R_X86_64_COPY:
 case elfcpp::R_X86_64_GLOB_DAT:
Only in gold_2.27_modified: .yarpMakefile
Only in gold_2.27_modified: yarp_note
Only in gold_2.27_modified: yarp.readme
Only in gold_2.27_modified: yyscript.c
Only in gold_2.27_modified: yyscript.h
