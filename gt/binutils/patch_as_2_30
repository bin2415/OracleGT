diff --git a/.c b/.c
new file mode 100644
index 0000000..3d186c2
--- /dev/null
+++ b/.c
@@ -0,0 +1,89 @@
+/* bbInfoHandle.h
+ *
+ * Handle basic block related directives
+ */
+
+#ifndef BBINFOHANDLE_H
+#define BBINFOHANDLE_H
+
+#include "as.h"
+#include "shuffleInfo.pb-c.h"
+#include <stdint.h>
+
+extern const pseudo_typeS bbInfo_pseudo_table[];
+extern int update_last_symbol(symbolS*);
+extern void init_bbinfo_global(void);
+extern void bbinfo_init(void);
+extern char bbinfo_is_new_sec(asection*);
+extern char bbinfo_is_new_sec_frag(asection*);
+
+
+
+// basic block related information
+struct basic_block{
+  uint32_t ID; // basic block id, every basic block has unique id in an object
+  uint8_t type; // basic block type: basic block or function boundary.
+ 		// 0 represents basic block. 1 represents function start. 2 represents object end
+  uint32_t offset; // offset from the section
+  int size; // basic block size
+  uint32_t alignment; // basic block alignment
+  uint32_t num_fixs; // number fixups
+  unsigned char fall_through; // whether the basic block is fall through
+  asection *sec; // which section the basic block belongs to
+  struct basic_block *next; // link next basic blosk
+  uint32_t parent_id; // function id
+  uint8_t is_begin; // if current instruction is the first instruction of this basic block
+  fragS *parent_frag; // this basic block belongs to which frag.
+  		      // FIXME. I'm not sure if there exists a basic block cross two fragS.
+};
+
+typedef struct basic_block bbinfo_mbb;
+
+
+// fixup information
+typedef struct fixup{
+  uint32_t offset; // offset from section
+  asection *sec; // which section the basic block belongs to
+  unsigned char is_new_section; // if its parent section is the new section that has the same name
+  unsigned char is_rela; // if this fixup is relative
+  uint32_t size; // the reference's size
+  uint32_t table_size; // for jump table reference only
+  uint32_t entry_size; // for jump table reference only
+  struct fixup *next; // link next fixup
+} bbinfo_fixup;
+
+extern bbinfo_fixup* fixups_list_head; // fixup list
+extern bbinfo_fixup* fixups_list_tail; // last element of fixups list
+extern bbinfo_mbb* mbbs_list_head; // basic blocks list
+extern bbinfo_mbb* mbbs_list_tail; // the last element of basic blocks list
+extern uint32_t cur_function_id; // current function id
+extern uint32_t prev_function_id; // prev function id
+extern uint32_t cur_function_end_id; // current function end id
+extern symbolS *last_symbol; // last user defined symbol
+extern uint32_t cur_block_id; // global current basic block id
+// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number
+extern unsigned text_sec_cnt;
+extern unsigned rodata_sec_cnt;
+extern unsigned data_sec_cnt;
+extern unsigned datarel_sec_cnt;
+extern unsigned init_sec_cnt;
+
+extern unsigned text_sec_frag_cnt;
+extern unsigned rodata_sec_frag_cnt;
+extern unsigned data_sec_frag_cnt;
+extern unsigned datarel_sec_frag_cnt;
+extern unsigned init_sec_frag_cnt;
+
+extern asection *bbinfo_text_sec;
+extern asection *bbinfo_rodata_sec;
+extern asection *bbinfo_data_sec;
+extern asection *bbinfo_init_sec;
+extern asection *bbinfo_datarel_sec;
+
+// shuffleInfo that CCR defines
+extern char* bbinfo_shuffle_info_buf; 
+extern unsigned bbinfo_shuffle_info_buf_len;
+
+extern bbinfo_fixup* bbinfo_init_fixup(void);
+extern void bbinfo_update_shuffle_info(void);
+#endif
diff --git a/Makefile.am b/Makefile.am
index 5aa68f3..e882179 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -70,6 +70,8 @@ GAS_CFILES = \
 	depend.c \
 	dwarf2dbg.c \
 	dw2gencfi.c \
+	bbInfoHandle.c \
+	shuffleInfo.pb-c.c \
 	ecoff.c \
 	ehopt.c \
 	expr.c \
@@ -104,6 +106,8 @@ HFILES = \
 	compress-debug.h \
 	dwarf2dbg.h \
 	dw2gencfi.h \
+	bbInfoHandle.h \
+	shuffleInfo.pb-c.h \
 	ecoff.h \
 	emul-target.h \
 	emul.h \
diff --git a/Makefile.in b/Makefile.in
index 51e96e5..57629ff 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -117,7 +117,9 @@ am__objects_1 = app.$(OBJEXT) as.$(OBJEXT) atof-generic.$(OBJEXT) \
 	listing.$(OBJEXT) literal.$(OBJEXT) macro.$(OBJEXT) \
 	messages.$(OBJEXT) output-file.$(OBJEXT) read.$(OBJEXT) \
 	remap.$(OBJEXT) sb.$(OBJEXT) stabs.$(OBJEXT) subsegs.$(OBJEXT) \
-	symbols.$(OBJEXT) write.$(OBJEXT)
+	symbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) \
+	shuffleInfo.pb-c.$(OBJEXT)
+	
 am_as_new_OBJECTS = $(am__objects_1)
 as_new_OBJECTS = $(am_as_new_OBJECTS)
 am__DEPENDENCIES_1 =
@@ -367,6 +369,8 @@ GAS_CFILES = \
 	depend.c \
 	dwarf2dbg.c \
 	dw2gencfi.c \
+	bbInfoHandle.c \
+	shuffleInfo.pb-c.c \
 	ecoff.c \
 	ehopt.c \
 	expr.c \
@@ -400,6 +404,8 @@ HFILES = \
 	compress-debug.h \
 	dwarf2dbg.h \
 	dw2gencfi.h \
+	bbInfoHandle.h \
+	shuffleInfo.pb-c.h \
 	ecoff.h \
 	emul-target.h \
 	emul.h \
@@ -820,6 +826,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/depend.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dw2gencfi.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dwarf2dbg.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bbInfoHandle.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-crisaout.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-criself.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-i386aout.Po@am__quote@
diff --git a/README b/README.as
similarity index 100%
rename from README
rename to README.as
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..78ca6be
--- /dev/null
+++ b/README.md
@@ -0,0 +1,35 @@
+binutils-2.30
+
+- handle basic block dummy directives [06/08/2019]
+- fix basic block size and fixups [18/08/2019]
+
+## TODO
+
+- [x] Handle assemble file and inline assemble statement
+- [x] Handle the new section for fragment
+- [x] fix basic block size
+- [x] basic block's fixup number equal to total fixup number in .text.xxx section
+- [x] figure out what are .text.startup, .text.hot, .text.exit and .text.unlikely section
+- [x] Support LTO optimization
+- [ ] Handle other sections' fixups(.eh\_frame .etc)
+- [x] add padding size of basic block
+- [ ] There is problem that compile with static link: `-static-libstdc++ -static-libgcc`
+- [ ] .fini\_array section's fixups
+- [ ] handle .init and .fini section
+
+## Problems
+
+- Can't handle fixups in section .plt and .got.plt
+- Can't handle the linker added functions. (We may handle it by compiling the glibc with our tool, but it seems that gold linker can't work correctly of compiling glibc)
+
+## Build
+
+- Install protobuf-c [link](https://github.com/protobuf-c/protobuf-c)
+
+- set CFLAGS and LDFLAGS
+```
+CFLAGS=`pkg-config --cflags 'libprotobuf-c >= 1.0.0'`
+LDFLAGS=`pkg-config --libs 'libprotobuf-c >= 1.0.0'`
+```
+
+
diff --git a/as.c b/as.c
index f6da1b1..45a5583 100644
--- a/as.c
+++ b/as.c
@@ -56,6 +56,11 @@
 extern void gas_cgen_begin (void);
 #endif
 
+// binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+#include "bbInfoHandle.h"
+#endif
+
 /* We build a list of defsyms as we read the options, and then define
    them after we have initialized everything.  */
 struct defsym_list
@@ -1252,6 +1257,11 @@ main (int argc, char ** argv)
   itbl_init ();
 
   dwarf2_init ();
+  
+  // binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+  bbinfo_init();
+#endif
 
   local_symbol_make (".gasversion.", absolute_section,
 		     BFD_VERSION / 10000UL, &predefined_address_frag);
diff --git a/as_patch_8dd86a1 b/as_patch_8dd86a1
new file mode 100644
index 0000000..b3f7f27
--- /dev/null
+++ b/as_patch_8dd86a1
@@ -0,0 +1,8961 @@
+diff --git a/.c b/.c
+new file mode 100644
+index 0000000..3d186c2
+--- /dev/null
++++ b/.c
+@@ -0,0 +1,89 @@
++/* bbInfoHandle.h
++ *
++ * Handle basic block related directives
++ */
++
++#ifndef BBINFOHANDLE_H
++#define BBINFOHANDLE_H
++
++#include "as.h"
++#include "shuffleInfo.pb-c.h"
++#include <stdint.h>
++
++extern const pseudo_typeS bbInfo_pseudo_table[];
++extern int update_last_symbol(symbolS*);
++extern void init_bbinfo_global(void);
++extern void bbinfo_init(void);
++extern char bbinfo_is_new_sec(asection*);
++extern char bbinfo_is_new_sec_frag(asection*);
++
++
++
++// basic block related information
++struct basic_block{
++  uint32_t ID; // basic block id, every basic block has unique id in an object
++  uint8_t type; // basic block type: basic block or function boundary.
++ 		// 0 represents basic block. 1 represents function start. 2 represents object end
++  uint32_t offset; // offset from the section
++  int size; // basic block size
++  uint32_t alignment; // basic block alignment
++  uint32_t num_fixs; // number fixups
++  unsigned char fall_through; // whether the basic block is fall through
++  asection *sec; // which section the basic block belongs to
++  struct basic_block *next; // link next basic blosk
++  uint32_t parent_id; // function id
++  uint8_t is_begin; // if current instruction is the first instruction of this basic block
++  fragS *parent_frag; // this basic block belongs to which frag.
++  		      // FIXME. I'm not sure if there exists a basic block cross two fragS.
++};
++
++typedef struct basic_block bbinfo_mbb;
++
++
++// fixup information
++typedef struct fixup{
++  uint32_t offset; // offset from section
++  asection *sec; // which section the basic block belongs to
++  unsigned char is_new_section; // if its parent section is the new section that has the same name
++  unsigned char is_rela; // if this fixup is relative
++  uint32_t size; // the reference's size
++  uint32_t table_size; // for jump table reference only
++  uint32_t entry_size; // for jump table reference only
++  struct fixup *next; // link next fixup
++} bbinfo_fixup;
++
++extern bbinfo_fixup* fixups_list_head; // fixup list
++extern bbinfo_fixup* fixups_list_tail; // last element of fixups list
++extern bbinfo_mbb* mbbs_list_head; // basic blocks list
++extern bbinfo_mbb* mbbs_list_tail; // the last element of basic blocks list
++extern uint32_t cur_function_id; // current function id
++extern uint32_t prev_function_id; // prev function id
++extern uint32_t cur_function_end_id; // current function end id
++extern symbolS *last_symbol; // last user defined symbol
++extern uint32_t cur_block_id; // global current basic block id
++// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number
++extern unsigned text_sec_cnt;
++extern unsigned rodata_sec_cnt;
++extern unsigned data_sec_cnt;
++extern unsigned datarel_sec_cnt;
++extern unsigned init_sec_cnt;
++
++extern unsigned text_sec_frag_cnt;
++extern unsigned rodata_sec_frag_cnt;
++extern unsigned data_sec_frag_cnt;
++extern unsigned datarel_sec_frag_cnt;
++extern unsigned init_sec_frag_cnt;
++
++extern asection *bbinfo_text_sec;
++extern asection *bbinfo_rodata_sec;
++extern asection *bbinfo_data_sec;
++extern asection *bbinfo_init_sec;
++extern asection *bbinfo_datarel_sec;
++
++// shuffleInfo that CCR defines
++extern char* bbinfo_shuffle_info_buf; 
++extern unsigned bbinfo_shuffle_info_buf_len;
++
++extern bbinfo_fixup* bbinfo_init_fixup(void);
++extern void bbinfo_update_shuffle_info(void);
++#endif
+diff --git a/Makefile.am b/Makefile.am
+index 5aa68f3..e882179 100644
+--- a/Makefile.am
++++ b/Makefile.am
+@@ -70,6 +70,8 @@ GAS_CFILES = \
+ 	depend.c \
+ 	dwarf2dbg.c \
+ 	dw2gencfi.c \
++	bbInfoHandle.c \
++	shuffleInfo.pb-c.c \
+ 	ecoff.c \
+ 	ehopt.c \
+ 	expr.c \
+@@ -104,6 +106,8 @@ HFILES = \
+ 	compress-debug.h \
+ 	dwarf2dbg.h \
+ 	dw2gencfi.h \
++	bbInfoHandle.h \
++	shuffleInfo.pb-c.h \
+ 	ecoff.h \
+ 	emul-target.h \
+ 	emul.h \
+diff --git a/Makefile.in b/Makefile.in
+index 51e96e5..57629ff 100644
+--- a/Makefile.in
++++ b/Makefile.in
+@@ -117,7 +117,9 @@ am__objects_1 = app.$(OBJEXT) as.$(OBJEXT) atof-generic.$(OBJEXT) \
+ 	listing.$(OBJEXT) literal.$(OBJEXT) macro.$(OBJEXT) \
+ 	messages.$(OBJEXT) output-file.$(OBJEXT) read.$(OBJEXT) \
+ 	remap.$(OBJEXT) sb.$(OBJEXT) stabs.$(OBJEXT) subsegs.$(OBJEXT) \
+-	symbols.$(OBJEXT) write.$(OBJEXT)
++	symbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) \
++	shuffleInfo.pb-c.$(OBJEXT)
++	
+ am_as_new_OBJECTS = $(am__objects_1)
+ as_new_OBJECTS = $(am_as_new_OBJECTS)
+ am__DEPENDENCIES_1 =
+@@ -367,6 +369,8 @@ GAS_CFILES = \
+ 	depend.c \
+ 	dwarf2dbg.c \
+ 	dw2gencfi.c \
++	bbInfoHandle.c \
++	shuffleInfo.pb-c.c \
+ 	ecoff.c \
+ 	ehopt.c \
+ 	expr.c \
+@@ -400,6 +404,8 @@ HFILES = \
+ 	compress-debug.h \
+ 	dwarf2dbg.h \
+ 	dw2gencfi.h \
++	bbInfoHandle.h \
++	shuffleInfo.pb-c.h \
+ 	ecoff.h \
+ 	emul-target.h \
+ 	emul.h \
+@@ -820,6 +826,7 @@ distclean-compile:
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/depend.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dw2gencfi.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dwarf2dbg.Po@am__quote@
++@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bbInfoHandle.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-crisaout.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-criself.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-i386aout.Po@am__quote@
+diff --git a/README b/README.as
+similarity index 100%
+rename from README
+rename to README.as
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..ea65688
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,35 @@
++binutils-2.30
++
++- handle basic block dummy directives [06/08/2019]
++- fix basic block size and fixups [18/08/2019]
++
++## TODO
++
++- [ ] Handle assemble file and inline assemble statement
++- [x] Handle the new section for fragment
++- [x] fix basic block size
++- [x] basic block's fixup number equal to total fixup number in .text.xxx section
++- [x] figure out what are .text.startup, .text.hot, .text.exit and .text.unlikely section
++- [x] Support LTO optimization
++- [ ] Handle other sections' fixups(.eh\_frame .etc)
++- [x] add padding size of basic block
++- [ ] There is problem that compile with static link: `-static-libstdc++ -static-libgcc`
++- [ ] .fini\_array section's fixups
++- [ ] handle .init and .fini section
++
++## Problems
++
++- Can't handle fixups in section .plt and .got.plt
++- Can't handle the linker added functions. (We may handle it by compiling the glibc with our tool, but it seems that gold linker can't work correctly of compiling glibc)
++
++## Build
++
++- Install protobuf-c [link](https://github.com/protobuf-c/protobuf-c)
++
++- set CFLAGS and LDFLAGS
++```
++CFLAGS=`pkg-config --cflags 'libprotobuf-c >= 1.0.0'`
++LDFLAGS=`pkg-config --libs 'libprotobuf-c >= 1.0.0'`
++```
++
++
+diff --git a/as.c b/as.c
+index f6da1b1..45a5583 100644
+--- a/as.c
++++ b/as.c
+@@ -56,6 +56,11 @@
+ extern void gas_cgen_begin (void);
+ #endif
+ 
++// binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++#include "bbInfoHandle.h"
++#endif
++
+ /* We build a list of defsyms as we read the options, and then define
+    them after we have initialized everything.  */
+ struct defsym_list
+@@ -1252,6 +1257,11 @@ main (int argc, char ** argv)
+   itbl_init ();
+ 
+   dwarf2_init ();
++  
++  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++  bbinfo_init();
++#endif
+ 
+   local_symbol_make (".gasversion.", absolute_section,
+ 		     BFD_VERSION / 10000UL, &predefined_address_frag);
+diff --git a/autom4te.cache/output.0 b/autom4te.cache/output.0
+new file mode 100644
+index 0000000..e69de29
+diff --git a/autom4te.cache/output.1t b/autom4te.cache/output.1t
+new file mode 100644
+index 0000000..ec88dfd
+--- /dev/null
++++ b/autom4te.cache/output.1t
+@@ -0,0 +1 @@
++@%:@! /bin/sh
+diff --git a/autom4te.cache/requests b/autom4te.cache/requests
+new file mode 100644
+index 0000000..6d18deb
+--- /dev/null
++++ b/autom4te.cache/requests
+@@ -0,0 +1,79 @@
++# This file was generated by Autom4te Sun Aug 20 23:09:08 UTC 2017.
++# It contains the lists of macros which have been traced.
++# It can be safely removed.
++
++@request = (
++             bless( [
++                      '0',
++                      1,
++                      [
++                        '/usr/share/autoconf'
++                      ],
++                      [
++                        '/usr/share/autoconf/autoconf/autoconf.m4f',
++                        'aclocal.m4',
++                        'Makefile.am'
++                      ],
++                      {
++                        'AC_FC_PP_DEFINE' => 1,
++                        '_LT_AC_TAGCONFIG' => 1,
++                        'AC_INIT' => 1,
++                        'AC_CONFIG_SUBDIRS' => 1,
++                        'AM_PROG_CXX_C_O' => 1,
++                        'AM_SILENT_RULES' => 1,
++                        'AM_PATH_GUILE' => 1,
++                        'AC_CONFIG_AUX_DIR' => 1,
++                        'AC_LIBSOURCE' => 1,
++                        'AM_AUTOMAKE_VERSION' => 1,
++                        'AC_CANONICAL_BUILD' => 1,
++                        '_AM_MAKEFILE_INCLUDE' => 1,
++                        'AC_REQUIRE_AUX_FILE' => 1,
++                        'AM_XGETTEXT_OPTION' => 1,
++                        'AC_SUBST' => 1,
++                        'AC_CANONICAL_SYSTEM' => 1,
++                        'AC_PROG_LIBTOOL' => 1,
++                        'AC_CANONICAL_HOST' => 1,
++                        'm4_pattern_forbid' => 1,
++                        'AM_ENABLE_MULTILIB' => 1,
++                        'm4_include' => 1,
++                        'AM_PROG_LIBTOOL' => 1,
++                        '_m4_warn' => 1,
++                        'AM_GNU_GETTEXT_INTL_SUBDIR' => 1,
++                        'AC_CANONICAL_TARGET' => 1,
++                        'AC_FC_FREEFORM' => 1,
++                        'LT_CONFIG_LTDL_DIR' => 1,
++                        'AM_MAINTAINER_MODE' => 1,
++                        'include' => 1,
++                        'AM_MAKEFILE_INCLUDE' => 1,
++                        'AC_DEFINE_TRACE_LITERAL' => 1,
++                        '_AM_COND_ENDIF' => 1,
++                        'AC_CONFIG_FILES' => 1,
++                        'sinclude' => 1,
++                        'm4_pattern_allow' => 1,
++                        'AM_NLS' => 1,
++                        'AM_INIT_AUTOMAKE' => 1,
++                        'AC_FC_PP_SRCEXT' => 1,
++                        '_AM_COND_IF' => 1,
++                        'LT_SUPPORTED_TAG' => 1,
++                        'AC_CONFIG_LIBOBJ_DIR' => 1,
++                        'AC_SUBST_TRACE' => 1,
++                        'AC_CONFIG_HEADERS' => 1,
++                        'm4_sinclude' => 1,
++                        'AM_PROG_AR' => 1,
++                        'AM_PROG_MOC' => 1,
++                        'AM_GNU_GETTEXT' => 1,
++                        'AC_FC_SRCEXT' => 1,
++                        'AM_PROG_F77_C_O' => 1,
++                        'LT_INIT' => 1,
++                        'AM_PROG_FC_C_O' => 1,
++                        '_AM_COND_ELSE' => 1,
++                        'AM_CONDITIONAL' => 1,
++                        'AC_CONFIG_LINKS' => 1,
++                        '_AM_SUBST_NOTMAKE' => 1,
++                        'AH_OUTPUT' => 1,
++                        'AM_PROG_CC_C_O' => 1,
++                        'AM_POT_TOOLS' => 1
++                      }
++                    ], 'Autom4te::Request' )
++           );
++
+diff --git a/autom4te.cache/traces.0 b/autom4te.cache/traces.0
+new file mode 100644
+index 0000000..363ac05
+--- /dev/null
++++ b/autom4te.cache/traces.0
+@@ -0,0 +1,20 @@
++m4trace:aclocal.m4:1012: -1- m4_include([../bfd/acinclude.m4])
++m4trace:aclocal.m4:1013: -1- m4_include([../bfd/warning.m4])
++m4trace:aclocal.m4:1014: -1- m4_include([../config/acx.m4])
++m4trace:aclocal.m4:1015: -1- m4_include([../config/depstand.m4])
++m4trace:aclocal.m4:1016: -1- m4_include([../config/gettext-sister.m4])
++m4trace:aclocal.m4:1017: -1- m4_include([../config/largefile.m4])
++m4trace:aclocal.m4:1018: -1- m4_include([../config/lcmessage.m4])
++m4trace:aclocal.m4:1019: -1- m4_include([../config/lead-dot.m4])
++m4trace:aclocal.m4:1020: -1- m4_include([../config/nls.m4])
++m4trace:aclocal.m4:1021: -1- m4_include([../config/override.m4])
++m4trace:aclocal.m4:1022: -1- m4_include([../config/plugins.m4])
++m4trace:aclocal.m4:1023: -1- m4_include([../config/po.m4])
++m4trace:aclocal.m4:1024: -1- m4_include([../config/progtest.m4])
++m4trace:aclocal.m4:1025: -1- m4_include([../config/zlib.m4])
++m4trace:aclocal.m4:1026: -1- m4_include([../libtool.m4])
++m4trace:aclocal.m4:1027: -1- m4_include([../ltoptions.m4])
++m4trace:aclocal.m4:1028: -1- m4_include([../ltsugar.m4])
++m4trace:aclocal.m4:1029: -1- m4_include([../ltversion.m4])
++m4trace:aclocal.m4:1030: -1- m4_include([../lt~obsolete.m4])
++m4trace:aclocal.m4:1031: -1- m4_include([acinclude.m4])
+diff --git a/autom4te.cache/traces.1t b/autom4te.cache/traces.1t
+new file mode 100644
+index 0000000..b9416dc
+--- /dev/null
++++ b/autom4te.cache/traces.1t
+@@ -0,0 +1,172 @@
++m4trace:aclocal.m4:1012: -1- m4_include([../bfd/acinclude.m4])
++m4trace:aclocal.m4:1013: -1- m4_include([../bfd/warning.m4])
++m4trace:aclocal.m4:1014: -1- m4_include([../config/acx.m4])
++m4trace:aclocal.m4:1015: -1- m4_include([../config/depstand.m4])
++m4trace:aclocal.m4:1016: -1- m4_include([../config/gettext-sister.m4])
++m4trace:aclocal.m4:1017: -1- m4_include([../config/largefile.m4])
++m4trace:aclocal.m4:1018: -1- m4_include([../config/lcmessage.m4])
++m4trace:aclocal.m4:1019: -1- m4_include([../config/lead-dot.m4])
++m4trace:aclocal.m4:1020: -1- m4_include([../config/nls.m4])
++m4trace:aclocal.m4:1021: -1- m4_include([../config/override.m4])
++m4trace:aclocal.m4:1022: -1- m4_include([../config/plugins.m4])
++m4trace:aclocal.m4:1023: -1- m4_include([../config/po.m4])
++m4trace:aclocal.m4:1024: -1- m4_include([../config/progtest.m4])
++m4trace:aclocal.m4:1025: -1- m4_include([../config/zlib.m4])
++m4trace:aclocal.m4:1026: -1- m4_include([../libtool.m4])
++m4trace:aclocal.m4:1027: -1- m4_include([../ltoptions.m4])
++m4trace:aclocal.m4:1028: -1- m4_include([../ltsugar.m4])
++m4trace:aclocal.m4:1029: -1- m4_include([../ltversion.m4])
++m4trace:aclocal.m4:1030: -1- m4_include([../lt~obsolete.m4])
++m4trace:aclocal.m4:1031: -1- m4_include([acinclude.m4])
++m4trace:configure.ac:24: -1- m4_include([../bfd/version.m4])
++m4trace:configure.ac:25: -1- AC_INIT([gas], [2.30])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?A[CHUM]_])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([_AC_])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^LIBOBJS$], [do not use LIBOBJS directly, use AC_LIBOBJ (see section `AC_LIBOBJ vs LIBOBJS'])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^AS_FLAGS$])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?m4_])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^dnl$])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?AS_])
++m4trace:configure.ac:25: -1- AC_SUBST([SHELL])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([SHELL])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^SHELL$])
++m4trace:configure.ac:25: -1- AC_SUBST([PATH_SEPARATOR])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PATH_SEPARATOR])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PATH_SEPARATOR$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_NAME], [m4_ifdef([AC_PACKAGE_NAME],      ['AC_PACKAGE_NAME'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_NAME])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_NAME$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_TARNAME], [m4_ifdef([AC_PACKAGE_TARNAME],   ['AC_PACKAGE_TARNAME'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_TARNAME])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_TARNAME$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_VERSION], [m4_ifdef([AC_PACKAGE_VERSION],   ['AC_PACKAGE_VERSION'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_VERSION])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_VERSION$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_STRING], [m4_ifdef([AC_PACKAGE_STRING],    ['AC_PACKAGE_STRING'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_STRING])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_STRING$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_BUGREPORT], [m4_ifdef([AC_PACKAGE_BUGREPORT], ['AC_PACKAGE_BUGREPORT'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_BUGREPORT])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_URL], [m4_ifdef([AC_PACKAGE_URL],       ['AC_PACKAGE_URL'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_URL])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_URL$])
++m4trace:configure.ac:25: -1- AC_SUBST([exec_prefix], [NONE])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([exec_prefix])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^exec_prefix$])
++m4trace:configure.ac:25: -1- AC_SUBST([prefix], [NONE])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([prefix])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^prefix$])
++m4trace:configure.ac:25: -1- AC_SUBST([program_transform_name], [s,x,x,])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([program_transform_name])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^program_transform_name$])
++m4trace:configure.ac:25: -1- AC_SUBST([bindir], ['${exec_prefix}/bin'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([bindir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^bindir$])
++m4trace:configure.ac:25: -1- AC_SUBST([sbindir], ['${exec_prefix}/sbin'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sbindir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^sbindir$])
++m4trace:configure.ac:25: -1- AC_SUBST([libexecdir], ['${exec_prefix}/libexec'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([libexecdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^libexecdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([datarootdir], ['${prefix}/share'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([datarootdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^datarootdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([datadir], ['${datarootdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([datadir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^datadir$])
++m4trace:configure.ac:25: -1- AC_SUBST([sysconfdir], ['${prefix}/etc'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sysconfdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^sysconfdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([sharedstatedir], ['${prefix}/com'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sharedstatedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^sharedstatedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([localstatedir], ['${prefix}/var'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([localstatedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^localstatedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([runstatedir], ['${localstatedir}/run'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([runstatedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^runstatedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([includedir], ['${prefix}/include'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([includedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^includedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([oldincludedir], ['/usr/include'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([oldincludedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^oldincludedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([docdir], [m4_ifset([AC_PACKAGE_TARNAME],
++				     ['${datarootdir}/doc/${PACKAGE_TARNAME}'],
++				     ['${datarootdir}/doc/${PACKAGE}'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([docdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^docdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([infodir], ['${datarootdir}/info'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([infodir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^infodir$])
++m4trace:configure.ac:25: -1- AC_SUBST([htmldir], ['${docdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([htmldir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^htmldir$])
++m4trace:configure.ac:25: -1- AC_SUBST([dvidir], ['${docdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([dvidir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^dvidir$])
++m4trace:configure.ac:25: -1- AC_SUBST([pdfdir], ['${docdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([pdfdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^pdfdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([psdir], ['${docdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([psdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^psdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([libdir], ['${exec_prefix}/lib'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([libdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^libdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([localedir], ['${datarootdir}/locale'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([localedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^localedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([mandir], ['${datarootdir}/man'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([mandir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^mandir$])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_NAME])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_NAME$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_NAME], [/* Define to the full name of this package. */
++@%:@undef PACKAGE_NAME])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_TARNAME])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_TARNAME$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_TARNAME], [/* Define to the one symbol short name of this package. */
++@%:@undef PACKAGE_TARNAME])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_VERSION])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_VERSION$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_VERSION], [/* Define to the version of this package. */
++@%:@undef PACKAGE_VERSION])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_STRING])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_STRING$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_STRING], [/* Define to the full name and version of this package. */
++@%:@undef PACKAGE_STRING])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_BUGREPORT])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_BUGREPORT], [/* Define to the address where bug reports for this package should be sent. */
++@%:@undef PACKAGE_BUGREPORT])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_URL])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_URL$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_URL], [/* Define to the home page for this package. */
++@%:@undef PACKAGE_URL])
++m4trace:configure.ac:25: -1- AC_SUBST([DEFS])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([DEFS])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^DEFS$])
++m4trace:configure.ac:25: -1- AC_SUBST([ECHO_C])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_C])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_C$])
++m4trace:configure.ac:25: -1- AC_SUBST([ECHO_N])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_N])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_N$])
++m4trace:configure.ac:25: -1- AC_SUBST([ECHO_T])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_T])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_T$])
++m4trace:configure.ac:25: -1- AC_SUBST([LIBS])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([LIBS])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^LIBS$])
++m4trace:configure.ac:25: -1- AC_SUBST([build_alias])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([build_alias])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^build_alias$])
++m4trace:configure.ac:25: -1- AC_SUBST([host_alias])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([host_alias])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^host_alias$])
++m4trace:configure.ac:25: -1- AC_SUBST([target_alias])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([target_alias])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^target_alias$])
+diff --git a/bbInfoHandle.c b/bbInfoHandle.c
+new file mode 100644
+index 0000000..faa80d5
+--- /dev/null
++++ b/bbInfoHandle.c
+@@ -0,0 +1,722 @@
++/*
++ * bbInfoHandle.c
++ */
++
++#include "bbInfoHandle.h"
++#include "struc-symbol.h"
++#include <time.h>
++#include <stdlib.h>
++#include <string.h>
++#include <stdio.h>
++
++static void jmptable_bbInfo_handler (int);
++static void funcb_bbInfo_handler (int);
++static void funce_bbInfo_handler (int);
++static void bb_bbInfo_handler (int);
++static void be_bbInfo_handler (int);
++void bbinfo_update_shuffle_info(void);
++bbinfo_mbb* init_basic_block(void);
++bbinfo_fixup* bbinfo_init_fixup();
++bbinfo_fixup* bbinfo_init_insert_fixup(asection*, int);
++char bbinfo_is_collect_sec(asection*);
++char bbinfo_is_new_sec_frag(asection*);
++
++#ifdef BBINFO_DEBUG_MSG
++char *bbinfo_file_name = NULL;
++#endif
++
++const pseudo_typeS bbInfo_pseudo_table[] = {
++    {"bbinfo_jmptbl", jmptable_bbInfo_handler, 0},
++    {"bbinfo_funb", funcb_bbInfo_handler, 0},
++    {"bbinfo_fune", funce_bbInfo_handler, 0},
++    {"bbinfo_bb", bb_bbInfo_handler, 0},
++    {"bbinfo_be", be_bbInfo_handler, 0},
++    {NULL, NULL, 0}
++};
++
++// debug related symbol
++const char* symbol_blacklist[] = {
++  ".Ldebug",
++  ".LASF"
++};
++
++// global variable
++bbinfo_fixup* fixups_list_head; // fixup list
++bbinfo_mbb* mbbs_list_head;   // first element of basic blocks list
++bbinfo_mbb* mbbs_list_tail; // last element of basic blocks list
++uint32_t cur_function_id;  // current functin id
++uint32_t cur_function_end_id; // current function end id
++uint32_t prev_function_id; // prev function id
++symbolS *last_symbol; // last user defined symbol
++uint32_t cur_block_id; // global current basic block id 
++unsigned char function_head; // represent that the current basic block is current function's first entry
++
++// to record if fixups is in a new section(such as .text.xxx)
++//unsigned text_sec_cnt;
++//unsigned rodata_sec_cnt;
++//unsigned data_sec_cnt;
++//unsigned datarel_sec_cnt;
++//unsigned init_sec_cnt;
++
++unsigned text_sec_frag_cnt;
++unsigned rodata_sec_frag_cnt;
++unsigned data_sec_frag_cnt;
++unsigned datarel_sec_frag_cnt;
++unsigned init_sec_frag_cnt;
++
++asection* bbinfo_text_sec;
++asection* bbinfo_rodata_sec;
++asection* bbinfo_data_sec;
++asection* bbinfo_init_sec;
++asection* bbinfo_datarel_sec;
++
++// store the shuffle information
++char* bbinfo_shuffle_info_buf = NULL;
++unsigned bbinfo_shuffle_info_buf_len = 0;
++
++
++// init the global variables
++void bbinfo_init(){
++  fixups_list_head = NULL;
++  mbbs_list_head = NULL;
++  mbbs_list_tail = NULL;
++  cur_function_id = 0;
++  cur_function_end_id = 0;
++  prev_function_id = 0;
++  last_symbol = NULL;
++  cur_block_id = 0;
++  function_head = 0;
++
++  text_sec_frag_cnt = 0;
++  rodata_sec_frag_cnt = 0;
++  data_sec_frag_cnt = 0;
++  datarel_sec_frag_cnt = 0;
++  init_sec_frag_cnt = 0;
++
++  bbinfo_text_sec = NULL;
++  bbinfo_rodata_sec = NULL;
++  bbinfo_data_sec = NULL;
++  bbinfo_init_sec = NULL;
++  bbinfo_datarel_sec = NULL;
++}
++
++// update the last_symbol global variable
++// exclude dedug defined label
++int update_last_symbol(symbolS *sym){
++  unsigned int size = sizeof(symbol_blacklist) / sizeof(char*);
++  const char* symbol_name = S_GET_NAME(sym);
++
++  if (!strcmp(symbol_name, "")){
++    as_warn (_("[bbInfo]: the symbol name is null"));
++    return -1;
++  }
++// check if the symbol_name is in black list
++  for (unsigned int i = 0; i < size; i++){
++    if(strstr(symbol_name, symbol_blacklist[i]))
++      return -1;
++  } 
++  last_symbol = sym;
++  return 0;
++}
++
++#ifdef BBINFO_DEBUG_MSG
++void save_to_tmp_directory(const char* file){
++  if (!file)
++    return;
++  char* tmp_file = "/tmp/bbinfo/";
++  char buf[100];
++  strcpy(buf, tmp_file);
++  srand(time(0));
++  unsigned rand_num = rand();
++  sprintf(buf, "cp %s /tmp/bbinfo/case_%x.s", file, rand_num);
++
++  as_warn(_("Execute %s"), buf);
++  system(buf);
++}
++#endif
++
++// generate shuffleInfo into protobuf
++void bbinfo_update_shuffle_info(void){
++ShuffleInfo__ReorderInfo reorder_info = SHUFFLE_INFO__REORDER_INFO__INIT;
++ShuffleInfo__ReorderInfo__BinaryInfo binary_info = 
++  SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;
++
++binary_info.has_rand_obj_offset = 1;
++binary_info.rand_obj_offset = 0; // should be update at linking time
++binary_info.has_main_addr_offset = 1;
++binary_info.main_addr_offset = 0; // should be update at linking time
++
++// 0 is ordinary c/c++ file. 
++// 1 is a source file contains inline assembly
++// 2 is standalone assembly file
++// TODO(binpang). Identify assemble file and inline 
++binary_info.has_src_type = 1;
++binary_info.src_type = 0;
++
++reorder_info.bin = &binary_info;
++
++unsigned bb_cnt = 0;
++unsigned text_fixp_cnt = 0;
++unsigned rodata_fixp_cnt = 0;
++unsigned data_fixp_cnt = 0;
++unsigned datarel_fixp_cnt = 0;
++unsigned init_fixp_cnt = 0;
++
++bbinfo_mbb* last_mbb = NULL;
++// count the basic block number
++for(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;
++    cur_mbb = cur_mbb->next){
++  if (!cur_mbb->sec){
++    continue;
++  }
++  //debug
++  if (last_mbb)
++    if (last_mbb->size + last_mbb->offset != cur_mbb->offset && last_mbb->sec == cur_mbb->sec){
++    as_warn(_("bb#%d, from %x to %x. last_mbb %d, its section is %s, last_mbb from %x to %x, last basic block added size %d\n"), 
++	bb_cnt, cur_mbb->offset, cur_mbb->offset + cur_mbb->size-1, (last_mbb->parent_frag->last_bb == last_mbb), cur_mbb->sec->name, last_mbb->offset, last_mbb->size+last_mbb->offset-1, last_mbb->parent_frag->last_bb_added_size);
++    
++#ifdef BBINFO_DEBUG_MSG
++    if (bbinfo_file_name){
++      save_to_tmp_directory (bbinfo_file_name);
++      bbinfo_file_name = NULL;
++    }
++#endif
++    }
++
++  bb_cnt++;
++  last_mbb = cur_mbb;
++}
++
++
++// count the fixp number
++for(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;
++    cur_fixp = cur_fixp->next){
++
++  // Bug here. The fixup does not have its parent section
++  if (!cur_fixp->sec){
++    as_warn(_("Bug here. The fixup does not have its parent section\n"));
++
++#ifdef BBINFO_DEBUG_MSG
++    if (bbinfo_file_name){
++      save_to_tmp_directory(bbinfo_file_name);
++      bbinfo_file_name = NULL;
++    }
++#endif
++    continue;
++  }
++
++  if (bbinfo_is_new_sec_frag(cur_fixp->sec) == 1)
++    cur_fixp->is_new_section = 1;
++
++  const char* sec_name =cur_fixp->sec->name;
++  if (strstr(sec_name, ".text"))
++    text_fixp_cnt++;
++  else if(strstr(sec_name, ".rodata"))
++    rodata_fixp_cnt++;
++  else if(strstr(sec_name, ".init_array"))
++    init_fixp_cnt++;
++  else if(strstr(sec_name, ".data.rel.ro"))
++    datarel_fixp_cnt++;
++  else if(strstr(sec_name, ".data"))
++    data_fixp_cnt++;
++}
++
++ShuffleInfo__ReorderInfo__LayoutInfo **layout;
++layout = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo *) * bb_cnt);
++unsigned index = 0;
++unsigned obj_size = 0;
++asection* last_sec = NULL;
++
++#ifdef BBINFO_DEBUG_MSG
++unsigned bb_fix_num = 0;
++#endif
++
++for(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;
++    cur_mbb = cur_mbb->next){
++
++  // Bug here. The basic block does not have its parent section
++  if (!cur_mbb->sec){
++    as_warn(_("The basic block[%d] does not have its parent section, its size is %d"), cur_mbb->ID, cur_mbb->size);
++
++// debug, save the failed asm file into /tmp/bbinfo/ directory
++#ifdef BBINFO_DEBUG_MSG
++    if (bbinfo_file_name && cur_mbb->size){
++      save_to_tmp_directory(bbinfo_file_name);
++      bbinfo_file_name = NULL;
++    }
++#endif
++    continue;
++  }
++
++#ifdef BBINFO_DEBUG_MSG
++  bb_fix_num += cur_mbb->num_fixs;
++#endif
++
++  layout[index] = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo));
++
++  shuffle_info__reorder_info__layout_info__init(layout[index]);
++  layout[index]->has_type = 1;
++  layout[index]->type = cur_mbb->type;
++  layout[index]->has_bb_size = 1;
++  layout[index]->bb_size = cur_mbb->size;
++  layout[index]->has_bb_fallthrough = 1;
++  layout[index]->bb_fallthrough = cur_mbb->fall_through;
++  layout[index]->has_num_fixups = 1;
++  layout[index]->num_fixups = cur_mbb->num_fixs;
++  layout[index]->section_name = (char*)cur_mbb->sec->name;
++  layout[index]->has_padding_size= 1;
++  layout[index]->padding_size = cur_mbb->alignment;
++  unsigned char is_last_bb = 0;
++  if (index == bb_cnt - 1){
++    if (layout[index]->type == 1)
++      layout[index]->type = 3; // 3 represents that it is both function and object end
++    else
++      layout[index]->type = 2;
++  }
++  // the last basic block is tail of last section.
++  else if (last_sec && last_sec != cur_mbb->sec){
++    if (layout[index-1]->type == 1)
++      layout[index-1]->type = 3;
++    else
++      layout[index-1]->type = 2;
++  }
++  layout[index]->has_offset = 1;
++  layout[index]->offset = cur_mbb->offset;
++
++#ifdef BBINFO_DEBUG_MSG
++  printf("[bbinfo]: bb%d - offset 0x%x, size 0x%x, alignment is %d, type %d, sec %s\n", 
++		  index, cur_mbb->offset, cur_mbb->size, cur_mbb->alignment, cur_mbb->type, cur_mbb->sec->name);
++#endif
++
++  index++;
++  
++  obj_size += cur_mbb->size;
++  last_sec = cur_mbb->sec;
++}
++
++#ifdef BBINFO_DEBUG_MSG
++if (bb_fix_num != text_fixp_cnt){
++  as_warn(_("basic block's fixup number[%d] does not equal to total fixups number[%d]"), bb_fix_num, text_fixp_cnt);
++if (bbinfo_file_name){
++    save_to_tmp_directory(bbinfo_file_name);
++    bbinfo_file_name = NULL;
++  }
++}
++#endif
++
++binary_info.has_obj_sz = 1;
++binary_info.obj_sz = obj_size;
++
++// update layout_info
++reorder_info.n_layout = index;
++reorder_info.layout = layout;
++
++ShuffleInfo__ReorderInfo__FixupInfo **fixup;
++fixup = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo *) * 1);
++fixup[0] = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo));
++shuffle_info__reorder_info__fixup_info__init(fixup[0]);
++
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text_fixp = NULL;
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata_fixp = NULL;
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data_fixp = NULL;
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel_fixp = NULL;
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **init_fixp = NULL;
++
++if (text_fixp_cnt)
++  text_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) * 
++    								text_fixp_cnt);
++if (rodata_fixp_cnt)
++  rodata_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
++    								rodata_fixp_cnt);
++if (data_fixp_cnt)
++  data_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
++      								data_fixp_cnt);
++if (init_fixp_cnt)
++  init_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
++      								init_fixp_cnt);
++if (datarel_fixp_cnt)
++  datarel_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
++      								datarel_fixp_cnt);
++unsigned cur_text_index = 0;
++unsigned cur_rodata_index = 0;
++unsigned cur_data_index = 0;
++unsigned cur_datarel_index = 0;
++unsigned cur_init_index = 0;
++
++for (bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;
++    					cur_fixp = cur_fixp->next){
++  if (!cur_fixp->sec)
++    continue;
++
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *cur_fixp_tuple =
++    		malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple));
++  shuffle_info__reorder_info__fixup_info__fixup_tuple__init(cur_fixp_tuple); 
++  cur_fixp_tuple->offset = cur_fixp->offset;
++  cur_fixp_tuple->deref_sz = cur_fixp->size;
++  cur_fixp_tuple->is_rela = cur_fixp->is_rela;
++  cur_fixp_tuple->section_name = (char*) cur_fixp->sec->name;
++  // jump table information
++  if (cur_fixp->table_size){
++    cur_fixp_tuple->has_num_jt_entries = 1;
++    cur_fixp_tuple->num_jt_entries = cur_fixp->table_size;
++    cur_fixp_tuple->has_jt_entry_sz = 1;
++    cur_fixp_tuple->jt_entry_sz = cur_fixp->entry_size;
++  }
++
++  cur_fixp_tuple->has_type = 1;
++  if (cur_fixp->is_new_section){
++    cur_fixp_tuple->type = 4; // let linker know if there are multiple .text sections
++  }else{
++    cur_fixp_tuple->type = 0; // c2c, c2d, d2c, d2d default=0; should be updated by linker
++  }
++
++  int discard_cnt = 0;
++  const char* sec_name =cur_fixp->sec->name;
++  if (strstr(sec_name, ".text"))
++    text_fixp[cur_text_index++] = cur_fixp_tuple;  
++  else if(strstr(sec_name, ".rodata"))
++    rodata_fixp[cur_rodata_index++] = cur_fixp_tuple;
++  else if(strstr(sec_name, ".init_array"))
++    init_fixp[cur_init_index++] = cur_fixp_tuple;
++  else if(strstr(sec_name, ".data.rel.ro"))
++    datarel_fixp[cur_datarel_index++] = cur_fixp_tuple;
++  else if(strstr(sec_name, ".data"))
++    data_fixp[cur_data_index++] = cur_fixp_tuple;
++}
++
++// store the fixup information into protobuf
++fixup[0]->n_text = text_fixp_cnt;
++fixup[0]->text = text_fixp;
++fixup[0]->n_rodata = rodata_fixp_cnt;
++fixup[0]->rodata = rodata_fixp;
++fixup[0]->n_data = data_fixp_cnt;
++fixup[0]->data = data_fixp;
++fixup[0]->n_datarel = datarel_fixp_cnt;
++fixup[0]->datarel = datarel_fixp;
++fixup[0]->n_initarray = init_fixp_cnt;
++fixup[0]->initarray = init_fixp;
++
++reorder_info.n_fixup = 1;
++reorder_info.fixup = fixup;
++
++bbinfo_shuffle_info_buf_len = protobuf_c_message_get_packed_size(&reorder_info); // get protobuf bytes length
++
++bbinfo_shuffle_info_buf = malloc(bbinfo_shuffle_info_buf_len);
++protobuf_c_message_pack(&reorder_info, bbinfo_shuffle_info_buf); // Pack reorder_info into buf
++
++// free the malloced space
++
++// free layouts
++for(index = 0; index < bb_cnt; index++){
++  free(layout[index]);
++}
++free(layout);
++
++// free fixups
++for (index = 0; index < text_fixp_cnt; index++){
++  free (text_fixp[index]);
++}
++for (index = 0; index < data_fixp_cnt; index++){
++  free (data_fixp[index]);
++}
++for (index = 0; index < rodata_fixp_cnt; index++){
++  free (rodata_fixp[index]);
++}
++for (index = 0; index < init_fixp_cnt; index++){
++  free (init_fixp[index]);
++}
++for (index = 0; index < datarel_fixp_cnt; index++){
++  free (datarel_fixp[index]);
++}
++if (text_fixp_cnt)
++ free (text_fixp); 
++if (rodata_fixp_cnt)
++ free (rodata_fixp);
++if (data_fixp_cnt)
++ free (data_fixp);
++if (init_fixp_cnt)
++ free (init_fixp);
++if (datarel_fixp_cnt)
++ free (datarel_fixp); 
++}
++#ifdef BBINFO_DEBUG_MSG
++// debug function
++int count_fixup_list_num(){
++  bbinfo_fixup* fixp;
++  int cnt = 0;
++  for (fixp = fixups_list_head; fixp; fixp = fixp->next, cnt++);
++  return cnt;
++}
++#endif
++
++// init the fixup struct and insert it into fixups_list serially
++bbinfo_fixup* bbinfo_init_insert_fixup(asection* sec, int offset){
++
++  bbinfo_fixup* result_fixup = malloc(sizeof(bbinfo_fixup));
++  // init
++  memset (result_fixup, 0, sizeof(bbinfo_fixup));
++  
++
++  if (fixups_list_head == NULL){
++    fixups_list_head = result_fixup;
++    return result_fixup;
++  }
++ 
++  bbinfo_fixup* prev = NULL;
++  bbinfo_fixup* cur = fixups_list_head;
++  // find the section that is equal to sec
++  while(cur && cur->sec != sec){
++    prev = cur;
++    cur = cur->next;
++  }
++
++  // The list does not have section sec
++  if (!cur){
++    prev->next = result_fixup;
++    return result_fixup;
++  }
++
++  // find the proper place accourding to its offset
++  while(cur && offset > cur->offset && cur->sec == sec){
++    prev = cur;
++    cur = cur->next;
++  }
++
++  // insert into the head
++  if (!prev){
++    result_fixup->next = fixups_list_head;
++    fixups_list_head = result_fixup;
++    return result_fixup;
++  }
++  prev->next = result_fixup;
++  result_fixup->next = cur;
++  return result_fixup;
++}
++
++/*
++// init the fixup struct
++bbinfo_fixup* bbinfo_init_fixup(void){
++  bbinfo_fixup *result_fixup = malloc(sizeof(bbinfo_fixup));
++  // init
++  memset(result_fixup, 0, sizeof(bbinfo_fixup)); 
++
++  // put it into the global fixups list
++  if (fixups_list_head == NULL){
++    fixups_list_head = result_fixup;
++  }else{
++    fixups_list_tail->next = result_fixup;
++  }
++  fixups_list_tail = result_fixup;
++  return result_fixup;
++}*/
++
++// check if this is the new section
++// TODO(binpang). Add it into a part of function bbinfo_is_new_sec
++char bbinfo_is_new_sec_frag(asection *sec){
++  // TODO. add new sections, such as .ctors, .fini_array, .dtors, .eh_frame ....
++  if (!sec){
++    as_warn(_("[bbinfo]: in function bbinfo_is_new_sec. The section is NULL"));
++    return -1;
++  }
++  const char* sec_name = sec->name;
++  char* tmp_pointer = NULL;
++  char returned_value = -1;
++  if ((tmp_pointer = strstr(sec_name, ".text")) &&
++      tmp_pointer == sec_name){
++
++    if (!text_sec_frag_cnt){
++      text_sec_frag_cnt++;
++      bbinfo_text_sec = sec;
++      returned_value = 0;
++    }
++    else{
++      returned_value = (bbinfo_text_sec == sec) ? 0 : 1;
++      if(returned_value) text_sec_frag_cnt++;
++      bbinfo_text_sec = sec;
++    }
++    return returned_value;
++  }
++
++  if ((tmp_pointer = strstr(sec_name, ".rodata")) && 
++	tmp_pointer == sec_name){
++
++    if (!rodata_sec_frag_cnt){
++      rodata_sec_frag_cnt++;
++      bbinfo_rodata_sec = sec;
++      returned_value = 0;
++    }else{
++      returned_value = (bbinfo_rodata_sec == sec) ? 0 : 1;
++      if (returned_value) rodata_sec_frag_cnt++;
++      bbinfo_rodata_sec = sec;
++    }
++    return returned_value;
++   }
++
++  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&
++      tmp_pointer == sec_name){
++    
++    if (!init_sec_frag_cnt){
++      init_sec_frag_cnt++;
++      bbinfo_init_sec = sec;
++      returned_value = 0;
++    } else {
++      returned_value = (bbinfo_init_sec == sec) ? 0 : 1;
++      if (returned_value) init_sec_frag_cnt++;
++      bbinfo_init_sec = sec;
++    }
++    return returned_value;
++  }
++
++  if ((tmp_pointer = strstr(sec_name, ".data")) &&
++      tmp_pointer == sec_name){
++
++    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&
++	tmp_pointer == sec_name){
++
++      if (!datarel_sec_frag_cnt){
++	datarel_sec_frag_cnt++;
++	bbinfo_datarel_sec = sec;
++	returned_value = 0;
++      } else {
++	returned_value = (bbinfo_datarel_sec == sec) ? 0 : 1;
++	if (returned_value) datarel_sec_frag_cnt++;
++	bbinfo_datarel_sec = sec;
++      }
++      return returned_value;
++    }
++
++    if (!data_sec_frag_cnt){
++      data_sec_frag_cnt++;
++      bbinfo_data_sec = sec;
++      returned_value = 0;
++    } else {
++      returned_value = (bbinfo_data_sec == sec) ? 0 : 1;
++      if (returned_value) data_sec_frag_cnt++;
++      bbinfo_data_sec = sec;
++    }
++
++    return returned_value;
++  }
++  return -1;
++}
++
++// if this section is the collected section
++// .text, .data.xxx, .rodata.xxxx, .init.xxx, .data.rel
++char bbinfo_is_collect_sec(asection *sec){
++  if (!sec){
++    as_warn(_("[bbinfo]: in function bbinfo_is_new_sec. The section is NULL"));
++    return -1;
++  }
++  const char* sec_name = sec->name;
++  char* tmp_pointer = NULL;
++  if ((tmp_pointer = strstr(sec_name, ".text")) &&
++      tmp_pointer == sec_name){
++      return 1;
++  }
++
++  if ((tmp_pointer = strstr(sec_name, ".rodata")) && 
++	tmp_pointer == sec_name){
++	return 1;
++      }
++
++  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&
++      tmp_pointer == sec_name){
++      return 1;
++  }
++
++  if ((tmp_pointer = strstr(sec_name, ".data")) &&
++      tmp_pointer == sec_name){
++
++    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&
++	tmp_pointer == sec_name){
++	return 1;
++    }
++      return 1;
++  }
++  as_warn("discard fixup in section %s", sec_name);
++  return 0;
++}
++
++// init the bbinfo struct
++bbinfo_mbb* init_basic_block(){
++  // malloc space
++  bbinfo_mbb *result_mbb = malloc(sizeof(bbinfo_mbb));
++  memset(result_mbb, 0, sizeof(bbinfo_mbb));
++  result_mbb->next = NULL;
++
++  // put it into the global basic blocks list
++  if (mbbs_list_head == NULL){
++    mbbs_list_head = result_mbb;
++  }else{
++    mbbs_list_tail->next = result_mbb;
++  } 
++  mbbs_list_tail = result_mbb;
++  return result_mbb;
++}
++
++// handle bbinfo_jmptbl directive
++void jmptable_bbInfo_handler(int ignored ATTRIBUTE_UNUSED){
++    offsetT table_size, entry_size;
++    table_size = get_absolute_expression();
++    SKIP_WHITESPACE();
++    entry_size = get_absolute_expression();
++    if (last_symbol == NULL){
++	printf("Sorry, the last symbol is null\n");
++	return;
++    }
++    // update the jump table related information of the symbol
++    S_SET_JMPTBL_SIZE(last_symbol, table_size);
++    S_SET_JMPTBL_ENTRY_SZ(last_symbol, entry_size);
++    // debug
++    printf("last_symbol is %s\n", S_GET_NAME(last_symbol));
++}
++
++// handle bbinfo_funcb directive, it represents function begin
++void funcb_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
++    prev_function_id = cur_function_id;
++    cur_function_id++;
++    function_head = 1;
++}
++
++// handle bbinfo_funce directive, it represents function end
++void funce_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
++   cur_function_end_id++;
++   if (!mbbs_list_tail){
++     as_fatal("[bbinfo]: funce_bbinfo_handler. the mbbs_list_tail is null");
++     exit(-1);
++   }
++   mbbs_list_tail->type = 1;
++   if (cur_function_end_id != cur_function_id)
++     as_warn(_("[bbInfo]: current function end id don not match current function id")); 
++}
++
++// handle bbinfo_bb directive, it represents basic block begin
++void bb_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
++    bbinfo_mbb *cur_mbb = init_basic_block();
++
++    // init the basic_block element
++    cur_mbb->ID = cur_block_id++;
++    cur_mbb->type = 0;
++    cur_mbb->offset = -1;
++    cur_mbb->size = 0;
++    cur_mbb->alignment = 0;
++    cur_mbb->num_fixs = 0;
++    cur_mbb->fall_through = 0;
++    cur_mbb->sec = NULL;
++    cur_mbb->parent_id = cur_function_id;
++    cur_mbb->is_begin = 1;
++
++    //if (function_head){
++    //  cur_mbb->type = 1; // this basic block is the first block of a function
++    //  function_head = 0;
++   // }
++
++}
++
++// handle bbinfo_be directive, it represents basic block end
++void be_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
++    offsetT fall_through;
++    fall_through = get_absolute_expression();
++    if (fall_through == 1)
++      mbbs_list_tail->fall_through = 1;
++}
+diff --git a/bbInfoHandle.h b/bbInfoHandle.h
+new file mode 100644
+index 0000000..bd655e6
+--- /dev/null
++++ b/bbInfoHandle.h
+@@ -0,0 +1,96 @@
++/* bbInfoHandle.h
++ *
++ * Handle basic block related directives
++ */
++
++#ifndef BBINFOHANDLE_H
++#define BBINFOHANDLE_H
++
++#define BBINFO_DEBUG_MSG
++
++#include "as.h"
++#include "shuffleInfo.pb-c.h"
++#include <stdint.h>
++
++extern const pseudo_typeS bbInfo_pseudo_table[];
++extern int update_last_symbol(symbolS*);
++extern void init_bbinfo_global(void);
++extern void bbinfo_init(void);
++extern char bbinfo_is_collect_sec(asection*);
++extern char bbinfo_is_new_sec_frag(asection*);
++
++#ifdef BBINFO_DEBUG_MSG
++extern char *bbinfo_file_name;
++#endif
++
++
++
++// basic block related information
++struct basic_block{
++  uint32_t ID; // basic block id, every basic block has unique id in an object
++  uint8_t type; // basic block type: basic block or function boundary.
++ 		// 0 represents basic block. 1 represents function start. 2 represents object end
++  uint32_t offset; // offset from the section
++  int size; // basic block size, include alignment size
++  uint32_t alignment; // basic block alignment size
++  uint32_t num_fixs; // number fixups
++  unsigned char fall_through; // whether the basic block is fall through
++  asection *sec; // which section the basic block belongs to
++  struct basic_block *next; // link next basic blosk
++  uint32_t parent_id; // function id
++  uint8_t is_begin; // if current instruction is the first instruction of this basic block
++  fragS *parent_frag; // this basic block belongs to which frag.
++  		      // FIXME. I'm not sure if there exists a basic block cross two fragS.
++};
++
++typedef struct basic_block bbinfo_mbb;
++
++
++// fixup information
++typedef struct fixup{
++  uint32_t offset; // offset from section
++  asection *sec; // which section the basic block belongs to
++  unsigned char is_new_section; // if its parent section is the new section that has the same name
++  unsigned char is_rela; // if this fixup is relative
++  uint32_t size; // the reference's size
++  uint32_t table_size; // for jump table reference only
++  uint32_t entry_size; // for jump table reference only
++  struct fixup *next; // link next fixup
++} bbinfo_fixup;
++
++extern bbinfo_fixup* fixups_list_head; // fixup list
++extern bbinfo_fixup* fixups_list_tail; // last element of fixups list
++extern bbinfo_mbb* mbbs_list_head; // basic blocks list
++extern bbinfo_mbb* mbbs_list_tail; // the last element of basic blocks list
++extern uint32_t cur_function_id; // current function id
++extern uint32_t prev_function_id; // prev function id
++extern uint32_t cur_function_end_id; // current function end id
++extern symbolS *last_symbol; // last user defined symbol
++extern uint32_t cur_block_id; // global current basic block id
++// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number
++extern unsigned text_sec_cnt;
++extern unsigned rodata_sec_cnt;
++extern unsigned data_sec_cnt;
++extern unsigned datarel_sec_cnt;
++extern unsigned init_sec_cnt;
++
++extern unsigned text_sec_frag_cnt;
++extern unsigned rodata_sec_frag_cnt;
++extern unsigned data_sec_frag_cnt;
++extern unsigned datarel_sec_frag_cnt;
++extern unsigned init_sec_frag_cnt;
++
++extern asection *bbinfo_text_sec;
++extern asection *bbinfo_rodata_sec;
++extern asection *bbinfo_data_sec;
++extern asection *bbinfo_init_sec;
++extern asection *bbinfo_datarel_sec;
++
++// shuffleInfo that CCR defines
++extern char* bbinfo_shuffle_info_buf; 
++extern unsigned bbinfo_shuffle_info_buf_len;
++
++extern bbinfo_fixup* bbinfo_init_fixup(void);
++extern bbinfo_fixup* bbinfo_init_insert_fixup(asection*, int);
++extern void bbinfo_update_shuffle_info(void);
++#endif
+diff --git a/config/tc-i386.c b/config/tc-i386.c
+index 5cd83da..21c4458 100644
+--- a/config/tc-i386.c
++++ b/config/tc-i386.c
+@@ -33,6 +33,8 @@
+ #include "elf/x86-64.h"
+ #include "opcodes/i386-init.h"
+ 
++#include "bbInfoHandle.h" //binpang add
++
+ #ifndef REGISTER_WARNINGS
+ #define REGISTER_WARNINGS 1
+ #endif
+@@ -392,6 +394,7 @@ struct _i386_insn
+ 
+     /* Error message.  */
+     enum i386_error error;
++
+   };
+ 
+ typedef struct _i386_insn i386_insn;
+@@ -4618,6 +4621,12 @@ optimize_disp (void)
+ 	    i.types[op].bitfield.disp32 = 0;
+ 	    i.types[op].bitfield.disp32s = 0;
+ 	    i.types[op].bitfield.disp64 = 0;
++	    // binpang, add
++	    // update the basic block's fix number
++#if defined(__i386__) || defined(__x86_64__)
++	    if (mbbs_list_tail)
++	      mbbs_list_tail->num_fixs++;
++#endif
+ 	  }
+  	else
+ 	  /* We only support 64bit displacement on constants.  */
+@@ -6933,6 +6942,7 @@ build_modrm_byte (void)
+ static void
+ output_branch (void)
+ {
++
+   char *p;
+   int size;
+   int code16;
+@@ -7091,6 +7101,12 @@ output_jump (void)
+   fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+ 		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
+ 
++  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++  if (mbbs_list_tail)
++    mbbs_list_tail->num_fixs++;
++#endif
++
+   /* All jumps handled here are signed, but don't use a signed limit
+      check for 32 and 16 bit jumps as we want to allow wrap around at
+      4G and 64k respectively.  */
+@@ -7153,9 +7169,15 @@ output_interseg_jump (void)
+ 	}
+       md_number_to_chars (p, n, size);
+     }
+-  else
++  else{
+     fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+ 		 i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
++    // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++    if (mbbs_list_tail)
++      mbbs_list_tail->num_fixs++;
++#endif
++  }
+   if (i.op[0].imms->X_op != O_constant)
+     as_bad (_("can't handle non absolute segment in `%s'"),
+ 	    i.tm.name);
+@@ -7176,6 +7198,17 @@ output_insn (void)
+   insn_start_frag = frag_now;
+   insn_start_off = frag_now_fix ();
+ 
++
++#if defined(__i386__) || defined(__x86_64)
++  // update the basic block offset in current/last fragment
++  insn_start_frag->last_bb = mbbs_list_tail;
++  if (mbbs_list_tail && mbbs_list_tail->is_begin){
++    mbbs_list_tail->is_begin = 0;
++    mbbs_list_tail->offset = insn_start_off;
++    mbbs_list_tail->parent_frag = insn_start_frag;
++  }
++#endif
++
+   /* Output jumps.  */
+   if (i.tm.opcode_modifier.jump)
+     output_branch ();
+@@ -7205,6 +7238,32 @@ output_insn (void)
+           offsetT val = 0x240483f0ULL;
+           p = frag_more (5);
+           md_number_to_chars (p, val, 5);
++
++// binpang add
++// get the last instruction size
++// the last basic block's size in fragment may change after fragment relocation 
++#if defined(__i386__) || defined(__x86_64__)
++  offsetT insn_size = 0;
++  if (insn_start_frag == frag_now){
++    insn_size = frag_now_fix() - insn_start_off; 
++  }else{
++    // last basic block in fragment may change in the frag relocation
++    // update its size after fragment relocation
++    insn_size = insn_start_frag->fr_fix - insn_start_off;
++    fragS *frag_tmp;
++    for (frag_tmp = insn_start_frag->fr_next; 
++	frag_tmp && frag_tmp != frag_now; frag_tmp = frag_tmp->fr_next){
++      insn_size += frag_tmp->fr_fix;
++      frag_tmp->last_bb = mbbs_list_tail;
++    }
++    insn_size += frag_now_fix();
++    frag_now->last_bb = mbbs_list_tail;
++  }
++
++  // update the basic block size
++  if (mbbs_list_tail)
++    mbbs_list_tail->size += (unsigned int)insn_size;
++#endif
+           return;
+         }
+ 
+@@ -7366,6 +7425,34 @@ check_prefix:
+       pi ("" /*line*/, &i);
+     }
+ #endif /* DEBUG386  */
++
++// binpang add
++// get the last instruction size
++// the last basic block's size in fragment may change after fragment relocation 
++#if defined(__i386__) || defined(__x86_64__)
++  offsetT insn_size = 0;
++  if (insn_start_frag == frag_now){
++    insn_size = frag_now_fix() - insn_start_off; 
++  }else{
++    // last basic block in fragment may change in the frag relocation
++    // update its size after fragment relocation
++    insn_size = insn_start_frag->fr_fix - insn_start_off;
++    fragS *frag_tmp;
++    for (frag_tmp = insn_start_frag->fr_next; 
++	frag_tmp && frag_tmp != frag_now; frag_tmp = frag_tmp->fr_next){
++      insn_size += frag_tmp->fr_fix;
++      frag_tmp->last_bb = mbbs_list_tail;
++    }
++    insn_size += frag_now_fix();
++    frag_now->last_bb = mbbs_list_tail;
++  }
++
++  // update the basic block size
++  if (mbbs_list_tail)
++    mbbs_list_tail->size += (unsigned int)insn_size;
++#endif
++  
++  
+ }
+ 
+ /* Return the size of the displacement operand N.  */
+@@ -7496,6 +7583,14 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)
+ 	      fixP = fix_new_exp (frag_now, p - frag_now->fr_literal,
+ 				  size, i.op[n].disps, pcrel,
+ 				  reloc_type);
++	      // binpang, add
++	      // update the basic block's fix number
++#if defined(__i386__) || defined(__x86_64__)
++	     if (mbbs_list_tail){
++	       mbbs_list_tail->num_fixs++;
++	     } 
++#endif
++
+ 	      /* Check for "call/jmp *mem", "mov mem, %reg",
+ 		 "test %reg, mem" and "binop mem, %reg" where binop
+ 		 is one of adc, add, and, cmp, or, sbb, sub, xor
+@@ -7653,6 +7748,13 @@ output_imm (fragS *insn_start_frag, offsetT insn_start_off)
+ 		}
+ 	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+ 			   i.op[n].imms, 0, reloc_type);
++	      // binpang, add
++	      // update the basic blocks fix number
++#if defined(__i386__) || defined(__x86_64__)
++	      if (mbbs_list_tail)
++		mbbs_list_tail->num_fixs++;
++#endif
++
+ 	    }
+ 	}
+     }
+@@ -9319,10 +9421,20 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 	  /* Make jmp (0xeb) a (d)word displacement jump.  */
+ 	  opcode[0] = 0xe9;
+ 	  fragP->fr_fix += size;
++
+ 	  fix_new (fragP, old_fr_fix, size,
+ 		   fragP->fr_symbol,
+ 		   fragP->fr_offset, 1,
+ 		   reloc_type);
++
++	  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	  if (fragP->last_bb)
++	    fragP->last_bb->num_fixs++;
++
++	  // update the added fix size
++	  fragP->last_bb_added_fix_size += size;
++#endif
+ 	  break;
+ 
+ 	case COND_JUMP86:
+@@ -9342,6 +9454,15 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 		       fragP->fr_symbol,
+ 		       fragP->fr_offset, 1,
+ 		       reloc_type);
++
++	  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	  if (fragP->last_bb)
++	    fragP->last_bb->num_fixs++;
++
++	  // update the added fix size
++	  fragP->last_bb_added_fix_size += 2 + 2;
++#endif
+ 	      break;
+ 	    }
+ 	  /* Fall through.  */
+@@ -9357,6 +9478,14 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 			      fragP->fr_offset, 1,
+ 			      BFD_RELOC_8_PCREL);
+ 	      fixP->fx_signed = 1;
++	  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	  if (fragP->last_bb)
++	    fragP->last_bb->num_fixs++;
++
++	  // update the added fix size
++	  fragP->last_bb_added_fix_size += 1;
++#endif
+ 	      break;
+ 	    }
+ 
+@@ -9370,6 +9499,14 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 		   fragP->fr_symbol,
+ 		   fragP->fr_offset, 1,
+ 		   reloc_type);
++	  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	  if (fragP->last_bb)
++	    fragP->last_bb->num_fixs++;
++
++	  // update the added fix size
++	  fragP->last_bb_added_fix_size += 1 + size;
++#endif
+ 	  break;
+ 
+ 	default:
+@@ -9399,9 +9536,13 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 	Caller will turn frag into a ".space 0".  */
+ 
+ void
+-md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
++md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec,
+                  fragS *fragP)
+ {
++  // binpang, add
++  // record added opcodes size
++  unsigned add_opcodes = 0;
++
+   unsigned char *opcode;
+   unsigned char *where_to_put_displacement = NULL;
+   offsetT target_address;
+@@ -9450,6 +9591,9 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
+ 	case ENCODE_RELAX_STATE (COND_JUMP, BIG):
+ 	case ENCODE_RELAX_STATE (COND_JUMP86, BIG):
+ 	  extension = 5;		/* 2 opcode + 4 displacement  */
++	  // binpang, add
++	  add_opcodes = 1;
++
+ 	  opcode[1] = opcode[0] + 0x10;
+ 	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
+ 	  where_to_put_displacement = &opcode[2];
+@@ -9457,6 +9601,9 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
+ 
+ 	case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
+ 	  extension = 3;		/* 2 opcode + 2 displacement  */
++	  // binpang, add
++	  add_opcodes = 1;
++
+ 	  opcode[1] = opcode[0] + 0x10;
+ 	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
+ 	  where_to_put_displacement = &opcode[2];
+@@ -9494,6 +9641,24 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
+   md_number_to_chars ((char *) where_to_put_displacement,
+ 		      (valueT) (displacement_from_opcode_start - extension),
+ 		      DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
++  
++#if defined(__i386__) || defined(__x86_64__)
++  char is_new_sec = bbinfo_is_collect_sec(sec);
++  if (is_new_sec)
++  {
++    // binpang, add fixup doesn't in fixup list
++    int tmp_offset = fragP->fr_address + fragP->fr_fix + add_opcodes;
++    bbinfo_fixup* tmp_fix = bbinfo_init_insert_fixup(sec, tmp_offset);
++    tmp_fix->sec = sec;
++    tmp_fix->offset = tmp_offset;
++    tmp_fix->is_new_section = 0;
++    tmp_fix->is_rela = 1; // this fixup is always pc-relative
++    tmp_fix->size = extension - add_opcodes;
++    if (fragP->last_bb)
++      fragP->last_bb->num_fixs++;
++  }
++#endif
++
+   fragP->fr_fix += extension;
+ }
+ 
+diff --git a/config/tc-ia64.c b/config/tc-ia64.c
+index 7976624..73ef1e4 100644
+--- a/config/tc-ia64.c
++++ b/config/tc-ia64.c
+@@ -11096,6 +11096,8 @@ ia64_cons_fix_new (fragS *f, int where, int nbytes, expressionS *exp,
+ static bfd_reloc_code_real_type
+ ia64_gen_real_reloc_type (struct symbol *sym, bfd_reloc_code_real_type r_type)
+ {
++
++
+   bfd_reloc_code_real_type newr = 0;
+   const char *type = NULL, *suffix = "";
+ 
+diff --git a/frags.c b/frags.c
+index 170fd97..412f166 100644
+--- a/frags.c
++++ b/frags.c
+@@ -198,6 +198,14 @@ frag_new (size_t old_frags_var_max_size
+   gas_assert (frchain_now->frch_last == frag_now);
+ 
+   frag_now->fr_next = NULL;
++
++#if defined(__i386__) || defined(__x86_64__)
++  // binpang, add
++  // init frag bbInfo related element
++  frag_now->last_bb = NULL;
++  frag_now->bb_offset = 0;
++  frag_now->last_bb_added_size = 0;
++#endif
+ }
+ 
+ /* Start a new frag unless we have n more chars of room in the current frag.
+diff --git a/frags.h b/frags.h
+index 28205c6..312667b 100644
+--- a/frags.h
++++ b/frags.h
+@@ -21,7 +21,9 @@
+ #ifndef FRAGS_H
+ #define FRAGS_H
+ 
++
+ struct obstack;
++struct basic_block;
+ 
+ /* A code fragment (frag) is some known number of chars, followed by some
+    unknown number of chars. Typically the unknown number of chars is an
+@@ -103,6 +105,15 @@ struct frag {
+   OBJ_FRAG_TYPE obj_frag_data;
+ #endif
+ 
++// binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++struct basic_block *last_bb; // last basic block in this fragment
++unsigned int bb_offset; // basic block offset in this fragment
++offsetT last_bb_added_size; // last basic block may be added
++offsetT last_bb_added_fix_size; // fr_fix added number
++asection *parent; // which section it belongs to
++#endif
++
+   /* Data begins here.  */
+   char fr_literal[1];
+ };
+diff --git a/libshuffleInfo.so b/libshuffleInfo.so
+new file mode 100755
+index 0000000..466ec8e
+Binary files /dev/null and b/libshuffleInfo.so differ
+diff --git a/makefile.vms b/makefile.vms
+index e7d88ed..421ce3f 100644
+--- a/makefile.vms
++++ b/makefile.vms
+@@ -43,7 +43,7 @@ OBJS:=targ-cpu.obj,obj-format.obj,atof-targ.obj,app.obj,as.obj,\
+   frags.obj,hash.obj,input-file.obj,\
+   input-scrub.obj,literal.obj,messages.obj,output-file.obj,read.obj,\
+   subsegs.obj,symbols.obj,write.obj,listing.obj,ecoff.obj,stabs.obj,sb.obj,\
+-  macro.obj,ehopt.obj,dw2gencfi.obj,dwarf2dbg.obj,remap.obj
++  macro.obj,ehopt.obj,dw2gencfi.obj,dwarf2dbg.obj,remap.obj,bbInfoHandle.obj
+ 
+ ifeq ($(ARCH),IA64)
+ OBJS:=$(OBJS),te-vms.obj
+diff --git a/read.c b/read.c
+index cf1bdec..66b84f3 100644
+--- a/read.c
++++ b/read.c
+@@ -40,6 +40,10 @@
+ #include "dw2gencfi.h"
+ #include "wchar.h"
+ 
++#if defined(__i386__) || defined(__x86_64__)
++#include "bbInfoHandle.h" // binpang, add
++#endif
++
+ #ifndef TC_START_LABEL
+ #define TC_START_LABEL(STR, NUL_CHAR, NEXT_CHAR) (NEXT_CHAR == ':')
+ #endif
+@@ -534,6 +538,11 @@ pop_insert (const pseudo_typeS *table)
+ #define cfi_pop_insert()	pop_insert(cfi_pseudo_table)
+ #endif
+ 
++// binpang, add. Handle basic block related information
++#if !defined(bbInfo_pop_insert) && (defined(__i386__) || defined (__x86_64__))
++#define bbInfo_pop_insert()    pop_insert(bbInfo_pseudo_table)
++#endif
++
+ static void
+ pobegin (void)
+ {
+@@ -556,8 +565,16 @@ pobegin (void)
+   pop_table_name = "cfi";
+   pop_override_ok = 1;
+   cfi_pop_insert ();
++
++// binpang, add.
++#if defined(__i386__) || defined(__x86_64__)
++  /* Now bbInfo ones. */
++  pop_table_name = "bbInfo";
++  bbInfo_pop_insert();
++#endif
++
+ }
+-
++
+ #define HANDLE_CONDITIONAL_ASSEMBLY(num_read)				\
+   if (ignore_input ())							\
+     {									\
+@@ -818,6 +835,13 @@ read_a_source_file (const char *name)
+   int temp;
+   pseudo_typeS *pop;
+ 
++// binpang, add. debug
++#ifdef BBINFO_DEBUG_MSG
++  bbinfo_file_name = name;
++// emmm, printf the information will get the gold linker LTO crashes...
++  as_warn(_("file name is %s\n"), bbinfo_file_name);
++#endif
++
+ #ifdef WARN_COMMENTS
+   found_comment = 0;
+ #endif
+@@ -845,8 +869,6 @@ read_a_source_file (const char *name)
+       while (input_line_pointer < buffer_limit)
+ 	{
+ 	  
+-          //binpang: debug
+-	  printf("New line %s", input_line_pointer);
+ 	  bfd_boolean was_new_line;
+ 	  /* We have more of this buffer to parse.  */
+ 
+@@ -1018,6 +1040,10 @@ read_a_source_file (const char *name)
+ 		    }
+ 
+ 		  line_label = colon (s);	/* User-defined label.  */
++		  //binpang add, record the last user defined label
++#if defined(__i386__) || defined(__x86_64__)
++		  update_last_symbol(line_label);
++#endif
+ 		  restore_line_pointer (nul_char);
+ 		  ++ input_line_pointer;
+ #ifdef tc_check_label
+@@ -1391,6 +1417,7 @@ read_a_source_file (const char *name)
+ 		     "first comment found here");
+   }
+ #endif
++
+ }
+ 
+ /* Convert O_constant expression EXP into the equivalent O_big representation.
+diff --git "a/set\033:q" "b/set\033:q"
+new file mode 100644
+index 0000000..0941808
+--- /dev/null
++++ "b/set\033:q"
+@@ -0,0 +1,484 @@
++[1mdiff --git a/Makefile.am b/Makefile.am[m
++[1mindex e183855..e882179 100644[m
++[1m--- a/Makefile.am[m
++[1m+++ b/Makefile.am[m
++[36m@@ -71,6 +71,7 @@[m [mGAS_CFILES = \[m
++ 	dwarf2dbg.c \[m
++ 	dw2gencfi.c \[m
++ 	bbInfoHandle.c \[m
++[32m+[m	[32mshuffleInfo.pb-c.c \[m
++ 	ecoff.c \[m
++ 	ehopt.c \[m
++ 	expr.c \[m
++[36m@@ -106,6 +107,7 @@[m [mHFILES = \[m
++ 	dwarf2dbg.h \[m
++ 	dw2gencfi.h \[m
++ 	bbInfoHandle.h \[m
++[32m+[m	[32mshuffleInfo.pb-c.h \[m
++ 	ecoff.h \[m
++ 	emul-target.h \[m
++ 	emul.h \[m
++[1mdiff --git a/Makefile.in b/Makefile.in[m
++[1mindex 161d5ca..57629ff 100644[m
++[1m--- a/Makefile.in[m
++[1m+++ b/Makefile.in[m
++[36m@@ -117,7 +117,9 @@[m [mam__objects_1 = app.$(OBJEXT) as.$(OBJEXT) atof-generic.$(OBJEXT) \[m
++ 	listing.$(OBJEXT) literal.$(OBJEXT) macro.$(OBJEXT) \[m
++ 	messages.$(OBJEXT) output-file.$(OBJEXT) read.$(OBJEXT) \[m
++ 	remap.$(OBJEXT) sb.$(OBJEXT) stabs.$(OBJEXT) subsegs.$(OBJEXT) \[m
++[31m-	symbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) [m
++[32m+[m	[32msymbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) \[m
++[32m+[m	[32mshuffleInfo.pb-c.$(OBJEXT)[m
++[32m+[m[41m	[m
++ am_as_new_OBJECTS = $(am__objects_1)[m
++ as_new_OBJECTS = $(am_as_new_OBJECTS)[m
++ am__DEPENDENCIES_1 =[m
++[36m@@ -368,6 +370,7 @@[m [mGAS_CFILES = \[m
++ 	dwarf2dbg.c \[m
++ 	dw2gencfi.c \[m
++ 	bbInfoHandle.c \[m
++[32m+[m	[32mshuffleInfo.pb-c.c \[m
++ 	ecoff.c \[m
++ 	ehopt.c \[m
++ 	expr.c \[m
++[36m@@ -402,6 +405,7 @@[m [mHFILES = \[m
++ 	dwarf2dbg.h \[m
++ 	dw2gencfi.h \[m
++ 	bbInfoHandle.h \[m
++[32m+[m	[32mshuffleInfo.pb-c.h \[m
++ 	ecoff.h \[m
++ 	emul-target.h \[m
++ 	emul.h \[m
++[1mdiff --git a/bbInfoHandle.c b/bbInfoHandle.c[m
++[1mindex bed65bf..9bd08bb 100644[m
++[1m--- a/bbInfoHandle.c[m
++[1m+++ b/bbInfoHandle.c[m
++[36m@@ -10,6 +10,7 @@[m [mstatic void funcb_bbInfo_handler (int);[m
++ static void funce_bbInfo_handler (int);[m
++ static void bb_bbInfo_handler (int);[m
++ static void be_bbInfo_handler (int);[m
++[32m+[m[32mvoid bbinfo_update_shuffle_info(void);[m
++ bbinfo_mbb* init_basic_block(void);[m
++ bbinfo_fixup* bbinfo_init_fixup(void);[m
++ [m
++[36m@@ -39,6 +40,17 @@[m [msymbolS *last_symbol; // last user defined symbol[m
++ uint32_t cur_block_id; // global current basic block id [m
++ unsigned char function_head; // represent that the current basic block is current function's first entry[m
++ [m
++[32m+[m[32munsigned text_sec_cnt;[m
++[32m+[m[32munsigned rodata_sec_cnt;[m
++[32m+[m[32munsigned data_sec_cnt;[m
++[32m+[m[32munsigned datarel_sec_cnt;[m
++[32m+[m[32munsigned init_sec_cnt;[m
++[32m+[m
++[32m+[m[32m// store the shuffle information[m
++[32m+[m[32mchar* bbinfo_shuffle_info_buf = NULL;[m
++[32m+[m[32munsigned bbinfo_shuffle_info_buf_len = 0;[m
++[32m+[m
++[32m+[m
++ // init the global variables[m
++ void bbinfo_init(){[m
++   fixups_list_head = NULL;[m
++[36m@@ -51,6 +63,11 @@[m [mvoid bbinfo_init(){[m
++   last_symbol = NULL;[m
++   cur_block_id = 0;[m
++   function_head = 0;[m
++[32m+[m[32m  text_sec_cnt = 0;[m
++[32m+[m[32m  data_sec_cnt = 0;[m
++[32m+[m[32m  datarel_sec_cnt = 0;[m
++[32m+[m[32m  rodata_sec_cnt = 0;[m
++[32m+[m[32m  init_sec_cnt = 0;[m
++ }[m
++ [m
++ // update the last_symbol global variable[m
++[36m@@ -72,6 +89,211 @@[m [mint update_last_symbol(symbolS *sym){[m
++   return 0;[m
++ }[m
++ [m
++[32m+[m[32m// generate shuffleInfo into protobuf[m
++[32m+[m[32mvoid bbinfo_update_shuffle_info(void){[m
++[32m+[m[32mShuffleInfo__ReorderInfo reorder_info = SHUFFLE_INFO__REORDER_INFO__INIT;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__BinaryInfo binary_info =[m[41m [m
++[32m+[m[32m  SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;[m
++[32m+[m
++[32m+[m[32mbinary_info.has_rand_obj_offset = 1;[m
++[32m+[m[32mbinary_info.rand_obj_offset = 0; // should be update at linking time[m
++[32m+[m[32mbinary_info.has_main_addr_offset = 1;[m
++[32m+[m[32mbinary_info.main_addr_offset = 0; // should be update at linking time[m
++[32m+[m
++[32m+[m[32m// 0 is ordinary c/c++ file.[m[41m [m
++[32m+[m[32m// 1 is a source file contains inline assembly[m
++[32m+[m[32m// 2 is standalone assembly file[m
++[32m+[m[32m// TODO(binpang). Identify assemble file and inline[m[41m [m
++[32m+[m[32mbinary_info.has_src_type = 1;[m
++[32m+[m[32mbinary_info.src_type = 0;[m
++[32m+[m
++[32m+[m[32mreorder_info.bin = &binary_info;[m
++[32m+[m
++[32m+[m[32munsigned bb_cnt = 0;[m
++[32m+[m[32munsigned text_fixp_cnt = 0;[m
++[32m+[m[32munsigned rodata_fixp_cnt = 0;[m
++[32m+[m[32munsigned data_fixp_cnt = 0;[m
++[32m+[m[32munsigned datarel_fixp_cnt = 0;[m
++[32m+[m[32munsigned init_fixp_cnt = 0;[m
++[32m+[m
++[32m+[m[32m// count the basic block number[m
++[32m+[m[32mfor(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;[m
++[32m+[m[32m    cur_mbb = cur_mbb->next){[m
++[32m+[m[32m  bb_cnt++;[m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m[32m// count the fixp number[m
++[32m+[m[32mfor(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;[m
++[32m+[m[32m    cur_fixp = cur_fixp->next){[m
++[32m+[m[32m  const char* sec_name =cur_fixp->sec->name;[m
++[32m+[m[32m  if (strstr(sec_name, ".text"))[m
++[32m+[m[32m    text_fixp_cnt++;[m
++[32m+[m[32m  else if(strstr(sec_name, ".rodata"))[m
++[32m+[m[32m    rodata_fixp_cnt++;[m
++[32m+[m[32m  else if(strstr(sec_name, ".init_array"))[m
++[32m+[m[32m    init_fixp_cnt++;[m
++[32m+[m[32m  else if(strstr(sec_name, ".data.rel.ro"))[m
++[32m+[m[32m    datarel_fixp_cnt++;[m
++[32m+[m[32m  else if(strstr(sec_name, ".data"))[m
++[32m+[m[32m    data_fixp_cnt++;[m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m[32mShuffleInfo__ReorderInfo__LayoutInfo **layout;[m
++[32m+[m[32mlayout = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo *) * bb_cnt);[m
++[32m+[m[32munsigned index = 0;[m
++[32m+[m[32munsigned obj_size = 0;[m
++[32m+[m[32mfor(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;[m
++[32m+[m[32m    cur_mbb = cur_mbb->next){[m
++[32m+[m[32m  layout[index] = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo));[m
++[32m+[m
++[32m+[m[32m  shuffle_info__reorder_info__layout_info__init(layout[index]);[m
++[32m+[m[32m  layout[index]->has_type = 1;[m
++[32m+[m[32m  layout[index]->type = cur_mbb->type;[m
++[32m+[m[32m  layout[index]->has_bb_size = 1;[m
++[32m+[m[32m  layout[index]->bb_size = cur_mbb->size;[m
++[32m+[m[32m  layout[index]->has_bb_fallthrough = 1;[m
++[32m+[m[32m  layout[index]->bb_fallthrough = cur_mbb->fall_through;[m
++[32m+[m[32m  //TODO, add basic block offset in shuffle.proto[m
++[32m+[m[32m  //TODO, collect num_fixups in gcc toolchain[m
++[32m+[m[32m  layout[index]->section_name = (char*)cur_mbb->sec->name;[m
++[32m+[m[32m  index++;[m
++[32m+[m[41m  [m
++[32m+[m[32m  obj_size += cur_mbb->size;[m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m[32mbinary_info.has_obj_sz;[m
++[32m+[m[32mbinary_info.obj_sz = obj_size;[m
++[32m+[m
++[32m+[m[32m// update layout_info[m
++[32m+[m[32mreorder_info.n_layout = index;[m
++[32m+[m[32mreorder_info.layout = layout;[m
++[32m+[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo **fixup;[m
++[32m+[m[32mfixup = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo *) * 1);[m
++[32m+[m[32mfixup[0] = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo));[m
++[32m+[m[32mshuffle_info__reorder_info__fixup_info__init(fixup[0]);[m
++[32m+[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text_fixp = NULL;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata_fixp = NULL;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data_fixp = NULL;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel_fixp = NULL;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **init_fixp = NULL;[m
++[32m+[m
++[32m+[m[32mif (text_fixp_cnt)[m
++[32m+[m[32m  text_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m[41m [m
++[32m+[m[41m    [m								[32mtext_fixp_cnt);[m
++[32m+[m[32mif (rodata_fixp_cnt)[m
++[32m+[m[32m  rodata_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
++[32m+[m[41m    [m								[32mrodata_fixp_cnt);[m
++[32m+[m[32mif (data_fixp_cnt)[m
++[32m+[m[32m  data_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
++[32m+[m[41m      [m								[32mdata_fixp_cnt);[m
++[32m+[m[32mif (init_fixp_cnt)[m
++[32m+[m[32m  init_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
++[32m+[m[41m      [m								[32minit_fixp_cnt);[m
++[32m+[m[32mif (datarel_fixp_cnt)[m
++[32m+[m[32m  datarel_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
++[32m+[m[41m      [m								[32mdatarel_fixp_cnt);[m
++[32m+[m[32munsigned cur_text_index = 0;[m
++[32m+[m[32munsigned cur_rodata_index = 0;[m
++[32m+[m[32munsigned cur_data_index = 0;[m
++[32m+[m[32munsigned cur_datarel_index = 0;[m
++[32m+[m[32munsigned cur_init_index = 0;[m
++[32m+[m
++[32m+[m[32mfor (bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;[m
++[32m+[m[41m    [m					[32mcur_fixp = cur_fixp->next){[m
++[32m+[m[32m  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *cur_fixp_tuple =[m
++[32m+[m[41m    [m		[32mmalloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple));[m
++[32m+[m[32m  shuffle_info__reorder_info__fixup_info__fixup_tuple__init(cur_fixp_tuple);[m[41m [m
++[32m+[m[32m  cur_fixp_tuple->offset = cur_fixp->offset;[m
++[32m+[m[32m  cur_fixp_tuple->deref_sz = cur_fixp->size;[m
++[32m+[m[32m  cur_fixp_tuple->is_rela = cur_fixp->is_rela;[m
++[32m+[m[32m  cur_fixp_tuple->section_name = (char*) cur_fixp->sec->name;[m
++[32m+[m[32m  // jump table information[m
++[32m+[m[32m  if (cur_fixp->table_size){[m
++[32m+[m[32m    cur_fixp_tuple->has_num_jt_entries = 1;[m
++[32m+[m[32m    cur_fixp_tuple->num_jt_entries = cur_fixp->table_size;[m
++[32m+[m[32m    cur_fixp_tuple->has_jt_entry_sz = 1;[m
++[32m+[m[32m    cur_fixp_tuple->jt_entry_sz = cur_fixp->entry_size;[m
++[32m+[m[32m  }[m
++[32m+[m
++[32m+[m[32m  cur_fixp_tuple->has_type = 1;[m
++[32m+[m[32m  if (cur_fixp->is_new_section){[m
++[32m+[m[32m    cur_fixp_tuple->type = 4; // let linker know if there are multiple .text sections[m
++[32m+[m[32m  }else{[m
++[32m+[m[32m    cur_fixp_tuple->type = 0; // c2c, c2d, d2c, d2d default=0; should be updated by linker[m
++[32m+[m[32m  }[m
++[32m+[m
++[32m+[m[32m  const char* sec_name =cur_fixp->sec->name;[m
++[32m+[m[32m  if (strstr(sec_name, ".text"))[m
++[32m+[m[32m    text_fixp[cur_text_index++] = cur_fixp_tuple;[m[41m  [m
++[32m+[m[32m  else if(strstr(sec_name, ".rodata"))[m
++[32m+[m[32m    rodata_fixp[cur_rodata_index++] = cur_fixp_tuple;[m
++[32m+[m[32m  else if(strstr(sec_name, ".init_array"))[m
++[32m+[m[32m    init_fixp[cur_init_index++] = cur_fixp_tuple;[m
++[32m+[m[32m  else if(strstr(sec_name, ".data.rel.ro"))[m
++[32m+[m[32m    datarel_fixp[cur_datarel_index++] = cur_fixp_tuple;[m
++[32m+[m[32m  else if(strstr(sec_name, ".data"))[m
++[32m+[m[32m    data_fixp[cur_data_index++] = cur_fixp_tuple;[m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m[32m// store the fixup information into protobuf[m
++[32m+[m[32mfixup[0]->n_text = text_fixp_cnt;[m
++[32m+[m[32mfixup[0]->text = text_fixp;[m
++[32m+[m[32mfixup[0]->n_rodata = rodata_fixp_cnt;[m
++[32m+[m[32mfixup[0]->rodata = rodata_fixp;[m
++[32m+[m[32mfixup[0]->n_data = data_fixp_cnt;[m
++[32m+[m[32mfixup[0]->data = data_fixp;[m
++[32m+[m[32mfixup[0]->n_datarel = datarel_fixp_cnt;[m
++[32m+[m[32mfixup[0]->datarel = datarel_fixp;[m
++[32m+[m[32mfixup[0]->n_initarray = init_fixp_cnt;[m
++[32m+[m[32mfixup[0]->initarray = init_fixp;[m
++[32m+[m
++[32m+[m[32mreorder_info.n_fixup = 1;[m
++[32m+[m[32mreorder_info.fixup = fixup;[m
++[32m+[m
++[32m+[m[32mbbinfo_shuffle_info_buf_len = protobuf_c_message_get_packed_size(&reorder_info); // get protobuf bytes length[m
++[32m+[m
++[32m+[m[32mbbinfo_shuffle_info_buf = malloc(bbinfo_shuffle_info_buf_len);[m
++[32m+[m[32mprotobuf_c_message_pack(&reorder_info, bbinfo_shuffle_info_buf); // Pack reorder_info into buf[m
++[32m+[m
++[32m+[m[32m// free the malloced space[m
++[32m+[m
++[32m+[m[32m// free layouts[m
++[32m+[m[32mfor(index = 0; index < bb_cnt; index++){[m
++[32m+[m[32m  free(layout[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfree(layout);[m
++[32m+[m
++[32m+[m[32m// free fixups[m
++[32m+[m[32mfor (index = 0; index < text_fixp_cnt; index++){[m
++[32m+[m[32m  free (text_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfor (index = 0; index < data_fixp_cnt; index++){[m
++[32m+[m[32m  free (data_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfor (index = 0; index < rodata_fixp_cnt; index++){[m
++[32m+[m[32m  free (rodata_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfor (index = 0; index < init_fixp_cnt; index++){[m
++[32m+[m[32m  free (init_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfor (index = 0; index < datarel_fixp_cnt; index++){[m
++[32m+[m[32m  free (datarel_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mif (text_fixp_cnt)[m
++[32m+[m[32m free (text_fixp);[m[41m [m
++[32m+[m[32mif (rodata_fixp_cnt)[m
++[32m+[m[32m free (rodata_fixp);[m
++[32m+[m[32mif (data_fixp_cnt)[m
++[32m+[m[32m free (data_fixp);[m
++[32m+[m[32mif (init_fixp_cnt)[m
++[32m+[m[32m free (init_fixp);[m
++[32m+[m[32mif (datarel_fixp_cnt)[m
++[32m+[m[32m free (datarel_fixp);[m[41m [m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m
++ // init the fixup struct[m
++ bbinfo_fixup* bbinfo_init_fixup(void){[m
++   bbinfo_fixup* result_fixup = malloc(sizeof(bbinfo_fixup));[m
++[36m@@ -88,6 +310,58 @@[m [mbbinfo_fixup* bbinfo_init_fixup(void){[m
++   return result_fixup;[m
++ }[m
++ [m
++[32m+[m[32m// if this is the new section[m
++[32m+[m[32mchar bbinfo_is_new_sec(asection *sec){[m
++[32m+[m[32m  const char* sec_name = sec->name;[m
++[32m+[m[32m  char* tmp_pointer = NULL;[m
++[32m+[m
++[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".text")) &&[m
++[32m+[m[32m      tmp_pointer == sec_name){[m
++[32m+[m[32m    text_sec_cnt++;[m
++[32m+[m[32m    if (text_sec_cnt == 1)[m
++[32m+[m[32m      return 0;[m
++[32m+[m[32m    else[m
++[32m+[m[32m      return 1;[m
++[32m+[m[32m  }[m
++[32m+[m
++[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".rodata")) &&[m[41m [m
++[32m+[m	[32mtmp_pointer == sec_name){[m
++[32m+[m[32m      rodata_sec_cnt++;[m
++[32m+[m[32m      if (rodata_sec_cnt == 1)[m
++[32m+[m	[32mreturn 0;[m
++[32m+[m[32m      else[m
++[32m+[m	[32mreturn 1;[m
++[32m+[m[32m      }[m
++[32m+[m
++[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&[m
++[32m+[m[32m      tmp_pointer == sec_name){[m
++[32m+[m[32m    init_sec_cnt++;[m
++[32m+[m[32m    if (init_sec_cnt == 1)[m
++[32m+[m[32m      return 0;[m
++[32m+[m[32m    else[m
++[32m+[m[32m      return 1;[m
++[32m+[m[32m  }[m
++[32m+[m
++[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".data")) &&[m
++[32m+[m[32m      tmp_pointer == sec_name){[m
++[32m+[m
++[32m+[m[32m    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&[m
++[32m+[m	[32mtmp_pointer == sec_name){[m
++[32m+[m[32m      datarel_sec_cnt++;[m
++[32m+[m[32m      if (datarel_sec_cnt == 1)[m
++[32m+[m	[32mreturn 0;[m
++[32m+[m[32m      else[m
++[32m+[m	[32mreturn 1;[m
++[32m+[m[32m    }[m
++[32m+[m
++[32m+[m[32m    data_sec_cnt++;[m
++[32m+[m[32m    if (data_sec_cnt == 1)[m
++[32m+[m[32m      return 0;[m
++[32m+[m[32m    else[m
++[32m+[m[32m      return 1;[m
++[32m+[m[32m  }[m
++[32m+[m[32m  return -1;[m
++[32m+[m[32m}[m
++ // init the bbinfo struct[m
++ bbinfo_mbb* init_basic_block(){[m
++   // malloc space[m
++[1mdiff --git a/bbInfoHandle.h b/bbInfoHandle.h[m
++[1mindex ac3b8c4..edc727b 100644[m
++[1m--- a/bbInfoHandle.h[m
++[1m+++ b/bbInfoHandle.h[m
++[36m@@ -7,12 +7,14 @@[m
++ #define BBINFOHANDLE_H[m
++ [m
++ #include "as.h"[m
++[32m+[m[32m#include "shuffleInfo.pb-c.h"[m
++ #include <stdint.h>[m
++ [m
++ extern const pseudo_typeS bbInfo_pseudo_table[];[m
++ extern int update_last_symbol(symbolS*);[m
++ extern void init_bbinfo_global(void);[m
++ extern void bbinfo_init(void);[m
++[32m+[m[32mextern char bbinfo_is_new_sec(asection*);[m
++ [m
++ [m
++ [m
++[36m@@ -41,6 +43,7 @@[m [mtypedef struct basic_block bbinfo_mbb;[m
++ typedef struct fixup{[m
++   uint32_t offset; // offset from section[m
++   asection *sec; // which section the basic block belongs to[m
++[32m+[m[32m  unsigned char is_new_section; // if its parent section is the new section that has the same name[m
++   unsigned char is_rela; // if this fixup is relative[m
++   uint32_t size; // the reference's size[m
++   uint32_t table_size; // for jump table reference only[m
++[36m@@ -57,6 +60,17 @@[m [mextern uint32_t prev_function_id; // prev function id[m
++ extern uint32_t cur_function_end_id; // current function end id[m
++ extern symbolS *last_symbol; // last user defined symbol[m
++ extern uint32_t cur_block_id; // global current basic block id[m
++[32m+[m[32m// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number[m
++[32m+[m[32mextern unsigned text_sec_cnt;[m
++[32m+[m[32mextern unsigned rodata_sec_cnt;[m
++[32m+[m[32mextern unsigned data_sec_cnt;[m
++[32m+[m[32mextern unsigned datarel_sec_cnt;[m
++[32m+[m[32mextern unsigned init_sec_cnt;[m
++[32m+[m
++[32m+[m[32m// shuffleInfo that CCR defines[m
++[32m+[m[32mextern char* bbinfo_shuffle_info_buf;[m[41m [m
++[32m+[m[32mextern unsigned bbinfo_shuffle_info_buf_len;[m
++ [m
++ extern bbinfo_fixup* bbinfo_init_fixup(void);[m
++[32m+[m[32mextern void bbinfo_update_shuffle_info(void);[m
++ #endif[m
++[1mdiff --git a/write.c b/write.c[m
++[1mindex 46a22e5..ab5ad70 100644[m
++[1m--- a/write.c[m
++[1m+++ b/write.c[m
++[36m@@ -1198,7 +1198,6 @@[m [mfix_segment (bfd *abfd ATTRIBUTE_UNUSED,[m
++  * binpang, add. [m
++  * collect fixup information before fixup resolved.[m
++  */[m
++[31m-[m
++ static void [m
++ bbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
++     	     asection *sec,[m
++[36m@@ -1206,6 +1205,12 @@[m [mbbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
++ {[m
++   fixS *fixp;[m
++   segment_info_type *seginfo = seg_info (sec);[m
++[32m+[m[32m  char is_new_sec = is_new_sec = bbinfo_is_new_sec(sec);[m
++[32m+[m[41m  [m
++[32m+[m[32m  // we only collect .text, .rodata, .init_array, .data, .data.rel.ro sections[m
++[32m+[m[32m  // FIXME[m
++[32m+[m[32m  if (is_new_sec == -1)[m
++[32m+[m[32m    return;[m
++   [m
++  /*[m
++   * TODO(binpang), add relocation information that .realoc directive defined[m
++[36m@@ -1225,9 +1230,11 @@[m [mbbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
++       tmp_fixp->table_size = S_GET_JMPTBL_SIZE(tmp_sym);[m
++       tmp_fixp->entry_size = S_GET_JMPTBL_ENTRY_SZ(tmp_sym);[m
++     }[m
++[32m+[m[32m    if (is_new_sec){[m
++[32m+[m[32m      tmp_fixp->is_new_section = 1;[m
++[32m+[m[32m    }[m
++   }[m
++ [m
++[31m-[m
++ }[m
++ static void[m
++ install_reloc (asection *sec, arelent *reloc, fragS *fragp,[m
++[36m@@ -1658,6 +1665,19 @@[m [mwrite_contents (bfd *abfd ATTRIBUTE_UNUSED,[m
++   segment_info_type *seginfo = seg_info (sec);[m
++   addressT offset = 0;[m
++   fragS *f;[m
++[32m+[m[41m  [m
++[32m+[m[32m  /*[m
++[32m+[m[32m   * binpang, add[m
++[32m+[m[32m   * output the section .rand[m
++[32m+[m[32m   */[m[41m [m
++[32m+[m[32m  if (!strcmp(sec->name, ".rand")){[m
++[32m+[m[32m    unsigned result = bfd_set_section_contents(stdoutput, sec, bbinfo_shuffle_info_buf,[m[41m [m
++[32m+[m			[32m(file_ptr) 0, (bfd_size_type) bbinfo_shuffle_info_buf_len);[m
++[32m+[m[41m    [m
++[32m+[m[32m    if(!result)[m
++[32m+[m[32m      as_warn(_("can't write data into .rand"));[m
++[32m+[m[32m    return;[m
++[32m+[m[32m  }[m
++ [m
++   /* Write out the frags.  */[m
++   if (seginfo == NULL[m
++[36m@@ -2348,6 +2368,16 @@[m [mwrite_object_file (void)[m
++       bfd_map_over_sections (stdoutput, compress_debug, (char *) 0);[m
++     }[m
++ [m
++[32m+[m[32m  /*[m
++[32m+[m[32m   * binpang, add[m
++[32m+[m[32m   * create .rand section[m
++[32m+[m[32m   */[m
++[32m+[m[32m  asection* rand_sec = bfd_make_section (stdoutput, ".rand");[m
++[32m+[m[32m  bfd_set_section_flags(stdoutput, rand_sec, SEC_HAS_CONTENTS);[m
++[32m+[m[32m  bbinfo_update_shuffle_info();[m
++[32m+[m[32m  // BUG? why should at here specify size. But in write_contents fuction, it can't work.[m
++[32m+[m[32m  rand_sec->size = bbinfo_shuffle_info_buf_len;[m
++[32m+[m
++   bfd_map_over_sections (stdoutput, write_contents, (char *) 0);[m
++ [m
++ // binpang, add. debug.[m
+diff --git a/shuffleInfo.pb-c.c b/shuffleInfo.pb-c.c
+new file mode 100644
+index 0000000..07b2a82
+--- /dev/null
++++ b/shuffleInfo.pb-c.c
+@@ -0,0 +1,598 @@
++/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
++/* Generated from: shuffleInfo.proto */
++
++/* Do not generate deprecated warnings for self */
++#ifndef PROTOBUF_C__NO_DEPRECATED
++#define PROTOBUF_C__NO_DEPRECATED
++#endif
++
++#include "shuffleInfo.pb-c.h"
++void   shuffle_info__reorder_info__binary_info__init
++                     (ShuffleInfo__ReorderInfo__BinaryInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo__BinaryInfo init_value = SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__layout_info__init
++                     (ShuffleInfo__ReorderInfo__LayoutInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo__LayoutInfo init_value = SHUFFLE_INFO__REORDER_INFO__LAYOUT_INFO__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__fixup_info__fixup_tuple__init
++                     (ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple         *message)
++{
++  static const ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple init_value = SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__FIXUP_TUPLE__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__fixup_info__init
++                     (ShuffleInfo__ReorderInfo__FixupInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo__FixupInfo init_value = SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__source_info__init
++                     (ShuffleInfo__ReorderInfo__SourceInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo__SourceInfo init_value = SHUFFLE_INFO__REORDER_INFO__SOURCE_INFO__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__init
++                     (ShuffleInfo__ReorderInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo init_value = SHUFFLE_INFO__REORDER_INFO__INIT;
++  *message = init_value;
++}
++size_t shuffle_info__reorder_info__get_packed_size
++                     (const ShuffleInfo__ReorderInfo *message)
++{
++  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
++  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
++}
++size_t shuffle_info__reorder_info__pack
++                     (const ShuffleInfo__ReorderInfo *message,
++                      uint8_t       *out)
++{
++  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
++  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
++}
++size_t shuffle_info__reorder_info__pack_to_buffer
++                     (const ShuffleInfo__ReorderInfo *message,
++                      ProtobufCBuffer *buffer)
++{
++  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
++  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
++}
++ShuffleInfo__ReorderInfo *
++       shuffle_info__reorder_info__unpack
++                     (ProtobufCAllocator  *allocator,
++                      size_t               len,
++                      const uint8_t       *data)
++{
++  return (ShuffleInfo__ReorderInfo *)
++     protobuf_c_message_unpack (&shuffle_info__reorder_info__descriptor,
++                                allocator, len, data);
++}
++void   shuffle_info__reorder_info__free_unpacked
++                     (ShuffleInfo__ReorderInfo *message,
++                      ProtobufCAllocator *allocator)
++{
++  if(!message)
++    return;
++  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
++  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
++}
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__binary_info__field_descriptors[4] =
++{
++  {
++    "rand_obj_offset",
++    1,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_rand_obj_offset),
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, rand_obj_offset),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "main_addr_offset",
++    2,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_main_addr_offset),
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, main_addr_offset),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "obj_sz",
++    3,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_obj_sz),
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, obj_sz),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "src_type",
++    4,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_src_type),
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, src_type),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__binary_info__field_indices_by_name[] = {
++  1,   /* field[1] = main_addr_offset */
++  2,   /* field[2] = obj_sz */
++  0,   /* field[0] = rand_obj_offset */
++  3,   /* field[3] = src_type */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__binary_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 4 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__binary_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.BinaryInfo",
++  "BinaryInfo",
++  "ShuffleInfo__ReorderInfo__BinaryInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__BinaryInfo),
++  4,
++  shuffle_info__reorder_info__binary_info__field_descriptors,
++  shuffle_info__reorder_info__binary_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__binary_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__binary_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__layout_info__field_descriptors[7] =
++{
++  {
++    "bb_size",
++    1,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_bb_size),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, bb_size),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "type",
++    2,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_type),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, type),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "num_fixups",
++    3,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_num_fixups),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, num_fixups),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "bb_fallthrough",
++    4,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_BOOL,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_bb_fallthrough),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, bb_fallthrough),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "section_name",
++    5,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_STRING,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, section_name),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "offset",
++    6,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_offset),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, offset),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "padding_size",
++    7,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_padding_size),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, padding_size),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__layout_info__field_indices_by_name[] = {
++  3,   /* field[3] = bb_fallthrough */
++  0,   /* field[0] = bb_size */
++  2,   /* field[2] = num_fixups */
++  5,   /* field[5] = offset */
++  6,   /* field[6] = padding_size */
++  4,   /* field[4] = section_name */
++  1,   /* field[1] = type */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__layout_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 7 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__layout_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.LayoutInfo",
++  "LayoutInfo",
++  "ShuffleInfo__ReorderInfo__LayoutInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__LayoutInfo),
++  7,
++  shuffle_info__reorder_info__layout_info__field_descriptors,
++  shuffle_info__reorder_info__layout_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__layout_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__layout_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__field_descriptors[7] =
++{
++  {
++    "offset",
++    1,
++    PROTOBUF_C_LABEL_REQUIRED,
++    PROTOBUF_C_TYPE_UINT32,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, offset),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "deref_sz",
++    2,
++    PROTOBUF_C_LABEL_REQUIRED,
++    PROTOBUF_C_TYPE_UINT32,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, deref_sz),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "is_rela",
++    3,
++    PROTOBUF_C_LABEL_REQUIRED,
++    PROTOBUF_C_TYPE_BOOL,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, is_rela),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "type",
++    4,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_type),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, type),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "section_name",
++    5,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_STRING,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, section_name),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "num_jt_entries",
++    6,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_num_jt_entries),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, num_jt_entries),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "jt_entry_sz",
++    7,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_jt_entry_sz),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, jt_entry_sz),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__fixup_info__fixup_tuple__field_indices_by_name[] = {
++  1,   /* field[1] = deref_sz */
++  2,   /* field[2] = is_rela */
++  6,   /* field[6] = jt_entry_sz */
++  5,   /* field[5] = num_jt_entries */
++  0,   /* field[0] = offset */
++  4,   /* field[4] = section_name */
++  3,   /* field[3] = type */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__fixup_info__fixup_tuple__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 7 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple",
++  "FixupTuple",
++  "ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple),
++  7,
++  shuffle_info__reorder_info__fixup_info__fixup_tuple__field_descriptors,
++  shuffle_info__reorder_info__fixup_info__fixup_tuple__field_indices_by_name,
++  1,  shuffle_info__reorder_info__fixup_info__fixup_tuple__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__fixup_info__fixup_tuple__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__fixup_info__field_descriptors[5] =
++{
++  {
++    "text",
++    1,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_text),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, text),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "rodata",
++    2,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_rodata),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, rodata),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "data",
++    3,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_data),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, data),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "datarel",
++    4,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_datarel),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, datarel),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "initarray",
++    5,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_initarray),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, initarray),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__fixup_info__field_indices_by_name[] = {
++  2,   /* field[2] = data */
++  3,   /* field[3] = datarel */
++  4,   /* field[4] = initarray */
++  1,   /* field[1] = rodata */
++  0,   /* field[0] = text */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__fixup_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 5 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.FixupInfo",
++  "FixupInfo",
++  "ShuffleInfo__ReorderInfo__FixupInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__FixupInfo),
++  5,
++  shuffle_info__reorder_info__fixup_info__field_descriptors,
++  shuffle_info__reorder_info__fixup_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__fixup_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__fixup_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__source_info__field_descriptors[1] =
++{
++  {
++    "src_type",
++    1,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__SourceInfo, n_src_type),
++    offsetof(ShuffleInfo__ReorderInfo__SourceInfo, src_type),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__source_info__field_indices_by_name[] = {
++  0,   /* field[0] = src_type */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__source_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 1 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__source_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.SourceInfo",
++  "SourceInfo",
++  "ShuffleInfo__ReorderInfo__SourceInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__SourceInfo),
++  1,
++  shuffle_info__reorder_info__source_info__field_descriptors,
++  shuffle_info__reorder_info__source_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__source_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__source_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__field_descriptors[4] =
++{
++  {
++    "bin",
++    1,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_MESSAGE,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo, bin),
++    &shuffle_info__reorder_info__binary_info__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "layout",
++    2,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo, n_layout),
++    offsetof(ShuffleInfo__ReorderInfo, layout),
++    &shuffle_info__reorder_info__layout_info__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "fixup",
++    3,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo, n_fixup),
++    offsetof(ShuffleInfo__ReorderInfo, fixup),
++    &shuffle_info__reorder_info__fixup_info__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "source",
++    4,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_MESSAGE,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo, source),
++    &shuffle_info__reorder_info__source_info__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__field_indices_by_name[] = {
++  0,   /* field[0] = bin */
++  2,   /* field[2] = fixup */
++  1,   /* field[1] = layout */
++  3,   /* field[3] = source */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 4 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo",
++  "ReorderInfo",
++  "ShuffleInfo__ReorderInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo),
++  4,
++  shuffle_info__reorder_info__field_descriptors,
++  shuffle_info__reorder_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
+diff --git a/shuffleInfo.pb-c.h b/shuffleInfo.pb-c.h
+new file mode 100644
+index 0000000..d036bbf
+--- /dev/null
++++ b/shuffleInfo.pb-c.h
+@@ -0,0 +1,265 @@
++/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
++/* Generated from: shuffleInfo.proto */
++
++#ifndef PROTOBUF_C_shuffleInfo_2eproto__INCLUDED
++#define PROTOBUF_C_shuffleInfo_2eproto__INCLUDED
++
++#include <protobuf-c/protobuf-c.h>
++
++PROTOBUF_C__BEGIN_DECLS
++
++#if PROTOBUF_C_VERSION_NUMBER < 1000000
++# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
++#elif 1003001 < PROTOBUF_C_MIN_COMPILER_VERSION
++# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
++#endif
++
++
++typedef struct _ShuffleInfo__ReorderInfo ShuffleInfo__ReorderInfo;
++typedef struct _ShuffleInfo__ReorderInfo__BinaryInfo ShuffleInfo__ReorderInfo__BinaryInfo;
++typedef struct _ShuffleInfo__ReorderInfo__LayoutInfo ShuffleInfo__ReorderInfo__LayoutInfo;
++typedef struct _ShuffleInfo__ReorderInfo__FixupInfo ShuffleInfo__ReorderInfo__FixupInfo;
++typedef struct _ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple;
++typedef struct _ShuffleInfo__ReorderInfo__SourceInfo ShuffleInfo__ReorderInfo__SourceInfo;
++
++
++/* --- enums --- */
++
++
++/* --- messages --- */
++
++/*
++ * Binary info from ld or ld.gold; reordering range and main offset
++ */
++struct  _ShuffleInfo__ReorderInfo__BinaryInfo
++{
++  ProtobufCMessage base;
++  /*
++   * PLACEHOLDER FOR LINKER
++   */
++  protobuf_c_boolean has_rand_obj_offset;
++  uint32_t rand_obj_offset;
++  /*
++   * PLACEHOLDER FOR LINKER
++   */
++  protobuf_c_boolean has_main_addr_offset;
++  uint32_t main_addr_offset;
++  /*
++   * Verification purpose
++   */
++  protobuf_c_boolean has_obj_sz;
++  uint32_t obj_sz;
++  /*
++   * See the SourceInfo message
++   */
++  protobuf_c_boolean has_src_type;
++  uint32_t src_type;
++};
++#define SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__binary_info__descriptor) \
++    , 0, 0, 0, 0, 0, 0, 0, 0 }
++
++
++/*
++ * Code layout Info (.text) from LLVM
++ * Embeded info ([#func|#fixup]/obj, [#bbk|#fixup]/func, objSz/ea, funcSz/ea)
++ */
++struct  _ShuffleInfo__ReorderInfo__LayoutInfo
++{
++  ProtobufCMessage base;
++  /*
++   * UPDATE AT LINKTIME WITH OBJ ALIGNMENTs
++   */
++  protobuf_c_boolean has_bb_size;
++  uint32_t bb_size;
++  /*
++   * All alignments between fn/bbl are included here
++   */
++  /*
++   * Represents the end of [OBJ|FUN|BBL]
++   */
++  protobuf_c_boolean has_type;
++  uint32_t type;
++  protobuf_c_boolean has_num_fixups;
++  uint32_t num_fixups;
++  protobuf_c_boolean has_bb_fallthrough;
++  protobuf_c_boolean bb_fallthrough;
++  /*
++   * section identifier for c++ mutiple sections
++   */
++  char *section_name;
++  /*
++   * update at linking when combining sections
++   */
++  protobuf_c_boolean has_offset;
++  uint32_t offset;
++  protobuf_c_boolean has_padding_size;
++  uint32_t padding_size;
++};
++#define SHUFFLE_INFO__REORDER_INFO__LAYOUT_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__layout_info__descriptor) \
++    , 0, 0, 0, 0, 0, 0, 0, 0, NULL, 0, 0, 0, 0 }
++
++
++struct  _ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple
++{
++  ProtobufCMessage base;
++  /*
++   * UPDATE AT LINKTIME WHEN COMBINING SECTIONS
++   */
++  uint32_t offset;
++  uint32_t deref_sz;
++  protobuf_c_boolean is_rela;
++  /*
++   * c2c, c2d, d2c, d2d = (0-3)
++   */
++  protobuf_c_boolean has_type;
++  uint32_t type;
++  /*
++   * section identifier for c++ mutiple sections
++   */
++  char *section_name;
++  /*
++   * fixup has a jump table (.rodata) for pic/pie use
++   */
++  /*
++   * number of the jump table entries
++   */
++  protobuf_c_boolean has_num_jt_entries;
++  uint32_t num_jt_entries;
++  /*
++   * size of each jump table entry in byte
++   */
++  protobuf_c_boolean has_jt_entry_sz;
++  uint32_t jt_entry_sz;
++};
++#define SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__FIXUP_TUPLE__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor) \
++    , 0, 0, 0, 0, 0, NULL, 0, 0, 0, 0 }
++
++
++/*
++ * Fixup info in ELF from LLVM
++ */
++struct  _ShuffleInfo__ReorderInfo__FixupInfo
++{
++  ProtobufCMessage base;
++  size_t n_text;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text;
++  size_t n_rodata;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata;
++  size_t n_data;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data;
++  size_t n_datarel;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel;
++  size_t n_initarray;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **initarray;
++};
++#define SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__fixup_info__descriptor) \
++    , 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL }
++
++
++/*
++ * Source info [generalSource(=0) | hasInlineAssembly(=1) | standaloneAssembly(=2)]
++ */
++struct  _ShuffleInfo__ReorderInfo__SourceInfo
++{
++  ProtobufCMessage base;
++  /*
++   * the src_type placeholder for linker
++   */
++  size_t n_src_type;
++  uint32_t *src_type;
++};
++#define SHUFFLE_INFO__REORDER_INFO__SOURCE_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__source_info__descriptor) \
++    , 0,NULL }
++
++
++struct  _ShuffleInfo__ReorderInfo
++{
++  ProtobufCMessage base;
++  ShuffleInfo__ReorderInfo__BinaryInfo *bin;
++  size_t n_layout;
++  ShuffleInfo__ReorderInfo__LayoutInfo **layout;
++  size_t n_fixup;
++  ShuffleInfo__ReorderInfo__FixupInfo **fixup;
++  ShuffleInfo__ReorderInfo__SourceInfo *source;
++};
++#define SHUFFLE_INFO__REORDER_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__descriptor) \
++    , NULL, 0,NULL, 0,NULL, NULL }
++
++
++/* ShuffleInfo__ReorderInfo__BinaryInfo methods */
++void   shuffle_info__reorder_info__binary_info__init
++                     (ShuffleInfo__ReorderInfo__BinaryInfo         *message);
++/* ShuffleInfo__ReorderInfo__LayoutInfo methods */
++void   shuffle_info__reorder_info__layout_info__init
++                     (ShuffleInfo__ReorderInfo__LayoutInfo         *message);
++/* ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple methods */
++void   shuffle_info__reorder_info__fixup_info__fixup_tuple__init
++                     (ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple         *message);
++/* ShuffleInfo__ReorderInfo__FixupInfo methods */
++void   shuffle_info__reorder_info__fixup_info__init
++                     (ShuffleInfo__ReorderInfo__FixupInfo         *message);
++/* ShuffleInfo__ReorderInfo__SourceInfo methods */
++void   shuffle_info__reorder_info__source_info__init
++                     (ShuffleInfo__ReorderInfo__SourceInfo         *message);
++/* ShuffleInfo__ReorderInfo methods */
++void   shuffle_info__reorder_info__init
++                     (ShuffleInfo__ReorderInfo         *message);
++size_t shuffle_info__reorder_info__get_packed_size
++                     (const ShuffleInfo__ReorderInfo   *message);
++size_t shuffle_info__reorder_info__pack
++                     (const ShuffleInfo__ReorderInfo   *message,
++                      uint8_t             *out);
++size_t shuffle_info__reorder_info__pack_to_buffer
++                     (const ShuffleInfo__ReorderInfo   *message,
++                      ProtobufCBuffer     *buffer);
++ShuffleInfo__ReorderInfo *
++       shuffle_info__reorder_info__unpack
++                     (ProtobufCAllocator  *allocator,
++                      size_t               len,
++                      const uint8_t       *data);
++void   shuffle_info__reorder_info__free_unpacked
++                     (ShuffleInfo__ReorderInfo *message,
++                      ProtobufCAllocator *allocator);
++/* --- per-message closures --- */
++
++typedef void (*ShuffleInfo__ReorderInfo__BinaryInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo__BinaryInfo *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo__LayoutInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo__LayoutInfo *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple_Closure)
++                 (const ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo__FixupInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo__FixupInfo *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo__SourceInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo__SourceInfo *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo *message,
++                  void *closure_data);
++
++/* --- services --- */
++
++
++/* --- descriptors --- */
++
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__binary_info__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__layout_info__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__source_info__descriptor;
++
++PROTOBUF_C__END_DECLS
++
++
++#endif  /* PROTOBUF_C_shuffleInfo_2eproto__INCLUDED */
+diff --git a/shuffleInfo.pb.cc b/shuffleInfo.pb.cc
+new file mode 100644
+index 0000000..dc74474
+--- /dev/null
++++ b/shuffleInfo.pb.cc
+@@ -0,0 +1,3372 @@
++// Generated by the protocol buffer compiler.  DO NOT EDIT!
++// source: shuffleInfo.proto
++
++#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
++#include "shuffleInfo.pb.h"
++
++#include <algorithm>
++
++#include <google/protobuf/stubs/common.h>
++#include <google/protobuf/stubs/port.h>
++#include <google/protobuf/stubs/once.h>
++#include <google/protobuf/io/coded_stream.h>
++#include <google/protobuf/wire_format_lite_inl.h>
++#include <google/protobuf/descriptor.h>
++#include <google/protobuf/generated_message_reflection.h>
++#include <google/protobuf/reflection_ops.h>
++#include <google/protobuf/wire_format.h>
++// @@protoc_insertion_point(includes)
++
++namespace ShuffleInfo {
++class ReorderInfo_BinaryInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_BinaryInfo> {};
++ReorderInfo_BinaryInfoDefaultTypeInternal _ReorderInfo_BinaryInfo_default_instance_;
++class ReorderInfo_LayoutInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_LayoutInfo> {};
++ReorderInfo_LayoutInfoDefaultTypeInternal _ReorderInfo_LayoutInfo_default_instance_;
++class ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_FixupInfo_FixupTuple> {};
++ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal _ReorderInfo_FixupInfo_FixupTuple_default_instance_;
++class ReorderInfo_FixupInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_FixupInfo> {};
++ReorderInfo_FixupInfoDefaultTypeInternal _ReorderInfo_FixupInfo_default_instance_;
++class ReorderInfo_SourceInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_SourceInfo> {};
++ReorderInfo_SourceInfoDefaultTypeInternal _ReorderInfo_SourceInfo_default_instance_;
++class ReorderInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo> {};
++ReorderInfoDefaultTypeInternal _ReorderInfo_default_instance_;
++
++namespace {
++
++::google::protobuf::Metadata file_level_metadata[6];
++
++}  // namespace
++
++
++const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto() GOOGLE_ATTRIBUTE_COLD;
++const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto() {
++  static const ::google::protobuf::uint32 offsets[] = {
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, rand_obj_offset_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, main_addr_offset_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, obj_sz_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, src_type_),
++    0,
++    1,
++    2,
++    3,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, bb_size_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, type_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, num_fixups_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, bb_fallthrough_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, section_name_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, offset_),
++    1,
++    2,
++    3,
++    4,
++    0,
++    5,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, offset_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, deref_sz_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, is_rela_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, type_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, section_name_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, num_jt_entries_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, jt_entry_sz_),
++    1,
++    2,
++    3,
++    4,
++    0,
++    5,
++    6,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, text_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, rodata_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, data_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, datarel_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, initarray_),
++    0,
++    1,
++    2,
++    3,
++    4,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, src_type_),
++    0,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, bin_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, layout_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, fixup_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, source_),
++    0,
++    2,
++    3,
++    1,
++  };
++  return offsets;
++}
++
++static const ::google::protobuf::internal::MigrationSchema schemas[] = {
++  { 0, 8, sizeof(ReorderInfo_BinaryInfo)},
++  { 12, 22, sizeof(ReorderInfo_LayoutInfo)},
++  { 28, 39, sizeof(ReorderInfo_FixupInfo_FixupTuple)},
++  { 46, 55, sizeof(ReorderInfo_FixupInfo)},
++  { 60, 65, sizeof(ReorderInfo_SourceInfo)},
++  { 66, 74, sizeof(ReorderInfo)},
++};
++
++static const ::google::protobuf::internal::DefaultInstanceData file_default_instances[] = {
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_BinaryInfo_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_LayoutInfo_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_FixupInfo_FixupTuple_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_FixupInfo_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_SourceInfo_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_default_instance_), NULL},
++};
++
++namespace {
++
++void protobuf_AssignDescriptors() {
++  protobuf_AddDesc_shuffleInfo_2eproto();
++  ::google::protobuf::MessageFactory* factory = NULL;
++  AssignDescriptors(
++      "shuffleInfo.proto", schemas, file_default_instances, protobuf_Offsets_shuffleInfo_2eproto(), factory,
++      file_level_metadata, NULL, NULL);
++}
++
++void protobuf_AssignDescriptorsOnce() {
++  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
++  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
++}
++
++void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
++void protobuf_RegisterTypes(const ::std::string&) {
++  protobuf_AssignDescriptorsOnce();
++  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 6);
++}
++
++}  // namespace
++
++void protobuf_ShutdownFile_shuffleInfo_2eproto() {
++  _ReorderInfo_BinaryInfo_default_instance_.Shutdown();
++  delete file_level_metadata[0].reflection;
++  _ReorderInfo_LayoutInfo_default_instance_.Shutdown();
++  delete file_level_metadata[1].reflection;
++  _ReorderInfo_FixupInfo_FixupTuple_default_instance_.Shutdown();
++  delete file_level_metadata[2].reflection;
++  _ReorderInfo_FixupInfo_default_instance_.Shutdown();
++  delete file_level_metadata[3].reflection;
++  _ReorderInfo_SourceInfo_default_instance_.Shutdown();
++  delete file_level_metadata[4].reflection;
++  _ReorderInfo_default_instance_.Shutdown();
++  delete file_level_metadata[5].reflection;
++}
++
++void protobuf_InitDefaults_shuffleInfo_2eproto_impl() {
++  GOOGLE_PROTOBUF_VERIFY_VERSION;
++
++  ::google::protobuf::internal::InitProtobufDefaults();
++  _ReorderInfo_BinaryInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_LayoutInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_FixupInfo_FixupTuple_default_instance_.DefaultConstruct();
++  _ReorderInfo_FixupInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_SourceInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_default_instance_.get_mutable()->bin_ = const_cast< ::ShuffleInfo::ReorderInfo_BinaryInfo*>(
++      ::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance());
++  _ReorderInfo_default_instance_.get_mutable()->source_ = const_cast< ::ShuffleInfo::ReorderInfo_SourceInfo*>(
++      ::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance());
++}
++
++void protobuf_InitDefaults_shuffleInfo_2eproto() {
++  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
++  ::google::protobuf::GoogleOnceInit(&once, &protobuf_InitDefaults_shuffleInfo_2eproto_impl);
++}
++void protobuf_AddDesc_shuffleInfo_2eproto_impl() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  static const char descriptor[] = {
++      "\n\021shuffleInfo.proto\022\013ShuffleInfo\"\272\007\n\013Reo"
++      "rderInfo\0220\n\003bin\030\001 \001(\0132#.ShuffleInfo.Reor"
++      "derInfo.BinaryInfo\0223\n\006layout\030\002 \003(\0132#.Shu"
++      "ffleInfo.ReorderInfo.LayoutInfo\0221\n\005fixup"
++      "\030\003 \003(\0132\".ShuffleInfo.ReorderInfo.FixupIn"
++      "fo\0223\n\006source\030\004 \001(\0132#.ShuffleInfo.Reorder"
++      "Info.SourceInfo\032a\n\nBinaryInfo\022\027\n\017rand_ob"
++      "j_offset\030\001 \001(\r\022\030\n\020main_addr_offset\030\002 \001(\r"
++      "\022\016\n\006obj_sz\030\003 \001(\r\022\020\n\010src_type\030\004 \001(\r\032}\n\nLa"
++      "youtInfo\022\017\n\007bb_size\030\001 \001(\r\022\014\n\004type\030\002 \001(\r\022"
++      "\022\n\nnum_fixups\030\003 \001(\r\022\026\n\016bb_fallthrough\030\004 "
++      "\001(\010\022\024\n\014section_name\030\005 \001(\t\022\016\n\006offset\030\006 \001("
++      "\r\032\331\003\n\tFixupInfo\022;\n\004text\030\001 \003(\0132-.ShuffleI"
++      "nfo.ReorderInfo.FixupInfo.FixupTuple\022=\n\006"
++      "rodata\030\002 \003(\0132-.ShuffleInfo.ReorderInfo.F"
++      "ixupInfo.FixupTuple\022;\n\004data\030\003 \003(\0132-.Shuf"
++      "fleInfo.ReorderInfo.FixupInfo.FixupTuple"
++      "\022>\n\007datarel\030\004 \003(\0132-.ShuffleInfo.ReorderI"
++      "nfo.FixupInfo.FixupTuple\022@\n\tinitarray\030\005 "
++      "\003(\0132-.ShuffleInfo.ReorderInfo.FixupInfo."
++      "FixupTuple\032\220\001\n\nFixupTuple\022\016\n\006offset\030\001 \002("
++      "\r\022\020\n\010deref_sz\030\002 \002(\r\022\017\n\007is_rela\030\003 \002(\010\022\014\n\004"
++      "type\030\004 \001(\r\022\024\n\014section_name\030\005 \001(\t\022\026\n\016num_"
++      "jt_entries\030\006 \001(\r\022\023\n\013jt_entry_sz\030\007 \001(\r\032\036\n"
++      "\nSourceInfo\022\020\n\010src_type\030\001 \003(\r"
++  };
++  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
++      descriptor, 989);
++  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
++    "shuffleInfo.proto", &protobuf_RegisterTypes);
++  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_shuffleInfo_2eproto);
++}
++
++GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_shuffleInfo_2eproto_once_);
++void protobuf_AddDesc_shuffleInfo_2eproto() {
++  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_shuffleInfo_2eproto_once_,
++                 &protobuf_AddDesc_shuffleInfo_2eproto_impl);
++}
++// Force AddDescriptors() to be called at static initialization time.
++struct StaticDescriptorInitializer_shuffleInfo_2eproto {
++  StaticDescriptorInitializer_shuffleInfo_2eproto() {
++    protobuf_AddDesc_shuffleInfo_2eproto();
++  }
++} static_descriptor_initializer_shuffleInfo_2eproto_;
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_BinaryInfo::kRandObjOffsetFieldNumber;
++const int ReorderInfo_BinaryInfo::kMainAddrOffsetFieldNumber;
++const int ReorderInfo_BinaryInfo::kObjSzFieldNumber;
++const int ReorderInfo_BinaryInfo::kSrcTypeFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_BinaryInfo::ReorderInfo_BinaryInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.BinaryInfo)
++}
++ReorderInfo_BinaryInfo::ReorderInfo_BinaryInfo(const ReorderInfo_BinaryInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  ::memcpy(&rand_obj_offset_, &from.rand_obj_offset_,
++    reinterpret_cast<char*>(&src_type_) -
++    reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.BinaryInfo)
++}
++
++void ReorderInfo_BinaryInfo::SharedCtor() {
++  _cached_size_ = 0;
++  ::memset(&rand_obj_offset_, 0, reinterpret_cast<char*>(&src_type_) -
++    reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
++}
++
++ReorderInfo_BinaryInfo::~ReorderInfo_BinaryInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.BinaryInfo)
++  SharedDtor();
++}
++
++void ReorderInfo_BinaryInfo::SharedDtor() {
++}
++
++void ReorderInfo_BinaryInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_BinaryInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[0].descriptor;
++}
++
++const ReorderInfo_BinaryInfo& ReorderInfo_BinaryInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_BinaryInfo* ReorderInfo_BinaryInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_BinaryInfo* n = new ReorderInfo_BinaryInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_BinaryInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  if (_has_bits_[0 / 32] & 15u) {
++    ::memset(&rand_obj_offset_, 0, reinterpret_cast<char*>(&src_type_) -
++      reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
++  }
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_BinaryInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // optional uint32 rand_obj_offset = 1;
++      case 1: {
++        if (tag == 8u) {
++          set_has_rand_obj_offset();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &rand_obj_offset_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 main_addr_offset = 2;
++      case 2: {
++        if (tag == 16u) {
++          set_has_main_addr_offset();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &main_addr_offset_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 obj_sz = 3;
++      case 3: {
++        if (tag == 24u) {
++          set_has_obj_sz();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &obj_sz_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 src_type = 4;
++      case 4: {
++        if (tag == 32u) {
++          set_has_src_type();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &src_type_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.BinaryInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.BinaryInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_BinaryInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  // optional uint32 rand_obj_offset = 1;
++  if (has_rand_obj_offset()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rand_obj_offset(), output);
++  }
++
++  // optional uint32 main_addr_offset = 2;
++  if (has_main_addr_offset()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->main_addr_offset(), output);
++  }
++
++  // optional uint32 obj_sz = 3;
++  if (has_obj_sz()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->obj_sz(), output);
++  }
++
++  // optional uint32 src_type = 4;
++  if (has_src_type()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->src_type(), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.BinaryInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo_BinaryInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  // optional uint32 rand_obj_offset = 1;
++  if (has_rand_obj_offset()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->rand_obj_offset(), target);
++  }
++
++  // optional uint32 main_addr_offset = 2;
++  if (has_main_addr_offset()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->main_addr_offset(), target);
++  }
++
++  // optional uint32 obj_sz = 3;
++  if (has_obj_sz()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->obj_sz(), target);
++  }
++
++  // optional uint32 src_type = 4;
++  if (has_src_type()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->src_type(), target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.BinaryInfo)
++  return target;
++}
++
++size_t ReorderInfo_BinaryInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  if (_has_bits_[0 / 32] & 15u) {
++    // optional uint32 rand_obj_offset = 1;
++    if (has_rand_obj_offset()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->rand_obj_offset());
++    }
++
++    // optional uint32 main_addr_offset = 2;
++    if (has_main_addr_offset()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->main_addr_offset());
++    }
++
++    // optional uint32 obj_sz = 3;
++    if (has_obj_sz()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->obj_sz());
++    }
++
++    // optional uint32 src_type = 4;
++    if (has_src_type()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->src_type());
++    }
++
++  }
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_BinaryInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_BinaryInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_BinaryInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.BinaryInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.BinaryInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_BinaryInfo::MergeFrom(const ReorderInfo_BinaryInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  if (from._has_bits_[0 / 32] & 15u) {
++    if (from.has_rand_obj_offset()) {
++      set_rand_obj_offset(from.rand_obj_offset());
++    }
++    if (from.has_main_addr_offset()) {
++      set_main_addr_offset(from.main_addr_offset());
++    }
++    if (from.has_obj_sz()) {
++      set_obj_sz(from.obj_sz());
++    }
++    if (from.has_src_type()) {
++      set_src_type(from.src_type());
++    }
++  }
++}
++
++void ReorderInfo_BinaryInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_BinaryInfo::CopyFrom(const ReorderInfo_BinaryInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_BinaryInfo::IsInitialized() const {
++  return true;
++}
++
++void ReorderInfo_BinaryInfo::Swap(ReorderInfo_BinaryInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_BinaryInfo::InternalSwap(ReorderInfo_BinaryInfo* other) {
++  std::swap(rand_obj_offset_, other->rand_obj_offset_);
++  std::swap(main_addr_offset_, other->main_addr_offset_);
++  std::swap(obj_sz_, other->obj_sz_);
++  std::swap(src_type_, other->src_type_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_BinaryInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[0];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_BinaryInfo
++
++// optional uint32 rand_obj_offset = 1;
++bool ReorderInfo_BinaryInfo::has_rand_obj_offset() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++void ReorderInfo_BinaryInfo::set_has_rand_obj_offset() {
++  _has_bits_[0] |= 0x00000001u;
++}
++void ReorderInfo_BinaryInfo::clear_has_rand_obj_offset() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++void ReorderInfo_BinaryInfo::clear_rand_obj_offset() {
++  rand_obj_offset_ = 0u;
++  clear_has_rand_obj_offset();
++}
++::google::protobuf::uint32 ReorderInfo_BinaryInfo::rand_obj_offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
++  return rand_obj_offset_;
++}
++void ReorderInfo_BinaryInfo::set_rand_obj_offset(::google::protobuf::uint32 value) {
++  set_has_rand_obj_offset();
++  rand_obj_offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
++}
++
++// optional uint32 main_addr_offset = 2;
++bool ReorderInfo_BinaryInfo::has_main_addr_offset() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++void ReorderInfo_BinaryInfo::set_has_main_addr_offset() {
++  _has_bits_[0] |= 0x00000002u;
++}
++void ReorderInfo_BinaryInfo::clear_has_main_addr_offset() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++void ReorderInfo_BinaryInfo::clear_main_addr_offset() {
++  main_addr_offset_ = 0u;
++  clear_has_main_addr_offset();
++}
++::google::protobuf::uint32 ReorderInfo_BinaryInfo::main_addr_offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
++  return main_addr_offset_;
++}
++void ReorderInfo_BinaryInfo::set_main_addr_offset(::google::protobuf::uint32 value) {
++  set_has_main_addr_offset();
++  main_addr_offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
++}
++
++// optional uint32 obj_sz = 3;
++bool ReorderInfo_BinaryInfo::has_obj_sz() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++void ReorderInfo_BinaryInfo::set_has_obj_sz() {
++  _has_bits_[0] |= 0x00000004u;
++}
++void ReorderInfo_BinaryInfo::clear_has_obj_sz() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++void ReorderInfo_BinaryInfo::clear_obj_sz() {
++  obj_sz_ = 0u;
++  clear_has_obj_sz();
++}
++::google::protobuf::uint32 ReorderInfo_BinaryInfo::obj_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
++  return obj_sz_;
++}
++void ReorderInfo_BinaryInfo::set_obj_sz(::google::protobuf::uint32 value) {
++  set_has_obj_sz();
++  obj_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
++}
++
++// optional uint32 src_type = 4;
++bool ReorderInfo_BinaryInfo::has_src_type() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++void ReorderInfo_BinaryInfo::set_has_src_type() {
++  _has_bits_[0] |= 0x00000008u;
++}
++void ReorderInfo_BinaryInfo::clear_has_src_type() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++void ReorderInfo_BinaryInfo::clear_src_type() {
++  src_type_ = 0u;
++  clear_has_src_type();
++}
++::google::protobuf::uint32 ReorderInfo_BinaryInfo::src_type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
++  return src_type_;
++}
++void ReorderInfo_BinaryInfo::set_src_type(::google::protobuf::uint32 value) {
++  set_has_src_type();
++  src_type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_LayoutInfo::kBbSizeFieldNumber;
++const int ReorderInfo_LayoutInfo::kTypeFieldNumber;
++const int ReorderInfo_LayoutInfo::kNumFixupsFieldNumber;
++const int ReorderInfo_LayoutInfo::kBbFallthroughFieldNumber;
++const int ReorderInfo_LayoutInfo::kSectionNameFieldNumber;
++const int ReorderInfo_LayoutInfo::kOffsetFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_LayoutInfo::ReorderInfo_LayoutInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.LayoutInfo)
++}
++ReorderInfo_LayoutInfo::ReorderInfo_LayoutInfo(const ReorderInfo_LayoutInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  if (from.has_section_name()) {
++    section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
++  }
++  ::memcpy(&bb_size_, &from.bb_size_,
++    reinterpret_cast<char*>(&offset_) -
++    reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.LayoutInfo)
++}
++
++void ReorderInfo_LayoutInfo::SharedCtor() {
++  _cached_size_ = 0;
++  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  ::memset(&bb_size_, 0, reinterpret_cast<char*>(&offset_) -
++    reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
++}
++
++ReorderInfo_LayoutInfo::~ReorderInfo_LayoutInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.LayoutInfo)
++  SharedDtor();
++}
++
++void ReorderInfo_LayoutInfo::SharedDtor() {
++  section_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++
++void ReorderInfo_LayoutInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_LayoutInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[1].descriptor;
++}
++
++const ReorderInfo_LayoutInfo& ReorderInfo_LayoutInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_LayoutInfo* ReorderInfo_LayoutInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_LayoutInfo* n = new ReorderInfo_LayoutInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_LayoutInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  if (has_section_name()) {
++    GOOGLE_DCHECK(!section_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
++    (*section_name_.UnsafeRawStringPointer())->clear();
++  }
++  if (_has_bits_[0 / 32] & 62u) {
++    ::memset(&bb_size_, 0, reinterpret_cast<char*>(&offset_) -
++      reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
++  }
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_LayoutInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // optional uint32 bb_size = 1;
++      case 1: {
++        if (tag == 8u) {
++          set_has_bb_size();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &bb_size_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 type = 2;
++      case 2: {
++        if (tag == 16u) {
++          set_has_type();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &type_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 num_fixups = 3;
++      case 3: {
++        if (tag == 24u) {
++          set_has_num_fixups();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &num_fixups_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional bool bb_fallthrough = 4;
++      case 4: {
++        if (tag == 32u) {
++          set_has_bb_fallthrough();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
++                 input, &bb_fallthrough_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional string section_name = 5;
++      case 5: {
++        if (tag == 42u) {
++          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
++                input, this->mutable_section_name()));
++          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++            this->section_name().data(), this->section_name().length(),
++            ::google::protobuf::internal::WireFormat::PARSE,
++            "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 offset = 6;
++      case 6: {
++        if (tag == 48u) {
++          set_has_offset();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &offset_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.LayoutInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.LayoutInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_LayoutInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  // optional uint32 bb_size = 1;
++  if (has_bb_size()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->bb_size(), output);
++  }
++
++  // optional uint32 type = 2;
++  if (has_type()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
++  }
++
++  // optional uint32 num_fixups = 3;
++  if (has_num_fixups()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->num_fixups(), output);
++  }
++
++  // optional bool bb_fallthrough = 4;
++  if (has_bb_fallthrough()) {
++    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->bb_fallthrough(), output);
++  }
++
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++      this->section_name().data(), this->section_name().length(),
++      ::google::protobuf::internal::WireFormat::SERIALIZE,
++      "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
++    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
++      5, this->section_name(), output);
++  }
++
++  // optional uint32 offset = 6;
++  if (has_offset()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->offset(), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.LayoutInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo_LayoutInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  // optional uint32 bb_size = 1;
++  if (has_bb_size()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->bb_size(), target);
++  }
++
++  // optional uint32 type = 2;
++  if (has_type()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->type(), target);
++  }
++
++  // optional uint32 num_fixups = 3;
++  if (has_num_fixups()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->num_fixups(), target);
++  }
++
++  // optional bool bb_fallthrough = 4;
++  if (has_bb_fallthrough()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->bb_fallthrough(), target);
++  }
++
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++      this->section_name().data(), this->section_name().length(),
++      ::google::protobuf::internal::WireFormat::SERIALIZE,
++      "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
++    target =
++      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
++        5, this->section_name(), target);
++  }
++
++  // optional uint32 offset = 6;
++  if (has_offset()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->offset(), target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.LayoutInfo)
++  return target;
++}
++
++size_t ReorderInfo_LayoutInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  if (_has_bits_[0 / 32] & 63u) {
++    // optional string section_name = 5;
++    if (has_section_name()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::StringSize(
++          this->section_name());
++    }
++
++    // optional uint32 bb_size = 1;
++    if (has_bb_size()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->bb_size());
++    }
++
++    // optional uint32 type = 2;
++    if (has_type()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->type());
++    }
++
++    // optional uint32 num_fixups = 3;
++    if (has_num_fixups()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->num_fixups());
++    }
++
++    // optional bool bb_fallthrough = 4;
++    if (has_bb_fallthrough()) {
++      total_size += 1 + 1;
++    }
++
++    // optional uint32 offset = 6;
++    if (has_offset()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->offset());
++    }
++
++  }
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_LayoutInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_LayoutInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_LayoutInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.LayoutInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.LayoutInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_LayoutInfo::MergeFrom(const ReorderInfo_LayoutInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  if (from._has_bits_[0 / 32] & 63u) {
++    if (from.has_section_name()) {
++      set_has_section_name();
++      section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
++    }
++    if (from.has_bb_size()) {
++      set_bb_size(from.bb_size());
++    }
++    if (from.has_type()) {
++      set_type(from.type());
++    }
++    if (from.has_num_fixups()) {
++      set_num_fixups(from.num_fixups());
++    }
++    if (from.has_bb_fallthrough()) {
++      set_bb_fallthrough(from.bb_fallthrough());
++    }
++    if (from.has_offset()) {
++      set_offset(from.offset());
++    }
++  }
++}
++
++void ReorderInfo_LayoutInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_LayoutInfo::CopyFrom(const ReorderInfo_LayoutInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_LayoutInfo::IsInitialized() const {
++  return true;
++}
++
++void ReorderInfo_LayoutInfo::Swap(ReorderInfo_LayoutInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_LayoutInfo::InternalSwap(ReorderInfo_LayoutInfo* other) {
++  section_name_.Swap(&other->section_name_);
++  std::swap(bb_size_, other->bb_size_);
++  std::swap(type_, other->type_);
++  std::swap(num_fixups_, other->num_fixups_);
++  std::swap(bb_fallthrough_, other->bb_fallthrough_);
++  std::swap(offset_, other->offset_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_LayoutInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[1];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_LayoutInfo
++
++// optional uint32 bb_size = 1;
++bool ReorderInfo_LayoutInfo::has_bb_size() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_bb_size() {
++  _has_bits_[0] |= 0x00000002u;
++}
++void ReorderInfo_LayoutInfo::clear_has_bb_size() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++void ReorderInfo_LayoutInfo::clear_bb_size() {
++  bb_size_ = 0u;
++  clear_has_bb_size();
++}
++::google::protobuf::uint32 ReorderInfo_LayoutInfo::bb_size() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
++  return bb_size_;
++}
++void ReorderInfo_LayoutInfo::set_bb_size(::google::protobuf::uint32 value) {
++  set_has_bb_size();
++  bb_size_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
++}
++
++// optional uint32 type = 2;
++bool ReorderInfo_LayoutInfo::has_type() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_type() {
++  _has_bits_[0] |= 0x00000004u;
++}
++void ReorderInfo_LayoutInfo::clear_has_type() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++void ReorderInfo_LayoutInfo::clear_type() {
++  type_ = 0u;
++  clear_has_type();
++}
++::google::protobuf::uint32 ReorderInfo_LayoutInfo::type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.type)
++  return type_;
++}
++void ReorderInfo_LayoutInfo::set_type(::google::protobuf::uint32 value) {
++  set_has_type();
++  type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.type)
++}
++
++// optional uint32 num_fixups = 3;
++bool ReorderInfo_LayoutInfo::has_num_fixups() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_num_fixups() {
++  _has_bits_[0] |= 0x00000008u;
++}
++void ReorderInfo_LayoutInfo::clear_has_num_fixups() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++void ReorderInfo_LayoutInfo::clear_num_fixups() {
++  num_fixups_ = 0u;
++  clear_has_num_fixups();
++}
++::google::protobuf::uint32 ReorderInfo_LayoutInfo::num_fixups() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
++  return num_fixups_;
++}
++void ReorderInfo_LayoutInfo::set_num_fixups(::google::protobuf::uint32 value) {
++  set_has_num_fixups();
++  num_fixups_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
++}
++
++// optional bool bb_fallthrough = 4;
++bool ReorderInfo_LayoutInfo::has_bb_fallthrough() const {
++  return (_has_bits_[0] & 0x00000010u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_bb_fallthrough() {
++  _has_bits_[0] |= 0x00000010u;
++}
++void ReorderInfo_LayoutInfo::clear_has_bb_fallthrough() {
++  _has_bits_[0] &= ~0x00000010u;
++}
++void ReorderInfo_LayoutInfo::clear_bb_fallthrough() {
++  bb_fallthrough_ = false;
++  clear_has_bb_fallthrough();
++}
++bool ReorderInfo_LayoutInfo::bb_fallthrough() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
++  return bb_fallthrough_;
++}
++void ReorderInfo_LayoutInfo::set_bb_fallthrough(bool value) {
++  set_has_bb_fallthrough();
++  bb_fallthrough_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
++}
++
++// optional string section_name = 5;
++bool ReorderInfo_LayoutInfo::has_section_name() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_section_name() {
++  _has_bits_[0] |= 0x00000001u;
++}
++void ReorderInfo_LayoutInfo::clear_has_section_name() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++void ReorderInfo_LayoutInfo::clear_section_name() {
++  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  clear_has_section_name();
++}
++const ::std::string& ReorderInfo_LayoutInfo::section_name() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  return section_name_.GetNoArena();
++}
++void ReorderInfo_LayoutInfo::set_section_name(const ::std::string& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++#if LANG_CXX11
++void ReorderInfo_LayoutInfo::set_section_name(::std::string&& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(
++    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
++  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++#endif
++void ReorderInfo_LayoutInfo::set_section_name(const char* value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
++  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++void ReorderInfo_LayoutInfo::set_section_name(const char* value, size_t size) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
++      ::std::string(reinterpret_cast<const char*>(value), size));
++  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++::std::string* ReorderInfo_LayoutInfo::mutable_section_name() {
++  set_has_section_name();
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++::std::string* ReorderInfo_LayoutInfo::release_section_name() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  clear_has_section_name();
++  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++void ReorderInfo_LayoutInfo::set_allocated_section_name(::std::string* section_name) {
++  if (section_name != NULL) {
++    set_has_section_name();
++  } else {
++    clear_has_section_name();
++  }
++  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++
++// optional uint32 offset = 6;
++bool ReorderInfo_LayoutInfo::has_offset() const {
++  return (_has_bits_[0] & 0x00000020u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_offset() {
++  _has_bits_[0] |= 0x00000020u;
++}
++void ReorderInfo_LayoutInfo::clear_has_offset() {
++  _has_bits_[0] &= ~0x00000020u;
++}
++void ReorderInfo_LayoutInfo::clear_offset() {
++  offset_ = 0u;
++  clear_has_offset();
++}
++::google::protobuf::uint32 ReorderInfo_LayoutInfo::offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
++  return offset_;
++}
++void ReorderInfo_LayoutInfo::set_offset(::google::protobuf::uint32 value) {
++  set_has_offset();
++  offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_FixupInfo_FixupTuple::kOffsetFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kDerefSzFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kIsRelaFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kTypeFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kSectionNameFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kNumJtEntriesFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kJtEntrySzFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_FixupInfo_FixupTuple::ReorderInfo_FixupInfo_FixupTuple()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++}
++ReorderInfo_FixupInfo_FixupTuple::ReorderInfo_FixupInfo_FixupTuple(const ReorderInfo_FixupInfo_FixupTuple& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  if (from.has_section_name()) {
++    section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
++  }
++  ::memcpy(&offset_, &from.offset_,
++    reinterpret_cast<char*>(&jt_entry_sz_) -
++    reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::SharedCtor() {
++  _cached_size_ = 0;
++  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  ::memset(&offset_, 0, reinterpret_cast<char*>(&jt_entry_sz_) -
++    reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
++}
++
++ReorderInfo_FixupInfo_FixupTuple::~ReorderInfo_FixupInfo_FixupTuple() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  SharedDtor();
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::SharedDtor() {
++  section_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_FixupInfo_FixupTuple::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[2].descriptor;
++}
++
++const ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo_FixupTuple::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo_FixupTuple::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_FixupInfo_FixupTuple* n = new ReorderInfo_FixupInfo_FixupTuple;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  if (has_section_name()) {
++    GOOGLE_DCHECK(!section_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
++    (*section_name_.UnsafeRawStringPointer())->clear();
++  }
++  if (_has_bits_[0 / 32] & 126u) {
++    ::memset(&offset_, 0, reinterpret_cast<char*>(&jt_entry_sz_) -
++      reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
++  }
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_FixupInfo_FixupTuple::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // required uint32 offset = 1;
++      case 1: {
++        if (tag == 8u) {
++          set_has_offset();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &offset_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // required uint32 deref_sz = 2;
++      case 2: {
++        if (tag == 16u) {
++          set_has_deref_sz();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &deref_sz_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // required bool is_rela = 3;
++      case 3: {
++        if (tag == 24u) {
++          set_has_is_rela();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
++                 input, &is_rela_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 type = 4;
++      case 4: {
++        if (tag == 32u) {
++          set_has_type();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &type_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional string section_name = 5;
++      case 5: {
++        if (tag == 42u) {
++          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
++                input, this->mutable_section_name()));
++          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++            this->section_name().data(), this->section_name().length(),
++            ::google::protobuf::internal::WireFormat::PARSE,
++            "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 num_jt_entries = 6;
++      case 6: {
++        if (tag == 48u) {
++          set_has_num_jt_entries();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &num_jt_entries_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 jt_entry_sz = 7;
++      case 7: {
++        if (tag == 56u) {
++          set_has_jt_entry_sz();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &jt_entry_sz_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  // required uint32 offset = 1;
++  if (has_offset()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->offset(), output);
++  }
++
++  // required uint32 deref_sz = 2;
++  if (has_deref_sz()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->deref_sz(), output);
++  }
++
++  // required bool is_rela = 3;
++  if (has_is_rela()) {
++    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_rela(), output);
++  }
++
++  // optional uint32 type = 4;
++  if (has_type()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->type(), output);
++  }
++
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++      this->section_name().data(), this->section_name().length(),
++      ::google::protobuf::internal::WireFormat::SERIALIZE,
++      "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
++    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
++      5, this->section_name(), output);
++  }
++
++  // optional uint32 num_jt_entries = 6;
++  if (has_num_jt_entries()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->num_jt_entries(), output);
++  }
++
++  // optional uint32 jt_entry_sz = 7;
++  if (has_jt_entry_sz()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->jt_entry_sz(), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++}
++
++::google::protobuf::uint8* ReorderInfo_FixupInfo_FixupTuple::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  // required uint32 offset = 1;
++  if (has_offset()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->offset(), target);
++  }
++
++  // required uint32 deref_sz = 2;
++  if (has_deref_sz()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->deref_sz(), target);
++  }
++
++  // required bool is_rela = 3;
++  if (has_is_rela()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->is_rela(), target);
++  }
++
++  // optional uint32 type = 4;
++  if (has_type()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->type(), target);
++  }
++
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++      this->section_name().data(), this->section_name().length(),
++      ::google::protobuf::internal::WireFormat::SERIALIZE,
++      "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
++    target =
++      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
++        5, this->section_name(), target);
++  }
++
++  // optional uint32 num_jt_entries = 6;
++  if (has_num_jt_entries()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->num_jt_entries(), target);
++  }
++
++  // optional uint32 jt_entry_sz = 7;
++  if (has_jt_entry_sz()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->jt_entry_sz(), target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  return target;
++}
++
++size_t ReorderInfo_FixupInfo_FixupTuple::RequiredFieldsByteSizeFallback() const {
++// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  size_t total_size = 0;
++
++  if (has_offset()) {
++    // required uint32 offset = 1;
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::UInt32Size(
++        this->offset());
++  }
++
++  if (has_deref_sz()) {
++    // required uint32 deref_sz = 2;
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::UInt32Size(
++        this->deref_sz());
++  }
++
++  if (has_is_rela()) {
++    // required bool is_rela = 3;
++    total_size += 1 + 1;
++  }
++
++  return total_size;
++}
++size_t ReorderInfo_FixupInfo_FixupTuple::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
++    // required uint32 offset = 1;
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::UInt32Size(
++        this->offset());
++
++    // required uint32 deref_sz = 2;
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::UInt32Size(
++        this->deref_sz());
++
++    // required bool is_rela = 3;
++    total_size += 1 + 1;
++
++  } else {
++    total_size += RequiredFieldsByteSizeFallback();
++  }
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::StringSize(
++        this->section_name());
++  }
++
++  if (_has_bits_[0 / 32] & 112u) {
++    // optional uint32 type = 4;
++    if (has_type()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->type());
++    }
++
++    // optional uint32 num_jt_entries = 6;
++    if (has_num_jt_entries()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->num_jt_entries());
++    }
++
++    // optional uint32 jt_entry_sz = 7;
++    if (has_jt_entry_sz()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->jt_entry_sz());
++    }
++
++  }
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_FixupInfo_FixupTuple* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_FixupInfo_FixupTuple>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::MergeFrom(const ReorderInfo_FixupInfo_FixupTuple& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  if (from._has_bits_[0 / 32] & 127u) {
++    if (from.has_section_name()) {
++      set_has_section_name();
++      section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
++    }
++    if (from.has_offset()) {
++      set_offset(from.offset());
++    }
++    if (from.has_deref_sz()) {
++      set_deref_sz(from.deref_sz());
++    }
++    if (from.has_is_rela()) {
++      set_is_rela(from.is_rela());
++    }
++    if (from.has_type()) {
++      set_type(from.type());
++    }
++    if (from.has_num_jt_entries()) {
++      set_num_jt_entries(from.num_jt_entries());
++    }
++    if (from.has_jt_entry_sz()) {
++      set_jt_entry_sz(from.jt_entry_sz());
++    }
++  }
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::CopyFrom(const ReorderInfo_FixupInfo_FixupTuple& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_FixupInfo_FixupTuple::IsInitialized() const {
++  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;
++  return true;
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::Swap(ReorderInfo_FixupInfo_FixupTuple* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_FixupInfo_FixupTuple::InternalSwap(ReorderInfo_FixupInfo_FixupTuple* other) {
++  section_name_.Swap(&other->section_name_);
++  std::swap(offset_, other->offset_);
++  std::swap(deref_sz_, other->deref_sz_);
++  std::swap(is_rela_, other->is_rela_);
++  std::swap(type_, other->type_);
++  std::swap(num_jt_entries_, other->num_jt_entries_);
++  std::swap(jt_entry_sz_, other->jt_entry_sz_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_FixupInfo_FixupTuple::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[2];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_FixupInfo_FixupTuple
++
++// required uint32 offset = 1;
++bool ReorderInfo_FixupInfo_FixupTuple::has_offset() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_offset() {
++  _has_bits_[0] |= 0x00000002u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_offset() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_offset() {
++  offset_ = 0u;
++  clear_has_offset();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
++  return offset_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_offset(::google::protobuf::uint32 value) {
++  set_has_offset();
++  offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
++}
++
++// required uint32 deref_sz = 2;
++bool ReorderInfo_FixupInfo_FixupTuple::has_deref_sz() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_deref_sz() {
++  _has_bits_[0] |= 0x00000004u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_deref_sz() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_deref_sz() {
++  deref_sz_ = 0u;
++  clear_has_deref_sz();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::deref_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
++  return deref_sz_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_deref_sz(::google::protobuf::uint32 value) {
++  set_has_deref_sz();
++  deref_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
++}
++
++// required bool is_rela = 3;
++bool ReorderInfo_FixupInfo_FixupTuple::has_is_rela() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_is_rela() {
++  _has_bits_[0] |= 0x00000008u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_is_rela() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_is_rela() {
++  is_rela_ = false;
++  clear_has_is_rela();
++}
++bool ReorderInfo_FixupInfo_FixupTuple::is_rela() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
++  return is_rela_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_is_rela(bool value) {
++  set_has_is_rela();
++  is_rela_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
++}
++
++// optional uint32 type = 4;
++bool ReorderInfo_FixupInfo_FixupTuple::has_type() const {
++  return (_has_bits_[0] & 0x00000010u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_type() {
++  _has_bits_[0] |= 0x00000010u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_type() {
++  _has_bits_[0] &= ~0x00000010u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_type() {
++  type_ = 0u;
++  clear_has_type();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
++  return type_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_type(::google::protobuf::uint32 value) {
++  set_has_type();
++  type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
++}
++
++// optional string section_name = 5;
++bool ReorderInfo_FixupInfo_FixupTuple::has_section_name() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_section_name() {
++  _has_bits_[0] |= 0x00000001u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_section_name() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_section_name() {
++  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  clear_has_section_name();
++}
++const ::std::string& ReorderInfo_FixupInfo_FixupTuple::section_name() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  return section_name_.GetNoArena();
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const ::std::string& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++#if LANG_CXX11
++void ReorderInfo_FixupInfo_FixupTuple::set_section_name(::std::string&& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(
++    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
++  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++#endif
++void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
++  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value, size_t size) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
++      ::std::string(reinterpret_cast<const char*>(value), size));
++  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++::std::string* ReorderInfo_FixupInfo_FixupTuple::mutable_section_name() {
++  set_has_section_name();
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++::std::string* ReorderInfo_FixupInfo_FixupTuple::release_section_name() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  clear_has_section_name();
++  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_allocated_section_name(::std::string* section_name) {
++  if (section_name != NULL) {
++    set_has_section_name();
++  } else {
++    clear_has_section_name();
++  }
++  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++
++// optional uint32 num_jt_entries = 6;
++bool ReorderInfo_FixupInfo_FixupTuple::has_num_jt_entries() const {
++  return (_has_bits_[0] & 0x00000020u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_num_jt_entries() {
++  _has_bits_[0] |= 0x00000020u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_num_jt_entries() {
++  _has_bits_[0] &= ~0x00000020u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_num_jt_entries() {
++  num_jt_entries_ = 0u;
++  clear_has_num_jt_entries();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::num_jt_entries() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
++  return num_jt_entries_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_num_jt_entries(::google::protobuf::uint32 value) {
++  set_has_num_jt_entries();
++  num_jt_entries_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
++}
++
++// optional uint32 jt_entry_sz = 7;
++bool ReorderInfo_FixupInfo_FixupTuple::has_jt_entry_sz() const {
++  return (_has_bits_[0] & 0x00000040u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_jt_entry_sz() {
++  _has_bits_[0] |= 0x00000040u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_jt_entry_sz() {
++  _has_bits_[0] &= ~0x00000040u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_jt_entry_sz() {
++  jt_entry_sz_ = 0u;
++  clear_has_jt_entry_sz();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::jt_entry_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
++  return jt_entry_sz_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_jt_entry_sz(::google::protobuf::uint32 value) {
++  set_has_jt_entry_sz();
++  jt_entry_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_FixupInfo::kTextFieldNumber;
++const int ReorderInfo_FixupInfo::kRodataFieldNumber;
++const int ReorderInfo_FixupInfo::kDataFieldNumber;
++const int ReorderInfo_FixupInfo::kDatarelFieldNumber;
++const int ReorderInfo_FixupInfo::kInitarrayFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_FixupInfo::ReorderInfo_FixupInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.FixupInfo)
++}
++ReorderInfo_FixupInfo::ReorderInfo_FixupInfo(const ReorderInfo_FixupInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0),
++      text_(from.text_),
++      rodata_(from.rodata_),
++      data_(from.data_),
++      datarel_(from.datarel_),
++      initarray_(from.initarray_) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.FixupInfo)
++}
++
++void ReorderInfo_FixupInfo::SharedCtor() {
++  _cached_size_ = 0;
++}
++
++ReorderInfo_FixupInfo::~ReorderInfo_FixupInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.FixupInfo)
++  SharedDtor();
++}
++
++void ReorderInfo_FixupInfo::SharedDtor() {
++}
++
++void ReorderInfo_FixupInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_FixupInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[3].descriptor;
++}
++
++const ReorderInfo_FixupInfo& ReorderInfo_FixupInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_FixupInfo* ReorderInfo_FixupInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_FixupInfo* n = new ReorderInfo_FixupInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_FixupInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  text_.Clear();
++  rodata_.Clear();
++  data_.Clear();
++  datarel_.Clear();
++  initarray_.Clear();
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_FixupInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++      case 1: {
++        if (tag == 10u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_text()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++      case 2: {
++        if (tag == 18u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_rodata()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++      case 3: {
++        if (tag == 26u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_data()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++      case 4: {
++        if (tag == 34u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_datarel()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++      case 5: {
++        if (tag == 42u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_initarray()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.FixupInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.FixupInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_FixupInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++  for (unsigned int i = 0, n = this->text_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      1, this->text(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++  for (unsigned int i = 0, n = this->rodata_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      2, this->rodata(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      3, this->data(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++  for (unsigned int i = 0, n = this->datarel_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      4, this->datarel(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++  for (unsigned int i = 0, n = this->initarray_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      5, this->initarray(i), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.FixupInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo_FixupInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++  for (unsigned int i = 0, n = this->text_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        1, this->text(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++  for (unsigned int i = 0, n = this->rodata_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        2, this->rodata(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        3, this->data(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++  for (unsigned int i = 0, n = this->datarel_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        4, this->datarel(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++  for (unsigned int i = 0, n = this->initarray_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        5, this->initarray(i), false, target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.FixupInfo)
++  return target;
++}
++
++size_t ReorderInfo_FixupInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++  {
++    unsigned int count = this->text_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->text(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++  {
++    unsigned int count = this->rodata_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->rodata(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++  {
++    unsigned int count = this->data_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->data(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++  {
++    unsigned int count = this->datarel_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->datarel(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++  {
++    unsigned int count = this->initarray_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->initarray(i));
++    }
++  }
++
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_FixupInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_FixupInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_FixupInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.FixupInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.FixupInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_FixupInfo::MergeFrom(const ReorderInfo_FixupInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  text_.MergeFrom(from.text_);
++  rodata_.MergeFrom(from.rodata_);
++  data_.MergeFrom(from.data_);
++  datarel_.MergeFrom(from.datarel_);
++  initarray_.MergeFrom(from.initarray_);
++}
++
++void ReorderInfo_FixupInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_FixupInfo::CopyFrom(const ReorderInfo_FixupInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_FixupInfo::IsInitialized() const {
++  if (!::google::protobuf::internal::AllAreInitialized(this->text())) return false;
++  if (!::google::protobuf::internal::AllAreInitialized(this->rodata())) return false;
++  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
++  if (!::google::protobuf::internal::AllAreInitialized(this->datarel())) return false;
++  if (!::google::protobuf::internal::AllAreInitialized(this->initarray())) return false;
++  return true;
++}
++
++void ReorderInfo_FixupInfo::Swap(ReorderInfo_FixupInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_FixupInfo::InternalSwap(ReorderInfo_FixupInfo* other) {
++  text_.UnsafeArenaSwap(&other->text_);
++  rodata_.UnsafeArenaSwap(&other->rodata_);
++  data_.UnsafeArenaSwap(&other->data_);
++  datarel_.UnsafeArenaSwap(&other->datarel_);
++  initarray_.UnsafeArenaSwap(&other->initarray_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_FixupInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[3];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_FixupInfo
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++int ReorderInfo_FixupInfo::text_size() const {
++  return text_.size();
++}
++void ReorderInfo_FixupInfo::clear_text() {
++  text_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::text(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_text(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_text() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_text() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return &text_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::text() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++int ReorderInfo_FixupInfo::rodata_size() const {
++  return rodata_.size();
++}
++void ReorderInfo_FixupInfo::clear_rodata() {
++  rodata_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::rodata(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_rodata(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_rodata() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_rodata() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return &rodata_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::rodata() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++int ReorderInfo_FixupInfo::data_size() const {
++  return data_.size();
++}
++void ReorderInfo_FixupInfo::clear_data() {
++  data_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::data(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_data(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_data() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_data() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return &data_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::data() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++int ReorderInfo_FixupInfo::datarel_size() const {
++  return datarel_.size();
++}
++void ReorderInfo_FixupInfo::clear_datarel() {
++  datarel_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::datarel(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_datarel(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_datarel() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_datarel() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return &datarel_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::datarel() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++int ReorderInfo_FixupInfo::initarray_size() const {
++  return initarray_.size();
++}
++void ReorderInfo_FixupInfo::clear_initarray() {
++  initarray_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::initarray(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_initarray(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_initarray() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_initarray() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return &initarray_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::initarray() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_;
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_SourceInfo::kSrcTypeFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_SourceInfo::ReorderInfo_SourceInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.SourceInfo)
++}
++ReorderInfo_SourceInfo::ReorderInfo_SourceInfo(const ReorderInfo_SourceInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0),
++      src_type_(from.src_type_) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.SourceInfo)
++}
++
++void ReorderInfo_SourceInfo::SharedCtor() {
++  _cached_size_ = 0;
++}
++
++ReorderInfo_SourceInfo::~ReorderInfo_SourceInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.SourceInfo)
++  SharedDtor();
++}
++
++void ReorderInfo_SourceInfo::SharedDtor() {
++}
++
++void ReorderInfo_SourceInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_SourceInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[4].descriptor;
++}
++
++const ReorderInfo_SourceInfo& ReorderInfo_SourceInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_SourceInfo* ReorderInfo_SourceInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_SourceInfo* n = new ReorderInfo_SourceInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_SourceInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  src_type_.Clear();
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_SourceInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // repeated uint32 src_type = 1;
++      case 1: {
++        if (tag == 8u) {
++          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 1, 8u, input, this->mutable_src_type())));
++        } else if (tag == 10u) {
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, this->mutable_src_type())));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.SourceInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.SourceInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_SourceInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  // repeated uint32 src_type = 1;
++  for (int i = 0; i < this->src_type_size(); i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
++      1, this->src_type(i), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.SourceInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo_SourceInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  // repeated uint32 src_type = 1;
++  for (int i = 0; i < this->src_type_size(); i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      WriteUInt32ToArray(1, this->src_type(i), target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.SourceInfo)
++  return target;
++}
++
++size_t ReorderInfo_SourceInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  // repeated uint32 src_type = 1;
++  {
++    size_t data_size = 0;
++    unsigned int count = this->src_type_size();
++    for (unsigned int i = 0; i < count; i++) {
++      data_size += ::google::protobuf::internal::WireFormatLite::
++        UInt32Size(this->src_type(i));
++    }
++    total_size += 1 *
++                  ::google::protobuf::internal::FromIntSize(this->src_type_size());
++    total_size += data_size;
++  }
++
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_SourceInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_SourceInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_SourceInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.SourceInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.SourceInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_SourceInfo::MergeFrom(const ReorderInfo_SourceInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  src_type_.MergeFrom(from.src_type_);
++}
++
++void ReorderInfo_SourceInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_SourceInfo::CopyFrom(const ReorderInfo_SourceInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_SourceInfo::IsInitialized() const {
++  return true;
++}
++
++void ReorderInfo_SourceInfo::Swap(ReorderInfo_SourceInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_SourceInfo::InternalSwap(ReorderInfo_SourceInfo* other) {
++  src_type_.UnsafeArenaSwap(&other->src_type_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_SourceInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[4];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_SourceInfo
++
++// repeated uint32 src_type = 1;
++int ReorderInfo_SourceInfo::src_type_size() const {
++  return src_type_.size();
++}
++void ReorderInfo_SourceInfo::clear_src_type() {
++  src_type_.Clear();
++}
++::google::protobuf::uint32 ReorderInfo_SourceInfo::src_type(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return src_type_.Get(index);
++}
++void ReorderInfo_SourceInfo::set_src_type(int index, ::google::protobuf::uint32 value) {
++  src_type_.Set(index, value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++}
++void ReorderInfo_SourceInfo::add_src_type(::google::protobuf::uint32 value) {
++  src_type_.Add(value);
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++}
++const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
++ReorderInfo_SourceInfo::src_type() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return src_type_;
++}
++::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
++ReorderInfo_SourceInfo::mutable_src_type() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return &src_type_;
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo::kBinFieldNumber;
++const int ReorderInfo::kLayoutFieldNumber;
++const int ReorderInfo::kFixupFieldNumber;
++const int ReorderInfo::kSourceFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo::ReorderInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo)
++}
++ReorderInfo::ReorderInfo(const ReorderInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0),
++      layout_(from.layout_),
++      fixup_(from.fixup_) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  if (from.has_bin()) {
++    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo(*from.bin_);
++  } else {
++    bin_ = NULL;
++  }
++  if (from.has_source()) {
++    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo(*from.source_);
++  } else {
++    source_ = NULL;
++  }
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo)
++}
++
++void ReorderInfo::SharedCtor() {
++  _cached_size_ = 0;
++  ::memset(&bin_, 0, reinterpret_cast<char*>(&source_) -
++    reinterpret_cast<char*>(&bin_) + sizeof(source_));
++}
++
++ReorderInfo::~ReorderInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo)
++  SharedDtor();
++}
++
++void ReorderInfo::SharedDtor() {
++  if (this != internal_default_instance()) {
++    delete bin_;
++  }
++  if (this != internal_default_instance()) {
++    delete source_;
++  }
++}
++
++void ReorderInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[5].descriptor;
++}
++
++const ReorderInfo& ReorderInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo* ReorderInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo* n = new ReorderInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo)
++  layout_.Clear();
++  fixup_.Clear();
++  if (_has_bits_[0 / 32] & 3u) {
++    if (has_bin()) {
++      GOOGLE_DCHECK(bin_ != NULL);
++      bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
++    }
++    if (has_source()) {
++      GOOGLE_DCHECK(source_ != NULL);
++      source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
++    }
++  }
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++      case 1: {
++        if (tag == 10u) {
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
++               input, mutable_bin()));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++      case 2: {
++        if (tag == 18u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_layout()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++      case 3: {
++        if (tag == 26u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_fixup()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++      case 4: {
++        if (tag == 34u) {
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
++               input, mutable_source()));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo)
++  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++  if (has_bin()) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      1, *this->bin_, output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++  for (unsigned int i = 0, n = this->layout_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      2, this->layout(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++  for (unsigned int i = 0, n = this->fixup_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      3, this->fixup(i), output);
++  }
++
++  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++  if (has_source()) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      4, *this->source_, output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo)
++  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++  if (has_bin()) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        1, *this->bin_, false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++  for (unsigned int i = 0, n = this->layout_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        2, this->layout(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++  for (unsigned int i = 0, n = this->fixup_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        3, this->fixup(i), false, target);
++  }
++
++  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++  if (has_source()) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        4, *this->source_, false, target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo)
++  return target;
++}
++
++size_t ReorderInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++  {
++    unsigned int count = this->layout_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->layout(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++  {
++    unsigned int count = this->fixup_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->fixup(i));
++    }
++  }
++
++  if (_has_bits_[0 / 32] & 3u) {
++    // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++    if (has_bin()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          *this->bin_);
++    }
++
++    // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++    if (has_source()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          *this->source_);
++    }
++
++  }
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo::MergeFrom(const ReorderInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  layout_.MergeFrom(from.layout_);
++  fixup_.MergeFrom(from.fixup_);
++  if (from._has_bits_[0 / 32] & 3u) {
++    if (from.has_bin()) {
++      mutable_bin()->::ShuffleInfo::ReorderInfo_BinaryInfo::MergeFrom(from.bin());
++    }
++    if (from.has_source()) {
++      mutable_source()->::ShuffleInfo::ReorderInfo_SourceInfo::MergeFrom(from.source());
++    }
++  }
++}
++
++void ReorderInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo::CopyFrom(const ReorderInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo::IsInitialized() const {
++  if (!::google::protobuf::internal::AllAreInitialized(this->fixup())) return false;
++  return true;
++}
++
++void ReorderInfo::Swap(ReorderInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo::InternalSwap(ReorderInfo* other) {
++  layout_.UnsafeArenaSwap(&other->layout_);
++  fixup_.UnsafeArenaSwap(&other->fixup_);
++  std::swap(bin_, other->bin_);
++  std::swap(source_, other->source_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[5];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo
++
++// optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++bool ReorderInfo::has_bin() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++void ReorderInfo::set_has_bin() {
++  _has_bits_[0] |= 0x00000001u;
++}
++void ReorderInfo::clear_has_bin() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++void ReorderInfo::clear_bin() {
++  if (bin_ != NULL) bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
++  clear_has_bin();
++}
++const ::ShuffleInfo::ReorderInfo_BinaryInfo& ReorderInfo::bin() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.bin)
++  return bin_ != NULL ? *bin_
++                         : *::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance();
++}
++::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::mutable_bin() {
++  set_has_bin();
++  if (bin_ == NULL) {
++    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo;
++  }
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.bin)
++  return bin_;
++}
++::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::release_bin() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.bin)
++  clear_has_bin();
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* temp = bin_;
++  bin_ = NULL;
++  return temp;
++}
++void ReorderInfo::set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin) {
++  delete bin_;
++  bin_ = bin;
++  if (bin) {
++    set_has_bin();
++  } else {
++    clear_has_bin();
++  }
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.bin)
++}
++
++// repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++int ReorderInfo::layout_size() const {
++  return layout_.size();
++}
++void ReorderInfo::clear_layout() {
++  layout_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_LayoutInfo& ReorderInfo::layout(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::mutable_layout(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::add_layout() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
++ReorderInfo::mutable_layout() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.layout)
++  return &layout_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
++ReorderInfo::layout() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.layout)
++  return layout_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++int ReorderInfo::fixup_size() const {
++  return fixup_.size();
++}
++void ReorderInfo::clear_fixup() {
++  fixup_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo& ReorderInfo::fixup(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::mutable_fixup(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::add_fixup() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
++ReorderInfo::mutable_fixup() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.fixup)
++  return &fixup_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
++ReorderInfo::fixup() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_;
++}
++
++// optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++bool ReorderInfo::has_source() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++void ReorderInfo::set_has_source() {
++  _has_bits_[0] |= 0x00000002u;
++}
++void ReorderInfo::clear_has_source() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++void ReorderInfo::clear_source() {
++  if (source_ != NULL) source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
++  clear_has_source();
++}
++const ::ShuffleInfo::ReorderInfo_SourceInfo& ReorderInfo::source() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.source)
++  return source_ != NULL ? *source_
++                         : *::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance();
++}
++::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::mutable_source() {
++  set_has_source();
++  if (source_ == NULL) {
++    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo;
++  }
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.source)
++  return source_;
++}
++::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::release_source() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.source)
++  clear_has_source();
++  ::ShuffleInfo::ReorderInfo_SourceInfo* temp = source_;
++  source_ = NULL;
++  return temp;
++}
++void ReorderInfo::set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source) {
++  delete source_;
++  source_ = source;
++  if (source) {
++    set_has_source();
++  } else {
++    clear_has_source();
++  }
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.source)
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// @@protoc_insertion_point(namespace_scope)
++
++}  // namespace ShuffleInfo
++
++// @@protoc_insertion_point(global_scope)
+diff --git a/shuffleInfo.pb.h b/shuffleInfo.pb.h
+new file mode 100644
+index 0000000..aea266f
+--- /dev/null
++++ b/shuffleInfo.pb.h
+@@ -0,0 +1,1771 @@
++// Generated by the protocol buffer compiler.  DO NOT EDIT!
++// source: shuffleInfo.proto
++
++#ifndef PROTOBUF_shuffleInfo_2eproto__INCLUDED
++#define PROTOBUF_shuffleInfo_2eproto__INCLUDED
++
++#include <string>
++
++#include <google/protobuf/stubs/common.h>
++
++#if GOOGLE_PROTOBUF_VERSION < 3001000
++#error This file was generated by a newer version of protoc which is
++#error incompatible with your Protocol Buffer headers.  Please update
++#error your headers.
++#endif
++#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
++#error This file was generated by an older version of protoc which is
++#error incompatible with your Protocol Buffer headers.  Please
++#error regenerate this file with a newer version of protoc.
++#endif
++
++#include <google/protobuf/arena.h>
++#include <google/protobuf/arenastring.h>
++#include <google/protobuf/generated_message_util.h>
++#include <google/protobuf/metadata.h>
++#include <google/protobuf/message.h>
++#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
++#include <google/protobuf/extension_set.h>  // IWYU pragma: export
++#include <google/protobuf/unknown_field_set.h>
++// @@protoc_insertion_point(includes)
++namespace ShuffleInfo {
++class ReorderInfo;
++class ReorderInfoDefaultTypeInternal;
++extern ReorderInfoDefaultTypeInternal _ReorderInfo_default_instance_;
++class ReorderInfo_BinaryInfo;
++class ReorderInfo_BinaryInfoDefaultTypeInternal;
++extern ReorderInfo_BinaryInfoDefaultTypeInternal _ReorderInfo_BinaryInfo_default_instance_;
++class ReorderInfo_FixupInfo;
++class ReorderInfo_FixupInfoDefaultTypeInternal;
++extern ReorderInfo_FixupInfoDefaultTypeInternal _ReorderInfo_FixupInfo_default_instance_;
++class ReorderInfo_FixupInfo_FixupTuple;
++class ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal;
++extern ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal _ReorderInfo_FixupInfo_FixupTuple_default_instance_;
++class ReorderInfo_LayoutInfo;
++class ReorderInfo_LayoutInfoDefaultTypeInternal;
++extern ReorderInfo_LayoutInfoDefaultTypeInternal _ReorderInfo_LayoutInfo_default_instance_;
++class ReorderInfo_SourceInfo;
++class ReorderInfo_SourceInfoDefaultTypeInternal;
++extern ReorderInfo_SourceInfoDefaultTypeInternal _ReorderInfo_SourceInfo_default_instance_;
++}  // namespace ShuffleInfo
++
++namespace ShuffleInfo {
++
++// Internal implementation detail -- do not call these.
++void protobuf_AddDesc_shuffleInfo_2eproto();
++void protobuf_InitDefaults_shuffleInfo_2eproto();
++
++// ===================================================================
++
++class ReorderInfo_BinaryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.BinaryInfo) */ {
++ public:
++  ReorderInfo_BinaryInfo();
++  virtual ~ReorderInfo_BinaryInfo();
++
++  ReorderInfo_BinaryInfo(const ReorderInfo_BinaryInfo& from);
++
++  inline ReorderInfo_BinaryInfo& operator=(const ReorderInfo_BinaryInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_BinaryInfo& default_instance();
++
++  static inline const ReorderInfo_BinaryInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_BinaryInfo*>(
++               &_ReorderInfo_BinaryInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo_BinaryInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_BinaryInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_BinaryInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_BinaryInfo& from);
++  void MergeFrom(const ReorderInfo_BinaryInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_BinaryInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  // accessors -------------------------------------------------------
++
++  // optional uint32 rand_obj_offset = 1;
++  bool has_rand_obj_offset() const;
++  void clear_rand_obj_offset();
++  static const int kRandObjOffsetFieldNumber = 1;
++  ::google::protobuf::uint32 rand_obj_offset() const;
++  void set_rand_obj_offset(::google::protobuf::uint32 value);
++
++  // optional uint32 main_addr_offset = 2;
++  bool has_main_addr_offset() const;
++  void clear_main_addr_offset();
++  static const int kMainAddrOffsetFieldNumber = 2;
++  ::google::protobuf::uint32 main_addr_offset() const;
++  void set_main_addr_offset(::google::protobuf::uint32 value);
++
++  // optional uint32 obj_sz = 3;
++  bool has_obj_sz() const;
++  void clear_obj_sz();
++  static const int kObjSzFieldNumber = 3;
++  ::google::protobuf::uint32 obj_sz() const;
++  void set_obj_sz(::google::protobuf::uint32 value);
++
++  // optional uint32 src_type = 4;
++  bool has_src_type() const;
++  void clear_src_type();
++  static const int kSrcTypeFieldNumber = 4;
++  ::google::protobuf::uint32 src_type() const;
++  void set_src_type(::google::protobuf::uint32 value);
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.BinaryInfo)
++ private:
++  void set_has_rand_obj_offset();
++  void clear_has_rand_obj_offset();
++  void set_has_main_addr_offset();
++  void clear_has_main_addr_offset();
++  void set_has_obj_sz();
++  void clear_has_obj_sz();
++  void set_has_src_type();
++  void clear_has_src_type();
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::uint32 rand_obj_offset_;
++  ::google::protobuf::uint32 main_addr_offset_;
++  ::google::protobuf::uint32 obj_sz_;
++  ::google::protobuf::uint32 src_type_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo_LayoutInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.LayoutInfo) */ {
++ public:
++  ReorderInfo_LayoutInfo();
++  virtual ~ReorderInfo_LayoutInfo();
++
++  ReorderInfo_LayoutInfo(const ReorderInfo_LayoutInfo& from);
++
++  inline ReorderInfo_LayoutInfo& operator=(const ReorderInfo_LayoutInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_LayoutInfo& default_instance();
++
++  static inline const ReorderInfo_LayoutInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_LayoutInfo*>(
++               &_ReorderInfo_LayoutInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo_LayoutInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_LayoutInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_LayoutInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_LayoutInfo& from);
++  void MergeFrom(const ReorderInfo_LayoutInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_LayoutInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  // accessors -------------------------------------------------------
++
++  // optional uint32 bb_size = 1;
++  bool has_bb_size() const;
++  void clear_bb_size();
++  static const int kBbSizeFieldNumber = 1;
++  ::google::protobuf::uint32 bb_size() const;
++  void set_bb_size(::google::protobuf::uint32 value);
++
++  // optional uint32 type = 2;
++  bool has_type() const;
++  void clear_type();
++  static const int kTypeFieldNumber = 2;
++  ::google::protobuf::uint32 type() const;
++  void set_type(::google::protobuf::uint32 value);
++
++  // optional uint32 num_fixups = 3;
++  bool has_num_fixups() const;
++  void clear_num_fixups();
++  static const int kNumFixupsFieldNumber = 3;
++  ::google::protobuf::uint32 num_fixups() const;
++  void set_num_fixups(::google::protobuf::uint32 value);
++
++  // optional bool bb_fallthrough = 4;
++  bool has_bb_fallthrough() const;
++  void clear_bb_fallthrough();
++  static const int kBbFallthroughFieldNumber = 4;
++  bool bb_fallthrough() const;
++  void set_bb_fallthrough(bool value);
++
++  // optional string section_name = 5;
++  bool has_section_name() const;
++  void clear_section_name();
++  static const int kSectionNameFieldNumber = 5;
++  const ::std::string& section_name() const;
++  void set_section_name(const ::std::string& value);
++  #if LANG_CXX11
++  void set_section_name(::std::string&& value);
++  #endif
++  void set_section_name(const char* value);
++  void set_section_name(const char* value, size_t size);
++  ::std::string* mutable_section_name();
++  ::std::string* release_section_name();
++  void set_allocated_section_name(::std::string* section_name);
++
++  // optional uint32 offset = 6;
++  bool has_offset() const;
++  void clear_offset();
++  static const int kOffsetFieldNumber = 6;
++  ::google::protobuf::uint32 offset() const;
++  void set_offset(::google::protobuf::uint32 value);
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.LayoutInfo)
++ private:
++  void set_has_bb_size();
++  void clear_has_bb_size();
++  void set_has_type();
++  void clear_has_type();
++  void set_has_num_fixups();
++  void clear_has_num_fixups();
++  void set_has_bb_fallthrough();
++  void clear_has_bb_fallthrough();
++  void set_has_section_name();
++  void clear_has_section_name();
++  void set_has_offset();
++  void clear_has_offset();
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::internal::ArenaStringPtr section_name_;
++  ::google::protobuf::uint32 bb_size_;
++  ::google::protobuf::uint32 type_;
++  ::google::protobuf::uint32 num_fixups_;
++  bool bb_fallthrough_;
++  ::google::protobuf::uint32 offset_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo_FixupInfo_FixupTuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple) */ {
++ public:
++  ReorderInfo_FixupInfo_FixupTuple();
++  virtual ~ReorderInfo_FixupInfo_FixupTuple();
++
++  ReorderInfo_FixupInfo_FixupTuple(const ReorderInfo_FixupInfo_FixupTuple& from);
++
++  inline ReorderInfo_FixupInfo_FixupTuple& operator=(const ReorderInfo_FixupInfo_FixupTuple& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_FixupInfo_FixupTuple& default_instance();
++
++  static inline const ReorderInfo_FixupInfo_FixupTuple* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_FixupInfo_FixupTuple*>(
++               &_ReorderInfo_FixupInfo_FixupTuple_default_instance_);
++  }
++
++  void Swap(ReorderInfo_FixupInfo_FixupTuple* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_FixupInfo_FixupTuple* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_FixupInfo_FixupTuple* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_FixupInfo_FixupTuple& from);
++  void MergeFrom(const ReorderInfo_FixupInfo_FixupTuple& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_FixupInfo_FixupTuple* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  // accessors -------------------------------------------------------
++
++  // required uint32 offset = 1;
++  bool has_offset() const;
++  void clear_offset();
++  static const int kOffsetFieldNumber = 1;
++  ::google::protobuf::uint32 offset() const;
++  void set_offset(::google::protobuf::uint32 value);
++
++  // required uint32 deref_sz = 2;
++  bool has_deref_sz() const;
++  void clear_deref_sz();
++  static const int kDerefSzFieldNumber = 2;
++  ::google::protobuf::uint32 deref_sz() const;
++  void set_deref_sz(::google::protobuf::uint32 value);
++
++  // required bool is_rela = 3;
++  bool has_is_rela() const;
++  void clear_is_rela();
++  static const int kIsRelaFieldNumber = 3;
++  bool is_rela() const;
++  void set_is_rela(bool value);
++
++  // optional uint32 type = 4;
++  bool has_type() const;
++  void clear_type();
++  static const int kTypeFieldNumber = 4;
++  ::google::protobuf::uint32 type() const;
++  void set_type(::google::protobuf::uint32 value);
++
++  // optional string section_name = 5;
++  bool has_section_name() const;
++  void clear_section_name();
++  static const int kSectionNameFieldNumber = 5;
++  const ::std::string& section_name() const;
++  void set_section_name(const ::std::string& value);
++  #if LANG_CXX11
++  void set_section_name(::std::string&& value);
++  #endif
++  void set_section_name(const char* value);
++  void set_section_name(const char* value, size_t size);
++  ::std::string* mutable_section_name();
++  ::std::string* release_section_name();
++  void set_allocated_section_name(::std::string* section_name);
++
++  // optional uint32 num_jt_entries = 6;
++  bool has_num_jt_entries() const;
++  void clear_num_jt_entries();
++  static const int kNumJtEntriesFieldNumber = 6;
++  ::google::protobuf::uint32 num_jt_entries() const;
++  void set_num_jt_entries(::google::protobuf::uint32 value);
++
++  // optional uint32 jt_entry_sz = 7;
++  bool has_jt_entry_sz() const;
++  void clear_jt_entry_sz();
++  static const int kJtEntrySzFieldNumber = 7;
++  ::google::protobuf::uint32 jt_entry_sz() const;
++  void set_jt_entry_sz(::google::protobuf::uint32 value);
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++ private:
++  void set_has_offset();
++  void clear_has_offset();
++  void set_has_deref_sz();
++  void clear_has_deref_sz();
++  void set_has_is_rela();
++  void clear_has_is_rela();
++  void set_has_type();
++  void clear_has_type();
++  void set_has_section_name();
++  void clear_has_section_name();
++  void set_has_num_jt_entries();
++  void clear_has_num_jt_entries();
++  void set_has_jt_entry_sz();
++  void clear_has_jt_entry_sz();
++
++  // helper for ByteSizeLong()
++  size_t RequiredFieldsByteSizeFallback() const;
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::internal::ArenaStringPtr section_name_;
++  ::google::protobuf::uint32 offset_;
++  ::google::protobuf::uint32 deref_sz_;
++  bool is_rela_;
++  ::google::protobuf::uint32 type_;
++  ::google::protobuf::uint32 num_jt_entries_;
++  ::google::protobuf::uint32 jt_entry_sz_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo_FixupInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.FixupInfo) */ {
++ public:
++  ReorderInfo_FixupInfo();
++  virtual ~ReorderInfo_FixupInfo();
++
++  ReorderInfo_FixupInfo(const ReorderInfo_FixupInfo& from);
++
++  inline ReorderInfo_FixupInfo& operator=(const ReorderInfo_FixupInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_FixupInfo& default_instance();
++
++  static inline const ReorderInfo_FixupInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_FixupInfo*>(
++               &_ReorderInfo_FixupInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo_FixupInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_FixupInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_FixupInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_FixupInfo& from);
++  void MergeFrom(const ReorderInfo_FixupInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_FixupInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  typedef ReorderInfo_FixupInfo_FixupTuple FixupTuple;
++
++  // accessors -------------------------------------------------------
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++  int text_size() const;
++  void clear_text();
++  static const int kTextFieldNumber = 1;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& text(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_text(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_text();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_text();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      text() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++  int rodata_size() const;
++  void clear_rodata();
++  static const int kRodataFieldNumber = 2;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& rodata(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_rodata(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_rodata();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_rodata();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      rodata() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++  int data_size() const;
++  void clear_data();
++  static const int kDataFieldNumber = 3;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& data(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_data(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_data();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_data();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      data() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++  int datarel_size() const;
++  void clear_datarel();
++  static const int kDatarelFieldNumber = 4;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& datarel(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_datarel(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_datarel();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_datarel();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      datarel() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++  int initarray_size() const;
++  void clear_initarray();
++  static const int kInitarrayFieldNumber = 5;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& initarray(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_initarray(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_initarray();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_initarray();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      initarray() const;
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.FixupInfo)
++ private:
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > text_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > rodata_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > data_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > datarel_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > initarray_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo_SourceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.SourceInfo) */ {
++ public:
++  ReorderInfo_SourceInfo();
++  virtual ~ReorderInfo_SourceInfo();
++
++  ReorderInfo_SourceInfo(const ReorderInfo_SourceInfo& from);
++
++  inline ReorderInfo_SourceInfo& operator=(const ReorderInfo_SourceInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_SourceInfo& default_instance();
++
++  static inline const ReorderInfo_SourceInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_SourceInfo*>(
++               &_ReorderInfo_SourceInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo_SourceInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_SourceInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_SourceInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_SourceInfo& from);
++  void MergeFrom(const ReorderInfo_SourceInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_SourceInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  // accessors -------------------------------------------------------
++
++  // repeated uint32 src_type = 1;
++  int src_type_size() const;
++  void clear_src_type();
++  static const int kSrcTypeFieldNumber = 1;
++  ::google::protobuf::uint32 src_type(int index) const;
++  void set_src_type(int index, ::google::protobuf::uint32 value);
++  void add_src_type(::google::protobuf::uint32 value);
++  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
++      src_type() const;
++  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
++      mutable_src_type();
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.SourceInfo)
++ private:
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > src_type_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo) */ {
++ public:
++  ReorderInfo();
++  virtual ~ReorderInfo();
++
++  ReorderInfo(const ReorderInfo& from);
++
++  inline ReorderInfo& operator=(const ReorderInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo& default_instance();
++
++  static inline const ReorderInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo*>(
++               &_ReorderInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo& from);
++  void MergeFrom(const ReorderInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  typedef ReorderInfo_BinaryInfo BinaryInfo;
++  typedef ReorderInfo_LayoutInfo LayoutInfo;
++  typedef ReorderInfo_FixupInfo FixupInfo;
++  typedef ReorderInfo_SourceInfo SourceInfo;
++
++  // accessors -------------------------------------------------------
++
++  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++  bool has_bin() const;
++  void clear_bin();
++  static const int kBinFieldNumber = 1;
++  const ::ShuffleInfo::ReorderInfo_BinaryInfo& bin() const;
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* mutable_bin();
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* release_bin();
++  void set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin);
++
++  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++  int layout_size() const;
++  void clear_layout();
++  static const int kLayoutFieldNumber = 2;
++  const ::ShuffleInfo::ReorderInfo_LayoutInfo& layout(int index) const;
++  ::ShuffleInfo::ReorderInfo_LayoutInfo* mutable_layout(int index);
++  ::ShuffleInfo::ReorderInfo_LayoutInfo* add_layout();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
++      mutable_layout();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
++      layout() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++  int fixup_size() const;
++  void clear_fixup();
++  static const int kFixupFieldNumber = 3;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo& fixup(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo* mutable_fixup(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo* add_fixup();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
++      mutable_fixup();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
++      fixup() const;
++
++  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++  bool has_source() const;
++  void clear_source();
++  static const int kSourceFieldNumber = 4;
++  const ::ShuffleInfo::ReorderInfo_SourceInfo& source() const;
++  ::ShuffleInfo::ReorderInfo_SourceInfo* mutable_source();
++  ::ShuffleInfo::ReorderInfo_SourceInfo* release_source();
++  void set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source);
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo)
++ private:
++  void set_has_bin();
++  void clear_has_bin();
++  void set_has_source();
++  void clear_has_source();
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo > layout_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo > fixup_;
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* bin_;
++  ::ShuffleInfo::ReorderInfo_SourceInfo* source_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// ===================================================================
++
++
++// ===================================================================
++
++#if !PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_BinaryInfo
++
++// optional uint32 rand_obj_offset = 1;
++inline bool ReorderInfo_BinaryInfo::has_rand_obj_offset() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++inline void ReorderInfo_BinaryInfo::set_has_rand_obj_offset() {
++  _has_bits_[0] |= 0x00000001u;
++}
++inline void ReorderInfo_BinaryInfo::clear_has_rand_obj_offset() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++inline void ReorderInfo_BinaryInfo::clear_rand_obj_offset() {
++  rand_obj_offset_ = 0u;
++  clear_has_rand_obj_offset();
++}
++inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::rand_obj_offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
++  return rand_obj_offset_;
++}
++inline void ReorderInfo_BinaryInfo::set_rand_obj_offset(::google::protobuf::uint32 value) {
++  set_has_rand_obj_offset();
++  rand_obj_offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
++}
++
++// optional uint32 main_addr_offset = 2;
++inline bool ReorderInfo_BinaryInfo::has_main_addr_offset() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++inline void ReorderInfo_BinaryInfo::set_has_main_addr_offset() {
++  _has_bits_[0] |= 0x00000002u;
++}
++inline void ReorderInfo_BinaryInfo::clear_has_main_addr_offset() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++inline void ReorderInfo_BinaryInfo::clear_main_addr_offset() {
++  main_addr_offset_ = 0u;
++  clear_has_main_addr_offset();
++}
++inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::main_addr_offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
++  return main_addr_offset_;
++}
++inline void ReorderInfo_BinaryInfo::set_main_addr_offset(::google::protobuf::uint32 value) {
++  set_has_main_addr_offset();
++  main_addr_offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
++}
++
++// optional uint32 obj_sz = 3;
++inline bool ReorderInfo_BinaryInfo::has_obj_sz() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++inline void ReorderInfo_BinaryInfo::set_has_obj_sz() {
++  _has_bits_[0] |= 0x00000004u;
++}
++inline void ReorderInfo_BinaryInfo::clear_has_obj_sz() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++inline void ReorderInfo_BinaryInfo::clear_obj_sz() {
++  obj_sz_ = 0u;
++  clear_has_obj_sz();
++}
++inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::obj_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
++  return obj_sz_;
++}
++inline void ReorderInfo_BinaryInfo::set_obj_sz(::google::protobuf::uint32 value) {
++  set_has_obj_sz();
++  obj_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
++}
++
++// optional uint32 src_type = 4;
++inline bool ReorderInfo_BinaryInfo::has_src_type() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++inline void ReorderInfo_BinaryInfo::set_has_src_type() {
++  _has_bits_[0] |= 0x00000008u;
++}
++inline void ReorderInfo_BinaryInfo::clear_has_src_type() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++inline void ReorderInfo_BinaryInfo::clear_src_type() {
++  src_type_ = 0u;
++  clear_has_src_type();
++}
++inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::src_type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
++  return src_type_;
++}
++inline void ReorderInfo_BinaryInfo::set_src_type(::google::protobuf::uint32 value) {
++  set_has_src_type();
++  src_type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo_LayoutInfo
++
++// optional uint32 bb_size = 1;
++inline bool ReorderInfo_LayoutInfo::has_bb_size() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_bb_size() {
++  _has_bits_[0] |= 0x00000002u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_bb_size() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++inline void ReorderInfo_LayoutInfo::clear_bb_size() {
++  bb_size_ = 0u;
++  clear_has_bb_size();
++}
++inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::bb_size() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
++  return bb_size_;
++}
++inline void ReorderInfo_LayoutInfo::set_bb_size(::google::protobuf::uint32 value) {
++  set_has_bb_size();
++  bb_size_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
++}
++
++// optional uint32 type = 2;
++inline bool ReorderInfo_LayoutInfo::has_type() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_type() {
++  _has_bits_[0] |= 0x00000004u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_type() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++inline void ReorderInfo_LayoutInfo::clear_type() {
++  type_ = 0u;
++  clear_has_type();
++}
++inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.type)
++  return type_;
++}
++inline void ReorderInfo_LayoutInfo::set_type(::google::protobuf::uint32 value) {
++  set_has_type();
++  type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.type)
++}
++
++// optional uint32 num_fixups = 3;
++inline bool ReorderInfo_LayoutInfo::has_num_fixups() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_num_fixups() {
++  _has_bits_[0] |= 0x00000008u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_num_fixups() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++inline void ReorderInfo_LayoutInfo::clear_num_fixups() {
++  num_fixups_ = 0u;
++  clear_has_num_fixups();
++}
++inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::num_fixups() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
++  return num_fixups_;
++}
++inline void ReorderInfo_LayoutInfo::set_num_fixups(::google::protobuf::uint32 value) {
++  set_has_num_fixups();
++  num_fixups_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
++}
++
++// optional bool bb_fallthrough = 4;
++inline bool ReorderInfo_LayoutInfo::has_bb_fallthrough() const {
++  return (_has_bits_[0] & 0x00000010u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_bb_fallthrough() {
++  _has_bits_[0] |= 0x00000010u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_bb_fallthrough() {
++  _has_bits_[0] &= ~0x00000010u;
++}
++inline void ReorderInfo_LayoutInfo::clear_bb_fallthrough() {
++  bb_fallthrough_ = false;
++  clear_has_bb_fallthrough();
++}
++inline bool ReorderInfo_LayoutInfo::bb_fallthrough() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
++  return bb_fallthrough_;
++}
++inline void ReorderInfo_LayoutInfo::set_bb_fallthrough(bool value) {
++  set_has_bb_fallthrough();
++  bb_fallthrough_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
++}
++
++// optional string section_name = 5;
++inline bool ReorderInfo_LayoutInfo::has_section_name() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_section_name() {
++  _has_bits_[0] |= 0x00000001u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_section_name() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++inline void ReorderInfo_LayoutInfo::clear_section_name() {
++  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  clear_has_section_name();
++}
++inline const ::std::string& ReorderInfo_LayoutInfo::section_name() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  return section_name_.GetNoArena();
++}
++inline void ReorderInfo_LayoutInfo::set_section_name(const ::std::string& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++#if LANG_CXX11
++inline void ReorderInfo_LayoutInfo::set_section_name(::std::string&& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(
++    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
++  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++#endif
++inline void ReorderInfo_LayoutInfo::set_section_name(const char* value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
++  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++inline void ReorderInfo_LayoutInfo::set_section_name(const char* value, size_t size) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
++      ::std::string(reinterpret_cast<const char*>(value), size));
++  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++inline ::std::string* ReorderInfo_LayoutInfo::mutable_section_name() {
++  set_has_section_name();
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++inline ::std::string* ReorderInfo_LayoutInfo::release_section_name() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  clear_has_section_name();
++  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++inline void ReorderInfo_LayoutInfo::set_allocated_section_name(::std::string* section_name) {
++  if (section_name != NULL) {
++    set_has_section_name();
++  } else {
++    clear_has_section_name();
++  }
++  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++
++// optional uint32 offset = 6;
++inline bool ReorderInfo_LayoutInfo::has_offset() const {
++  return (_has_bits_[0] & 0x00000020u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_offset() {
++  _has_bits_[0] |= 0x00000020u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_offset() {
++  _has_bits_[0] &= ~0x00000020u;
++}
++inline void ReorderInfo_LayoutInfo::clear_offset() {
++  offset_ = 0u;
++  clear_has_offset();
++}
++inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
++  return offset_;
++}
++inline void ReorderInfo_LayoutInfo::set_offset(::google::protobuf::uint32 value) {
++  set_has_offset();
++  offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo_FixupInfo_FixupTuple
++
++// required uint32 offset = 1;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_offset() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_offset() {
++  _has_bits_[0] |= 0x00000002u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_offset() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_offset() {
++  offset_ = 0u;
++  clear_has_offset();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
++  return offset_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_offset(::google::protobuf::uint32 value) {
++  set_has_offset();
++  offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
++}
++
++// required uint32 deref_sz = 2;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_deref_sz() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_deref_sz() {
++  _has_bits_[0] |= 0x00000004u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_deref_sz() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_deref_sz() {
++  deref_sz_ = 0u;
++  clear_has_deref_sz();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::deref_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
++  return deref_sz_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_deref_sz(::google::protobuf::uint32 value) {
++  set_has_deref_sz();
++  deref_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
++}
++
++// required bool is_rela = 3;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_is_rela() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_is_rela() {
++  _has_bits_[0] |= 0x00000008u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_is_rela() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_is_rela() {
++  is_rela_ = false;
++  clear_has_is_rela();
++}
++inline bool ReorderInfo_FixupInfo_FixupTuple::is_rela() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
++  return is_rela_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_is_rela(bool value) {
++  set_has_is_rela();
++  is_rela_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
++}
++
++// optional uint32 type = 4;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_type() const {
++  return (_has_bits_[0] & 0x00000010u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_type() {
++  _has_bits_[0] |= 0x00000010u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_type() {
++  _has_bits_[0] &= ~0x00000010u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_type() {
++  type_ = 0u;
++  clear_has_type();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
++  return type_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_type(::google::protobuf::uint32 value) {
++  set_has_type();
++  type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
++}
++
++// optional string section_name = 5;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_section_name() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_section_name() {
++  _has_bits_[0] |= 0x00000001u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_section_name() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_section_name() {
++  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  clear_has_section_name();
++}
++inline const ::std::string& ReorderInfo_FixupInfo_FixupTuple::section_name() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  return section_name_.GetNoArena();
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const ::std::string& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++#if LANG_CXX11
++inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(::std::string&& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(
++    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
++  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++#endif
++inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
++  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value, size_t size) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
++      ::std::string(reinterpret_cast<const char*>(value), size));
++  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++inline ::std::string* ReorderInfo_FixupInfo_FixupTuple::mutable_section_name() {
++  set_has_section_name();
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++inline ::std::string* ReorderInfo_FixupInfo_FixupTuple::release_section_name() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  clear_has_section_name();
++  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_allocated_section_name(::std::string* section_name) {
++  if (section_name != NULL) {
++    set_has_section_name();
++  } else {
++    clear_has_section_name();
++  }
++  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++
++// optional uint32 num_jt_entries = 6;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_num_jt_entries() const {
++  return (_has_bits_[0] & 0x00000020u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_num_jt_entries() {
++  _has_bits_[0] |= 0x00000020u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_num_jt_entries() {
++  _has_bits_[0] &= ~0x00000020u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_num_jt_entries() {
++  num_jt_entries_ = 0u;
++  clear_has_num_jt_entries();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::num_jt_entries() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
++  return num_jt_entries_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_num_jt_entries(::google::protobuf::uint32 value) {
++  set_has_num_jt_entries();
++  num_jt_entries_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
++}
++
++// optional uint32 jt_entry_sz = 7;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_jt_entry_sz() const {
++  return (_has_bits_[0] & 0x00000040u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_jt_entry_sz() {
++  _has_bits_[0] |= 0x00000040u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_jt_entry_sz() {
++  _has_bits_[0] &= ~0x00000040u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_jt_entry_sz() {
++  jt_entry_sz_ = 0u;
++  clear_has_jt_entry_sz();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::jt_entry_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
++  return jt_entry_sz_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_jt_entry_sz(::google::protobuf::uint32 value) {
++  set_has_jt_entry_sz();
++  jt_entry_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo_FixupInfo
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++inline int ReorderInfo_FixupInfo::text_size() const {
++  return text_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_text() {
++  text_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::text(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_text(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_text() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_text() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return &text_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::text() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++inline int ReorderInfo_FixupInfo::rodata_size() const {
++  return rodata_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_rodata() {
++  rodata_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::rodata(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_rodata(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_rodata() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_rodata() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return &rodata_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::rodata() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++inline int ReorderInfo_FixupInfo::data_size() const {
++  return data_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_data() {
++  data_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::data(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_data(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_data() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_data() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return &data_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::data() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++inline int ReorderInfo_FixupInfo::datarel_size() const {
++  return datarel_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_datarel() {
++  datarel_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::datarel(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_datarel(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_datarel() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_datarel() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return &datarel_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::datarel() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++inline int ReorderInfo_FixupInfo::initarray_size() const {
++  return initarray_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_initarray() {
++  initarray_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::initarray(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_initarray(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_initarray() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_initarray() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return &initarray_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::initarray() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_;
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo_SourceInfo
++
++// repeated uint32 src_type = 1;
++inline int ReorderInfo_SourceInfo::src_type_size() const {
++  return src_type_.size();
++}
++inline void ReorderInfo_SourceInfo::clear_src_type() {
++  src_type_.Clear();
++}
++inline ::google::protobuf::uint32 ReorderInfo_SourceInfo::src_type(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return src_type_.Get(index);
++}
++inline void ReorderInfo_SourceInfo::set_src_type(int index, ::google::protobuf::uint32 value) {
++  src_type_.Set(index, value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++}
++inline void ReorderInfo_SourceInfo::add_src_type(::google::protobuf::uint32 value) {
++  src_type_.Add(value);
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++}
++inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
++ReorderInfo_SourceInfo::src_type() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return src_type_;
++}
++inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
++ReorderInfo_SourceInfo::mutable_src_type() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return &src_type_;
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo
++
++// optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++inline bool ReorderInfo::has_bin() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++inline void ReorderInfo::set_has_bin() {
++  _has_bits_[0] |= 0x00000001u;
++}
++inline void ReorderInfo::clear_has_bin() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++inline void ReorderInfo::clear_bin() {
++  if (bin_ != NULL) bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
++  clear_has_bin();
++}
++inline const ::ShuffleInfo::ReorderInfo_BinaryInfo& ReorderInfo::bin() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.bin)
++  return bin_ != NULL ? *bin_
++                         : *::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance();
++}
++inline ::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::mutable_bin() {
++  set_has_bin();
++  if (bin_ == NULL) {
++    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo;
++  }
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.bin)
++  return bin_;
++}
++inline ::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::release_bin() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.bin)
++  clear_has_bin();
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* temp = bin_;
++  bin_ = NULL;
++  return temp;
++}
++inline void ReorderInfo::set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin) {
++  delete bin_;
++  bin_ = bin;
++  if (bin) {
++    set_has_bin();
++  } else {
++    clear_has_bin();
++  }
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.bin)
++}
++
++// repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++inline int ReorderInfo::layout_size() const {
++  return layout_.size();
++}
++inline void ReorderInfo::clear_layout() {
++  layout_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_LayoutInfo& ReorderInfo::layout(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::mutable_layout(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::add_layout() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
++ReorderInfo::mutable_layout() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.layout)
++  return &layout_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
++ReorderInfo::layout() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.layout)
++  return layout_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++inline int ReorderInfo::fixup_size() const {
++  return fixup_.size();
++}
++inline void ReorderInfo::clear_fixup() {
++  fixup_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo& ReorderInfo::fixup(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::mutable_fixup(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::add_fixup() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
++ReorderInfo::mutable_fixup() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.fixup)
++  return &fixup_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
++ReorderInfo::fixup() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_;
++}
++
++// optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++inline bool ReorderInfo::has_source() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++inline void ReorderInfo::set_has_source() {
++  _has_bits_[0] |= 0x00000002u;
++}
++inline void ReorderInfo::clear_has_source() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++inline void ReorderInfo::clear_source() {
++  if (source_ != NULL) source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
++  clear_has_source();
++}
++inline const ::ShuffleInfo::ReorderInfo_SourceInfo& ReorderInfo::source() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.source)
++  return source_ != NULL ? *source_
++                         : *::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance();
++}
++inline ::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::mutable_source() {
++  set_has_source();
++  if (source_ == NULL) {
++    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo;
++  }
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.source)
++  return source_;
++}
++inline ::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::release_source() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.source)
++  clear_has_source();
++  ::ShuffleInfo::ReorderInfo_SourceInfo* temp = source_;
++  source_ = NULL;
++  return temp;
++}
++inline void ReorderInfo::set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source) {
++  delete source_;
++  source_ = source;
++  if (source) {
++    set_has_source();
++  } else {
++    clear_has_source();
++  }
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.source)
++}
++
++#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
++// -------------------------------------------------------------------
++
++// -------------------------------------------------------------------
++
++// -------------------------------------------------------------------
++
++// -------------------------------------------------------------------
++
++// -------------------------------------------------------------------
++
++
++// @@protoc_insertion_point(namespace_scope)
++
++
++}  // namespace ShuffleInfo
++
++// @@protoc_insertion_point(global_scope)
++
++#endif  // PROTOBUF_shuffleInfo_2eproto__INCLUDED
+diff --git a/shuffleInfo.proto b/shuffleInfo.proto
+new file mode 100644
+index 0000000..802826d
+--- /dev/null
++++ b/shuffleInfo.proto
+@@ -0,0 +1,63 @@
++// This file defines the buffer protocol of the shuffleInfo for reordering.
++// The following command automatically generates both the declaration 
++// and the implementation of shuffleInfo class.
++//    $ protoc --cpp_out=$DST_DIR shuffleInfo.proto       # C++
++//    $ protoc --python_out=$DST_DIR shuffleInfo.proto    # Python
++// The following command generates the shared object.
++//    $ c++ -fPIC -shared shuffleInfo.pb.cc -o shuffleInfo.so `pkg-config --cflags --libs protobuf`
++// Revised: 4/22/18
++
++syntax = "proto2";
++package ShuffleInfo;
++
++message ReorderInfo {
++  // Binary info from ld or ld.gold; reordering range and main offset
++  message BinaryInfo {
++    optional uint32 rand_obj_offset = 1;  // PLACEHOLDER FOR LINKER
++    optional uint32 main_addr_offset = 2; // PLACEHOLDER FOR LINKER
++    optional uint32 obj_sz = 3;           // Verification purpose
++    optional uint32 src_type = 4;         // See the SourceInfo message
++  }
++
++  // Code layout Info (.text) from LLVM
++  // Embeded info ([#func|#fixup]/obj, [#bbk|#fixup]/func, objSz/ea, funcSz/ea)
++  message LayoutInfo {
++    optional uint32 bb_size = 1;          // UPDATE AT LINKTIME WITH OBJ ALIGNMENTs
++                                          // All alignments between fn/bbl are included here
++    optional uint32 type = 2;             // Represents the end of [OBJ|FUN|BBL]
++    optional uint32 num_fixups = 3;
++    optional bool bb_fallthrough = 4;
++    optional string section_name = 5;     // section identifier for c++ mutiple sections
++    optional uint32 offset = 6; // update at linking when combining sections
++    optional uint32 padding_size = 7;
++  }
++
++  // Fixup info in ELF from LLVM
++  message FixupInfo {
++    message FixupTuple {
++      required uint32 offset = 1;         // UPDATE AT LINKTIME WHEN COMBINING SECTIONS
++      required uint32 deref_sz = 2;
++      required bool   is_rela = 3;
++      optional uint32 type = 4;           // c2c, c2d, d2c, d2d = (0-3)
++      optional string section_name = 5;   // section identifier for c++ mutiple sections
++                                          // fixup has a jump table (.rodata) for pic/pie use
++      optional uint32 num_jt_entries = 6; // number of the jump table entries
++      optional uint32 jt_entry_sz = 7;    // size of each jump table entry in byte
++    }
++    repeated FixupTuple text = 1;
++    repeated FixupTuple rodata = 2;
++    repeated FixupTuple data = 3;
++    repeated FixupTuple datarel = 4;
++    repeated FixupTuple initarray = 5;
++  }
++  
++  // Source info [generalSource(=0) | hasInlineAssembly(=1) | standaloneAssembly(=2)]
++  message SourceInfo {
++    repeated uint32 src_type = 1;         // the src_type placeholder for linker
++  }
++
++  optional BinaryInfo bin = 1;
++  repeated LayoutInfo layout = 2;
++  repeated FixupInfo fixup = 3;
++  optional SourceInfo source = 4;
++}
+diff --git a/struc-symbol.h b/struc-symbol.h
+index c016848..44957f2 100644
+--- a/struc-symbol.h
++++ b/struc-symbol.h
+@@ -104,6 +104,16 @@ struct symbol
+ #ifdef TARGET_SYMBOL_FIELDS
+   TARGET_SYMBOL_FIELDS
+ #endif
++
++// binpang add
++// jump table related information, we only add the related information in i386/x86_64 architecture
++#if defined(__i386__) || defined(__x86_64__)
++   struct jump_table{
++      unsigned int table_size; // the jump table size(number of jump table entry)
++      unsigned int entry_size; // the jump table entry size
++   } jmp_table;
++#endif
++
+ };
+ 
+ /* A pointer in the symbol may point to either a complete symbol
+@@ -144,6 +154,12 @@ struct local_symbol
+ #ifdef TC_LOCAL_SYMFIELD_TYPE
+   TC_LOCAL_SYMFIELD_TYPE lsy_tc;
+ #endif
++
++// binpang add
++// jump table related information, we only add the related information in i386/x86_64 architecture
++#if defined(__i386__) || defined(__x86_64__)
++struct jump_table jmp_table;
++#endif
+ };
+ 
+ #define local_symbol_converted_p(l) ((l)->lsy_section == reg_section)
+diff --git a/symbols.c b/symbols.c
+index d16e804..863d60a 100644
+--- a/symbols.c
++++ b/symbols.c
+@@ -2213,6 +2213,38 @@ S_GET_NAME (symbolS *s)
+   return s->bsym->name;
+ }
+ 
++/*
++ * binpang, add
++ * get and set jump table related element
++ */
++unsigned S_GET_JMPTBL_SIZE(symbolS *s)
++{
++  if (LOCAL_SYMBOL_CHECK (s))
++    return ((struct local_symbol *) s)->jmp_table.table_size;
++  return s->jmp_table.table_size;
++}
++
++unsigned S_GET_JMPTBL_ENTRY_SZ(symbolS *s)
++{
++  if (LOCAL_SYMBOL_CHECK (s))
++    return ((struct local_symbol *) s)->jmp_table.entry_size;
++  return s->jmp_table.entry_size;
++}
++
++void S_SET_JMPTBL_SIZE(symbolS *s, unsigned size){
++  if (LOCAL_SYMBOL_CHECK (s))
++    ((struct local_symbol *) s)->jmp_table.table_size = size;
++  else
++    s->jmp_table.table_size = size;
++}
++
++void S_SET_JMPTBL_ENTRY_SZ(symbolS *s, unsigned size){
++  if (LOCAL_SYMBOL_CHECK (s))
++    ((struct local_symbol *) s)->jmp_table.entry_size = size;
++  else
++    s->jmp_table.entry_size = size;
++}
++
+ segT
+ S_GET_SEGMENT (symbolS *s)
+ {
+diff --git a/symbols.h b/symbols.h
+index cb316b5..5b125e2 100644
+--- a/symbols.h
++++ b/symbols.h
+@@ -84,6 +84,15 @@ char *fb_label_name (long n, long augend);
+ 
+ extern void copy_symbol_attributes (symbolS *, symbolS *);
+ 
++/*
++ * binpang, add
++ * get and set jump table struct
++ */
++extern unsigned S_GET_JMPTBL_SIZE(symbolS*);
++extern unsigned S_GET_JMPTBL_ENTRY_SZ(symbolS*);
++extern void S_SET_JMPTBL_SIZE(symbolS*, unsigned);
++extern void S_SET_JMPTBL_ENTRY_SZ(symbolS*, unsigned);
++
+ /* Get and set the values of symbols.  These used to be macros.  */
+ extern valueT S_GET_VALUE (symbolS *);
+ extern void S_SET_VALUE (symbolS *, valueT);
+diff --git a/write.c b/write.c
+index 2869660..9ccd622 100644
+--- a/write.c
++++ b/write.c
+@@ -27,6 +27,10 @@
+ #include "dwarf2dbg.h"
+ #include "compress-debug.h"
+ 
++#if defined(__i386__) || defined(__x86_64__)
++#include "bbInfoHandle.h"
++#endif
++
+ #ifndef TC_FORCE_RELOCATION
+ #define TC_FORCE_RELOCATION(FIX)		\
+   (generic_force_reloc (FIX))
+@@ -549,6 +553,84 @@ relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx)
+     info->changed = 1;
+ }
+ 
++/*
++ *  binpang, add.
++ *  update basic block size.
++ */
++#if defined(__i386__) || defined(__x86_64__)
++static void update_basic_block_size(bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx ATTRIBUTE_UNUSED)
++{
++  const char* sec_name = sec->name;
++  // we only handle the basic block in .text.xxx section
++  char* tmp_pointer = NULL;
++  tmp_pointer = strstr(sec_name, ".text");
++  if (!(tmp_pointer && tmp_pointer == sec_name))
++    return;
++  segment_info_type *seginfo = seg_info (sec);
++  struct frag *seg_frag_root = seginfo->frchainP->frch_root;
++  struct frag *fragP;
++  bbinfo_mbb *mbbP;
++  
++  for (fragP = seg_frag_root; fragP;
++    fragP = fragP->fr_next){
++    fragP->parent = sec;
++    // update the basic block size
++    mbbP = fragP->last_bb;
++    
++    if (mbbP && fragP->last_bb_added_size){
++      mbbP->size += fragP->last_bb_added_size;
++    }
++    
++   }
++}
++
++static void update_basic_block_size_from_frag(bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx ATTRIBUTE_UNUSED)
++{
++  const char* sec_name = sec->name;
++  // we only handle the basic block in .text.xxx section
++  char* tmp_pointer = NULL;
++  tmp_pointer = strstr(sec_name, ".text");
++  if (!(tmp_pointer && tmp_pointer == sec_name))
++    return;
++
++  segment_info_type *seginfo = seg_info (sec);
++  struct frag *seg_frag_root = seginfo->frchainP->frch_root;
++  struct frag *fragP;
++  bbinfo_mbb *mbbP;
++  struct frag *last_frag = NULL;
++  
++  for (fragP = seg_frag_root; fragP;
++    fragP = fragP->fr_next){
++    
++    mbbP = fragP->last_bb;
++    if (last_frag && last_frag->last_bb){
++      int frag_offset = fragP->fr_address - last_frag->last_bb->offset;
++   // update the basic block size according to the fragment offset
++      if (frag_offset > last_frag->last_bb->size){
++	last_frag->last_bb->size = frag_offset;}
++    }
++
++    if (mbbP)
++      last_frag = fragP;
++   }
++}
++// update basic block offset
++static void update_basic_block_offset(void){
++  for (bbinfo_mbb *cur_mbb = mbbs_list_head; cur_mbb;
++      		cur_mbb = cur_mbb->next)
++  {
++    if (!cur_mbb->parent_frag)
++    {
++      //as_warn(_("[bbInfo warning]: Basic block %d don't have parent fragment, its size %d"), cur_mbb->ID, cur_mbb->size);
++      continue;
++    }
++    cur_mbb->offset += cur_mbb->parent_frag->fr_address;
++    cur_mbb->sec = cur_mbb->parent_frag->parent;
++  }
++}
++#endif
++
++
+ static void
+ size_seg (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
+ {
+@@ -1149,6 +1231,52 @@ fix_segment (bfd *abfd ATTRIBUTE_UNUSED,
+   fixup_segment (seginfo->fix_root, sec);
+ }
+ 
++/*
++ * binpang, add. 
++ * collect fixup information before fixup resolved.
++ */
++static void 
++bbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,
++    	     asection *sec,
++	     void *xxx ATTRIBUTE_UNUSED)
++{
++
++  fixS *fixp;
++  segment_info_type *seginfo = seg_info (sec);
++
++  if (!seginfo->fix_root)
++    return;
++
++  char is_new_sec = bbinfo_is_collect_sec(sec);
++  
++  // we only collect .text, .rodata, .init_array, .data, .data.rel.ro sections
++  if (!is_new_sec)
++    return;
++  
++ /*
++  * TODO(binpang), add relocation information that .realoc directive defined
++  * which is stored in reloc_list.
++  *  may refer to what write_relocs fucntion does
++  */
++  for(fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
++  {
++    int offset = fixp->fx_frag->fr_address + fixp->fx_where; 
++   // bbinfo_fixup* tmp_fixp = bbinfo_init_fixup(fixups_list_head, fixups_list_tail);
++    bbinfo_fixup* tmp_fixp = bbinfo_init_insert_fixup(sec, offset);
++    tmp_fixp->sec = sec;
++    tmp_fixp->offset = offset;
++    tmp_fixp->is_rela = (unsigned char)fixp->fx_pcrel;
++    tmp_fixp->size = fixp->fx_size;
++    // FIXME. Here I only consider fixp->fx_addsy
++    symbolS* tmp_sym = fixp->fx_addsy;
++    if(tmp_sym){
++      tmp_fixp->table_size = S_GET_JMPTBL_SIZE(tmp_sym);
++      tmp_fixp->entry_size = S_GET_JMPTBL_ENTRY_SZ(tmp_sym);
++    }
++    tmp_fixp->is_new_section = 0;
++  }
++
++}
+ static void
+ install_reloc (asection *sec, arelent *reloc, fragS *fragp,
+ 	       const char *file, unsigned int line)
+@@ -1578,6 +1706,20 @@ write_contents (bfd *abfd ATTRIBUTE_UNUSED,
+   segment_info_type *seginfo = seg_info (sec);
+   addressT offset = 0;
+   fragS *f;
++  
++  /*
++   * binpang, add
++   * output the section .rand
++   */ 
++  if (!strcmp(sec->name, ".rand")){
++    unsigned result = bfd_set_section_contents(stdoutput, sec, bbinfo_shuffle_info_buf, 
++			(file_ptr) 0, (bfd_size_type) bbinfo_shuffle_info_buf_len);
++    
++  if(!result)
++    as_warn(_("can't write data into .rand"));
++
++  return;
++  }
+ 
+   /* Write out the frags.  */
+   if (seginfo == NULL
+@@ -1916,6 +2058,14 @@ write_object_file (void)
+ 	break;
+     }
+ 
++// binpang, add 
++// update basic block size and offset
++#if defined(__i386__) || defined(__x86_64__)
++  bfd_map_over_sections (stdoutput, update_basic_block_size, (void*)0);
++  update_basic_block_offset();
++  //bfd_map_over_sections (stdoutput, update_basic_block_size_from_frag, (void*)0);
++#endif
++
+   /* Note - Most ports will use the default value of
+      TC_FINALIZE_SYMS_BEFORE_SIZE_SEG, which 1.  This will force
+      local symbols to be resolved, removing their frag information.
+@@ -2040,6 +2190,12 @@ write_object_file (void)
+   }
+ #endif /* not WORKING_DOT_WORD  */
+ 
++  /*
++   * binpang, add
++   * collect all fixup
++   */
++  bfd_map_over_sections (stdoutput, bbinfo_update_fixp, (char *) 0);
++
+   /* Resolve symbol values.  This needs to be done before processing
+      the relocations.  */
+   if (symbol_rootP)
+@@ -2255,7 +2411,32 @@ write_object_file (void)
+       bfd_map_over_sections (stdoutput, compress_debug, (char *) 0);
+     }
+ 
++  /*
++   * binpang, add
++   * create .rand section
++   */
++  asection* rand_sec = bfd_make_section (stdoutput, ".rand");
++  bfd_set_section_flags(stdoutput, rand_sec, SEC_HAS_CONTENTS);
++  bbinfo_update_shuffle_info();
++  // BUG? why should at here specify size. But in write_contents fuction, it can't work.
++  rand_sec->size = bbinfo_shuffle_info_buf_len;
++
+   bfd_map_over_sections (stdoutput, write_contents, (char *) 0);
++
++// binpang, add. debug.
++//#if defined(__i386__) || defined(__x86_64__)
++//  int tmp_index = 0;
++//  printf("after relaxing....\n");
++//  for(bbinfo_mbb* cur_bb = mbbs_list_head; cur_bb; cur_bb = cur_bb->next)
++//    printf("basic block#%d: basic block offset %x, size %d, fall_through %d, its section name is %s\n", 
++//	tmp_index++, cur_bb->offset, cur_bb->size, cur_bb->fall_through, cur_bb->sec->name);
++//
++//  printf("fixup information\n");
++//  tmp_index = 0;
++//  for(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp; cur_fixp = cur_fixp->next)
++//    printf("fixup#%d: fixup offset %x, size %d, section %s, is rela %d, table size %d, entry size %d\n ", 
++//	tmp_index++, cur_fixp->offset, cur_fixp->size, cur_fixp->sec->name, cur_fixp->is_rela, cur_fixp->table_size, cur_fixp->entry_size);
++//#endif
+ }
+ 
+ #ifdef TC_GENERIC_RELAX_TABLE
+@@ -2407,6 +2588,14 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+   int region;
+   int ret;
+ 
++// binpang add
++// use last_frag to record the last fragS
++// handle the situation that before alignment fragS
++#if defined(__i386__) || defined(__x86_64__)
++struct frag *last_frag = NULL;
++bbinfo_mbb *frag_last_bb = NULL;
++#endif
++
+   /* In case md_estimate_size_before_relax() wants to make fixSs.  */
+   subseg_change (segment, 0);
+ 
+@@ -2423,10 +2612,28 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+       fragP->fr_address = address;
+       address += fragP->fr_fix;
+ 
++// binpang, add.
++#if defined(__i386__) || defined(__x86_64__)
++      frag_last_bb = NULL;
++      // may do many times relax pass. every time reset last_bb_added_size.
++      fragP->last_bb_added_size = fragP->last_bb_added_fix_size;
++      if (fragP->last_bb && fragP->last_bb->alignment)
++	fragP->last_bb->alignment = 0;
++#endif
++
+       switch (fragP->fr_type)
+ 	{
+ 	case rs_fill:
+-	  address += fragP->fr_offset * fragP->fr_var;
++	  {int addedBytes = fragP->fr_offset * fragP->fr_var;
++
++#if defined(__i386__) || defined(__x86_64__) 
++	  frag_last_bb = fragP->last_bb;
++	  if (frag_last_bb){
++	    fragP->last_bb_added_size += addedBytes;
++	  }
++#endif
++	  address += addedBytes;
++	}
+ 	  break;
+ 
+ 	case rs_align:
+@@ -2449,8 +2656,30 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 			      (unsigned long) offset, (long) fragP->fr_var);
+ 		offset -= (offset % fragP->fr_var);
+ 	      }
+-
+ 	    address += offset;
++	 
++// add the alignment bytes to the last basic block
++// TODO(binpang). Seperate the alignment fragment into a seperate basic block.
++#if defined(__i386__) || defined(__x86_64__)
++	    struct frag* tmp_frag = NULL;
++	      /*
++	       * FIXME. If the current frag has fix bytes, then append the alignment to the current frag.
++	       * Otherwise, append the alignment to the last frag.
++	       */
++	      if(fragP && fragP->fr_fix)
++	       	tmp_frag = fragP;
++	      else 
++		tmp_frag = last_frag;
++
++	      // make sure the tmp_frag contains basic block
++	      if (tmp_frag && tmp_frag->last_bb)
++	      {
++		tmp_frag->last_bb_added_size += offset;
++		tmp_frag->last_bb->alignment += offset;
++	        //printf("[bbInfo]: alignment add size %d, frag address %x\n", offset, fragP->fr_address);
++	      }
++	      
++#endif
+ 	    region += 1;
+ 	  }
+ 	  break;
+@@ -2470,7 +2699,18 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 	  if (fragP->fr_symbol)
+ 	    resolve_symbol_value (fragP->fr_symbol);
+ 
+-	  address += md_estimate_size_before_relax (fragP, segment);
++	  int added_bytes = md_estimate_size_before_relax (fragP, segment);
++	  address += added_bytes;
++
++	  //binpang, add. update the last basic block's size
++#if defined(__i386__) || defined(__x86_64__)
++	  frag_last_bb = fragP->last_bb;
++	  if (frag_last_bb && added_bytes)
++	  {
++	    fragP->last_bb_added_size += added_bytes;
++	  }
++#endif
++	  
+ 	  break;
+ 
+ #ifndef WORKING_DOT_WORD
+@@ -2497,6 +2737,11 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 	  BAD_CASE (fragP->fr_type);
+ 	  break;
+ 	}
++
++#if defined(__i386__) || defined(__x86_64__)
++        if (fragP->last_bb)
++	  last_frag = fragP;
++#endif
+     }
+ 
+   /* Do relax().  */
+@@ -2549,12 +2794,18 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+     if (max_iterations < frag_count)
+       max_iterations = frag_count;
+ 
++
+     ret = 0;
+     do
+       {
+ 	stretch = 0;
+ 	stretched = 0;
+ 
++// binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++   last_frag = NULL; 
++#endif
++
+ 	for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
+ 	  {
+ 	    offsetT growth = 0;
+@@ -2663,6 +2914,29 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 
+ 		  growth = newoff - oldoff;
+ 
++/* 
++ * binpang, add.
++ * update the fragment's last basic block size. Similar to up.
++ * TODO(binpang). maybe seperate the alignment fragment in code segment into a basic block.
++*/
++#if defined(__i386__) || defined(__x86_64__)
++		  struct frag* tmp_frag = NULL;
++		  if (fragP && fragP->fr_fix)
++		    tmp_frag = fragP;
++		  else
++		  {
++		    tmp_frag = last_frag;
++		  }
++		    // tmp_frag has basic block. exclude data fragment.
++		  if (tmp_frag && tmp_frag->last_bb)
++		    {
++		      tmp_frag->last_bb_added_size += growth;
++		      tmp_frag->last_bb->alignment += growth;
++		   // debug
++		   // printf("[bbInfo]: alignment add size %d, frag address is %x\n", growth, fragP->fr_address);
++		    }
++#endif
++
+ 		  /* If this align happens to follow a leb128 and
+ 		     we have determined that the leb128 is bouncing
+ 		     in size, then break the cycle by inserting an
+@@ -2801,6 +3075,7 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 		break;
+ 
+ 	      case rs_machine_dependent:
++		{
+ #ifdef md_relax_frag
+ 		growth = md_relax_frag (segment, fragP, stretch);
+ #else
+@@ -2809,6 +3084,19 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 		   TC_GENERIC_RELAX_TABLE.  */
+ 		growth = relax_frag (segment, fragP, stretch);
+ #endif /* TC_GENERIC_RELAX_TABLE  */
++#endif
++		
++		// binpang, add
++		// update the relaxed basic block size
++#if defined(__i386__) || defined(__x86_64__)
++		frag_last_bb = fragP->last_bb;
++		if (frag_last_bb && growth)
++		{
++		  fragP->last_bb_added_size += growth;
++		  // debug
++		  //printf("[bbInfo]: machine dependent add size %d, frag address is %x. Hello?\n", growth, fragP->fr_address);
++		}
++             }
+ #endif
+ 		break;
+ 
+@@ -2849,6 +3137,13 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 		else
+ 		  rs_leb128_fudge = 0;
+ 	      }
++
++// binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	    if (fragP->last_bb)
++	      last_frag = fragP;
++#endif
++
+ 	  }
+ 
+ 	if (stretch == 0
diff --git a/autom4te.cache/output.0 b/autom4te.cache/output.0
new file mode 100644
index 0000000..e69de29
diff --git a/autom4te.cache/output.1t b/autom4te.cache/output.1t
new file mode 100644
index 0000000..ec88dfd
--- /dev/null
+++ b/autom4te.cache/output.1t
@@ -0,0 +1 @@
+@%:@! /bin/sh
diff --git a/autom4te.cache/requests b/autom4te.cache/requests
new file mode 100644
index 0000000..6d18deb
--- /dev/null
+++ b/autom4te.cache/requests
@@ -0,0 +1,79 @@
+# This file was generated by Autom4te Sun Aug 20 23:09:08 UTC 2017.
+# It contains the lists of macros which have been traced.
+# It can be safely removed.
+
+@request = (
+             bless( [
+                      '0',
+                      1,
+                      [
+                        '/usr/share/autoconf'
+                      ],
+                      [
+                        '/usr/share/autoconf/autoconf/autoconf.m4f',
+                        'aclocal.m4',
+                        'Makefile.am'
+                      ],
+                      {
+                        'AC_FC_PP_DEFINE' => 1,
+                        '_LT_AC_TAGCONFIG' => 1,
+                        'AC_INIT' => 1,
+                        'AC_CONFIG_SUBDIRS' => 1,
+                        'AM_PROG_CXX_C_O' => 1,
+                        'AM_SILENT_RULES' => 1,
+                        'AM_PATH_GUILE' => 1,
+                        'AC_CONFIG_AUX_DIR' => 1,
+                        'AC_LIBSOURCE' => 1,
+                        'AM_AUTOMAKE_VERSION' => 1,
+                        'AC_CANONICAL_BUILD' => 1,
+                        '_AM_MAKEFILE_INCLUDE' => 1,
+                        'AC_REQUIRE_AUX_FILE' => 1,
+                        'AM_XGETTEXT_OPTION' => 1,
+                        'AC_SUBST' => 1,
+                        'AC_CANONICAL_SYSTEM' => 1,
+                        'AC_PROG_LIBTOOL' => 1,
+                        'AC_CANONICAL_HOST' => 1,
+                        'm4_pattern_forbid' => 1,
+                        'AM_ENABLE_MULTILIB' => 1,
+                        'm4_include' => 1,
+                        'AM_PROG_LIBTOOL' => 1,
+                        '_m4_warn' => 1,
+                        'AM_GNU_GETTEXT_INTL_SUBDIR' => 1,
+                        'AC_CANONICAL_TARGET' => 1,
+                        'AC_FC_FREEFORM' => 1,
+                        'LT_CONFIG_LTDL_DIR' => 1,
+                        'AM_MAINTAINER_MODE' => 1,
+                        'include' => 1,
+                        'AM_MAKEFILE_INCLUDE' => 1,
+                        'AC_DEFINE_TRACE_LITERAL' => 1,
+                        '_AM_COND_ENDIF' => 1,
+                        'AC_CONFIG_FILES' => 1,
+                        'sinclude' => 1,
+                        'm4_pattern_allow' => 1,
+                        'AM_NLS' => 1,
+                        'AM_INIT_AUTOMAKE' => 1,
+                        'AC_FC_PP_SRCEXT' => 1,
+                        '_AM_COND_IF' => 1,
+                        'LT_SUPPORTED_TAG' => 1,
+                        'AC_CONFIG_LIBOBJ_DIR' => 1,
+                        'AC_SUBST_TRACE' => 1,
+                        'AC_CONFIG_HEADERS' => 1,
+                        'm4_sinclude' => 1,
+                        'AM_PROG_AR' => 1,
+                        'AM_PROG_MOC' => 1,
+                        'AM_GNU_GETTEXT' => 1,
+                        'AC_FC_SRCEXT' => 1,
+                        'AM_PROG_F77_C_O' => 1,
+                        'LT_INIT' => 1,
+                        'AM_PROG_FC_C_O' => 1,
+                        '_AM_COND_ELSE' => 1,
+                        'AM_CONDITIONAL' => 1,
+                        'AC_CONFIG_LINKS' => 1,
+                        '_AM_SUBST_NOTMAKE' => 1,
+                        'AH_OUTPUT' => 1,
+                        'AM_PROG_CC_C_O' => 1,
+                        'AM_POT_TOOLS' => 1
+                      }
+                    ], 'Autom4te::Request' )
+           );
+
diff --git a/autom4te.cache/traces.0 b/autom4te.cache/traces.0
new file mode 100644
index 0000000..363ac05
--- /dev/null
+++ b/autom4te.cache/traces.0
@@ -0,0 +1,20 @@
+m4trace:aclocal.m4:1012: -1- m4_include([../bfd/acinclude.m4])
+m4trace:aclocal.m4:1013: -1- m4_include([../bfd/warning.m4])
+m4trace:aclocal.m4:1014: -1- m4_include([../config/acx.m4])
+m4trace:aclocal.m4:1015: -1- m4_include([../config/depstand.m4])
+m4trace:aclocal.m4:1016: -1- m4_include([../config/gettext-sister.m4])
+m4trace:aclocal.m4:1017: -1- m4_include([../config/largefile.m4])
+m4trace:aclocal.m4:1018: -1- m4_include([../config/lcmessage.m4])
+m4trace:aclocal.m4:1019: -1- m4_include([../config/lead-dot.m4])
+m4trace:aclocal.m4:1020: -1- m4_include([../config/nls.m4])
+m4trace:aclocal.m4:1021: -1- m4_include([../config/override.m4])
+m4trace:aclocal.m4:1022: -1- m4_include([../config/plugins.m4])
+m4trace:aclocal.m4:1023: -1- m4_include([../config/po.m4])
+m4trace:aclocal.m4:1024: -1- m4_include([../config/progtest.m4])
+m4trace:aclocal.m4:1025: -1- m4_include([../config/zlib.m4])
+m4trace:aclocal.m4:1026: -1- m4_include([../libtool.m4])
+m4trace:aclocal.m4:1027: -1- m4_include([../ltoptions.m4])
+m4trace:aclocal.m4:1028: -1- m4_include([../ltsugar.m4])
+m4trace:aclocal.m4:1029: -1- m4_include([../ltversion.m4])
+m4trace:aclocal.m4:1030: -1- m4_include([../lt~obsolete.m4])
+m4trace:aclocal.m4:1031: -1- m4_include([acinclude.m4])
diff --git a/autom4te.cache/traces.1t b/autom4te.cache/traces.1t
new file mode 100644
index 0000000..b9416dc
--- /dev/null
+++ b/autom4te.cache/traces.1t
@@ -0,0 +1,172 @@
+m4trace:aclocal.m4:1012: -1- m4_include([../bfd/acinclude.m4])
+m4trace:aclocal.m4:1013: -1- m4_include([../bfd/warning.m4])
+m4trace:aclocal.m4:1014: -1- m4_include([../config/acx.m4])
+m4trace:aclocal.m4:1015: -1- m4_include([../config/depstand.m4])
+m4trace:aclocal.m4:1016: -1- m4_include([../config/gettext-sister.m4])
+m4trace:aclocal.m4:1017: -1- m4_include([../config/largefile.m4])
+m4trace:aclocal.m4:1018: -1- m4_include([../config/lcmessage.m4])
+m4trace:aclocal.m4:1019: -1- m4_include([../config/lead-dot.m4])
+m4trace:aclocal.m4:1020: -1- m4_include([../config/nls.m4])
+m4trace:aclocal.m4:1021: -1- m4_include([../config/override.m4])
+m4trace:aclocal.m4:1022: -1- m4_include([../config/plugins.m4])
+m4trace:aclocal.m4:1023: -1- m4_include([../config/po.m4])
+m4trace:aclocal.m4:1024: -1- m4_include([../config/progtest.m4])
+m4trace:aclocal.m4:1025: -1- m4_include([../config/zlib.m4])
+m4trace:aclocal.m4:1026: -1- m4_include([../libtool.m4])
+m4trace:aclocal.m4:1027: -1- m4_include([../ltoptions.m4])
+m4trace:aclocal.m4:1028: -1- m4_include([../ltsugar.m4])
+m4trace:aclocal.m4:1029: -1- m4_include([../ltversion.m4])
+m4trace:aclocal.m4:1030: -1- m4_include([../lt~obsolete.m4])
+m4trace:aclocal.m4:1031: -1- m4_include([acinclude.m4])
+m4trace:configure.ac:24: -1- m4_include([../bfd/version.m4])
+m4trace:configure.ac:25: -1- AC_INIT([gas], [2.30])
+m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?A[CHUM]_])
+m4trace:configure.ac:25: -1- m4_pattern_forbid([_AC_])
+m4trace:configure.ac:25: -1- m4_pattern_forbid([^LIBOBJS$], [do not use LIBOBJS directly, use AC_LIBOBJ (see section `AC_LIBOBJ vs LIBOBJS'])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^AS_FLAGS$])
+m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?m4_])
+m4trace:configure.ac:25: -1- m4_pattern_forbid([^dnl$])
+m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?AS_])
+m4trace:configure.ac:25: -1- AC_SUBST([SHELL])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([SHELL])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^SHELL$])
+m4trace:configure.ac:25: -1- AC_SUBST([PATH_SEPARATOR])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PATH_SEPARATOR])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PATH_SEPARATOR$])
+m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_NAME], [m4_ifdef([AC_PACKAGE_NAME],      ['AC_PACKAGE_NAME'])])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_NAME])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_NAME$])
+m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_TARNAME], [m4_ifdef([AC_PACKAGE_TARNAME],   ['AC_PACKAGE_TARNAME'])])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_TARNAME])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_TARNAME$])
+m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_VERSION], [m4_ifdef([AC_PACKAGE_VERSION],   ['AC_PACKAGE_VERSION'])])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_VERSION])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_VERSION$])
+m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_STRING], [m4_ifdef([AC_PACKAGE_STRING],    ['AC_PACKAGE_STRING'])])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_STRING])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_STRING$])
+m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_BUGREPORT], [m4_ifdef([AC_PACKAGE_BUGREPORT], ['AC_PACKAGE_BUGREPORT'])])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_BUGREPORT])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])
+m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_URL], [m4_ifdef([AC_PACKAGE_URL],       ['AC_PACKAGE_URL'])])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_URL])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_URL$])
+m4trace:configure.ac:25: -1- AC_SUBST([exec_prefix], [NONE])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([exec_prefix])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^exec_prefix$])
+m4trace:configure.ac:25: -1- AC_SUBST([prefix], [NONE])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([prefix])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^prefix$])
+m4trace:configure.ac:25: -1- AC_SUBST([program_transform_name], [s,x,x,])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([program_transform_name])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^program_transform_name$])
+m4trace:configure.ac:25: -1- AC_SUBST([bindir], ['${exec_prefix}/bin'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([bindir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^bindir$])
+m4trace:configure.ac:25: -1- AC_SUBST([sbindir], ['${exec_prefix}/sbin'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sbindir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^sbindir$])
+m4trace:configure.ac:25: -1- AC_SUBST([libexecdir], ['${exec_prefix}/libexec'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([libexecdir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^libexecdir$])
+m4trace:configure.ac:25: -1- AC_SUBST([datarootdir], ['${prefix}/share'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([datarootdir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^datarootdir$])
+m4trace:configure.ac:25: -1- AC_SUBST([datadir], ['${datarootdir}'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([datadir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^datadir$])
+m4trace:configure.ac:25: -1- AC_SUBST([sysconfdir], ['${prefix}/etc'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sysconfdir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^sysconfdir$])
+m4trace:configure.ac:25: -1- AC_SUBST([sharedstatedir], ['${prefix}/com'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sharedstatedir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^sharedstatedir$])
+m4trace:configure.ac:25: -1- AC_SUBST([localstatedir], ['${prefix}/var'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([localstatedir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^localstatedir$])
+m4trace:configure.ac:25: -1- AC_SUBST([runstatedir], ['${localstatedir}/run'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([runstatedir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^runstatedir$])
+m4trace:configure.ac:25: -1- AC_SUBST([includedir], ['${prefix}/include'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([includedir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^includedir$])
+m4trace:configure.ac:25: -1- AC_SUBST([oldincludedir], ['/usr/include'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([oldincludedir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^oldincludedir$])
+m4trace:configure.ac:25: -1- AC_SUBST([docdir], [m4_ifset([AC_PACKAGE_TARNAME],
+				     ['${datarootdir}/doc/${PACKAGE_TARNAME}'],
+				     ['${datarootdir}/doc/${PACKAGE}'])])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([docdir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^docdir$])
+m4trace:configure.ac:25: -1- AC_SUBST([infodir], ['${datarootdir}/info'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([infodir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^infodir$])
+m4trace:configure.ac:25: -1- AC_SUBST([htmldir], ['${docdir}'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([htmldir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^htmldir$])
+m4trace:configure.ac:25: -1- AC_SUBST([dvidir], ['${docdir}'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([dvidir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^dvidir$])
+m4trace:configure.ac:25: -1- AC_SUBST([pdfdir], ['${docdir}'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([pdfdir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^pdfdir$])
+m4trace:configure.ac:25: -1- AC_SUBST([psdir], ['${docdir}'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([psdir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^psdir$])
+m4trace:configure.ac:25: -1- AC_SUBST([libdir], ['${exec_prefix}/lib'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([libdir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^libdir$])
+m4trace:configure.ac:25: -1- AC_SUBST([localedir], ['${datarootdir}/locale'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([localedir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^localedir$])
+m4trace:configure.ac:25: -1- AC_SUBST([mandir], ['${datarootdir}/man'])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([mandir])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^mandir$])
+m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_NAME])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_NAME$])
+m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_NAME], [/* Define to the full name of this package. */
+@%:@undef PACKAGE_NAME])
+m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_TARNAME])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_TARNAME$])
+m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_TARNAME], [/* Define to the one symbol short name of this package. */
+@%:@undef PACKAGE_TARNAME])
+m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_VERSION])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_VERSION$])
+m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_VERSION], [/* Define to the version of this package. */
+@%:@undef PACKAGE_VERSION])
+m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_STRING])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_STRING$])
+m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_STRING], [/* Define to the full name and version of this package. */
+@%:@undef PACKAGE_STRING])
+m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_BUGREPORT])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])
+m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_BUGREPORT], [/* Define to the address where bug reports for this package should be sent. */
+@%:@undef PACKAGE_BUGREPORT])
+m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_URL])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_URL$])
+m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_URL], [/* Define to the home page for this package. */
+@%:@undef PACKAGE_URL])
+m4trace:configure.ac:25: -1- AC_SUBST([DEFS])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([DEFS])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^DEFS$])
+m4trace:configure.ac:25: -1- AC_SUBST([ECHO_C])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_C])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_C$])
+m4trace:configure.ac:25: -1- AC_SUBST([ECHO_N])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_N])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_N$])
+m4trace:configure.ac:25: -1- AC_SUBST([ECHO_T])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_T])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_T$])
+m4trace:configure.ac:25: -1- AC_SUBST([LIBS])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([LIBS])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^LIBS$])
+m4trace:configure.ac:25: -1- AC_SUBST([build_alias])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([build_alias])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^build_alias$])
+m4trace:configure.ac:25: -1- AC_SUBST([host_alias])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([host_alias])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^host_alias$])
+m4trace:configure.ac:25: -1- AC_SUBST([target_alias])
+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([target_alias])
+m4trace:configure.ac:25: -1- m4_pattern_allow([^target_alias$])
diff --git a/bbInfoHandle.c b/bbInfoHandle.c
new file mode 100644
index 0000000..3b10dc5
--- /dev/null
+++ b/bbInfoHandle.c
@@ -0,0 +1,950 @@
+/*
+ * bbInfoHandle.c
+ */
+
+#include "bbInfoHandle.h"
+#include "struc-symbol.h"
+#include <time.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+static void jmptable_bbInfo_handler (int);
+static void funcb_bbInfo_handler (int);
+static void funce_bbInfo_handler (int);
+static void bb_bbInfo_handler (int);
+static void be_bbInfo_handler (int);
+static void inlineb_bbInfo_handler (int);
+static void inlinee_bbInfo_handler (int);
+void bbinfo_update_shuffle_info(void);
+bbinfo_mbb* init_basic_block(void);
+bbinfo_fixup* bbinfo_init_fixup();
+bbinfo_fixup* bbinfo_init_insert_fixup(asection*, int);
+char bbinfo_is_collect_sec(asection*);
+char bbinfo_is_new_sec_frag(asection*);
+void handwritten_funcb_bbinfo_handler();
+void handwritten_funce_bbinfo_handler();
+
+#ifdef BBINFO_DEBUG_MSG
+char *bbinfo_file_name = NULL;
+#endif
+
+const pseudo_typeS bbInfo_pseudo_table[] = {
+    {"bbinfo_jmptbl", jmptable_bbInfo_handler, 0},
+    {"bbinfo_funb", funcb_bbInfo_handler, 0},
+    {"bbinfo_fune", funce_bbInfo_handler, 0},
+    {"bbinfo_bb", bb_bbInfo_handler, 0},
+    {"bbinfo_be", be_bbInfo_handler, 0},
+    {"bbinfo_inlineb", inlineb_bbInfo_handler, 0},
+    {"bbinfo_inlinee", inlinee_bbInfo_handler, 0},
+    {NULL, NULL, 0}
+};
+
+// debug related symbol
+const char* symbol_blacklist[] = {
+  ".Ldebug",
+  ".LASF"
+};
+
+// local variable
+bbinfo_mbb* _mbbs_tmp_prev = NULL;
+
+// global variable
+bbinfo_sec_last_bb* sec_last_bb_head = NULL;
+bbinfo_fixup* fixups_list_head; // fixup list
+bbinfo_mbb* mbbs_list_head;   // first element of basic blocks list
+bbinfo_mbb* mbbs_list_tail; // last element of basic blocks list
+uint32_t cur_function_id;  // current functin id
+uint32_t cur_function_end_id; // current function end id
+uint32_t prev_function_id; // prev function id
+symbolS *last_symbol; // last user defined symbol
+uint32_t cur_block_id; // global current basic block id 
+unsigned char function_head; // represent that the current basic block is current function's first entry
+const char* handwritten_bbinfo_func_name = NULL;
+
+// to record if fixups is in a new section(such as .text.xxx)
+//unsigned text_sec_cnt;
+//unsigned rodata_sec_cnt;
+//unsigned data_sec_cnt;
+//unsigned datarel_sec_cnt;
+//unsigned init_sec_cnt;
+
+unsigned text_sec_frag_cnt;
+unsigned rodata_sec_frag_cnt;
+unsigned data_sec_frag_cnt;
+unsigned datarel_sec_frag_cnt;
+unsigned init_sec_frag_cnt;
+
+asection* bbinfo_text_sec;
+asection* bbinfo_rodata_sec;
+asection* bbinfo_data_sec;
+asection* bbinfo_init_sec;
+asection* bbinfo_datarel_sec;
+
+int bbinfo_app;
+int bbinfo_handwritten_file;
+unsigned int bbinfo_last_inst_size;
+int bbinfo_last_inst_offset;
+fragS* bbinfo_last_frag;
+void bbinfo_initbb_handwritten(void);
+
+// store the shuffle information
+char* bbinfo_shuffle_info_buf = NULL;
+unsigned bbinfo_shuffle_info_buf_len = 0;
+
+
+// init the global variables
+void bbinfo_init(){
+  fixups_list_head = NULL;
+  mbbs_list_head = NULL;
+  mbbs_list_tail = NULL;
+  cur_function_id = 0;
+  cur_function_end_id = 0;
+  prev_function_id = 0;
+  last_symbol = NULL;
+  cur_block_id = 0;
+  function_head = 0;
+
+  text_sec_frag_cnt = 0;
+  rodata_sec_frag_cnt = 0;
+  data_sec_frag_cnt = 0;
+  datarel_sec_frag_cnt = 0;
+  init_sec_frag_cnt = 0;
+
+  bbinfo_text_sec = NULL;
+  bbinfo_rodata_sec = NULL;
+  bbinfo_data_sec = NULL;
+  bbinfo_init_sec = NULL;
+  bbinfo_datarel_sec = NULL;
+
+  bbinfo_app = 0;
+  bbinfo_handwritten_file = 1;
+
+  bbinfo_last_inst_size = 0;
+  bbinfo_last_inst_offset = 0;
+  fragS* bbinfo_last_frag = NULL;
+}
+
+// update the last_symbol global variable
+// exclude dedug defined label
+int update_last_symbol(symbolS *sym){
+  unsigned int size = sizeof(symbol_blacklist) / sizeof(char*);
+  const char* symbol_name = S_GET_NAME(sym);
+
+  if (!strcmp(symbol_name, "")){
+    as_warn (_("[bbInfo]: the symbol name is null"));
+    return -1;
+  }
+// check if the symbol_name is in black list
+  for (unsigned int i = 0; i < size; i++){
+    if(strstr(symbol_name, symbol_blacklist[i]))
+      return -1;
+  } 
+  last_symbol = sym;
+  return 0;
+}
+
+#ifdef BBINFO_DEBUG_MSG
+void save_to_tmp_directory(const char* file){
+  if (!file)
+    return;
+  char* tmp_file = "/tmp/bbinfo/";
+  char buf[100];
+  strcpy(buf, tmp_file);
+  srand(time(0));
+  unsigned rand_num = rand();
+  sprintf(buf, "cp %s /tmp/bbinfo/case_%x.s", file, rand_num);
+
+  as_warn(_("Execute %s"), buf);
+  system(buf);
+}
+#endif
+
+// generate shuffleInfo into protobuf
+void bbinfo_update_shuffle_info(void){
+ShuffleInfo__ReorderInfo reorder_info = SHUFFLE_INFO__REORDER_INFO__INIT;
+ShuffleInfo__ReorderInfo__BinaryInfo binary_info = 
+  SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;
+
+binary_info.has_rand_obj_offset = 1;
+binary_info.rand_obj_offset = 0; // should be update at linking time
+binary_info.has_main_addr_offset = 1;
+binary_info.main_addr_offset = 0; // should be update at linking time
+
+// 0 is ordinary c/c++ file. 
+// 1 is a source file contains inline assembly
+// 2 is standalone assembly file
+// TODO(binpang). Identify assemble file and inline 
+binary_info.has_src_type = 1;
+binary_info.src_type = 0;
+
+reorder_info.bin = &binary_info;
+
+unsigned bb_cnt = 0;
+unsigned text_fixp_cnt = 0;
+unsigned rodata_fixp_cnt = 0;
+unsigned data_fixp_cnt = 0;
+unsigned datarel_fixp_cnt = 0;
+unsigned init_fixp_cnt = 0;
+
+bbinfo_mbb* last_mbb = NULL;
+// count the basic block number
+for(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;
+    cur_mbb = cur_mbb->next){
+  if (!cur_mbb->sec || !cur_mbb->size){
+    continue;
+  }
+  //debug
+  if (last_mbb && !bbinfo_handwritten_file)
+    if (last_mbb->size + last_mbb->offset != cur_mbb->offset && last_mbb->sec == cur_mbb->sec){
+#ifdef BBINFO_DEBUG_MSG
+    as_warn(_("bb#%d, from %x to %x. last_mbb %d, its section is %s, last_mbb from %x to %x, last basic block added size %d"), 
+	bb_cnt, cur_mbb->offset, cur_mbb->offset + cur_mbb->size-1, (last_mbb->parent_frag->last_bb == last_mbb), cur_mbb->sec->name, last_mbb->offset, last_mbb->size+last_mbb->offset-1, last_mbb->parent_frag->last_bb_added_size);
+    
+    if (bbinfo_file_name){
+      save_to_tmp_directory (bbinfo_file_name);
+      bbinfo_file_name = NULL;
+    }
+#endif
+    }
+  
+  // record the last basic block of every section
+  if (!cur_mbb->next || cur_mbb->next->sec != cur_mbb->sec){
+    bbinfo_sec_last_bb* current_sec_last_bb = sec_last_bb_head;
+    while(current_sec_last_bb && current_sec_last_bb->sec != cur_mbb->sec){
+      current_sec_last_bb = current_sec_last_bb->next;
+    }
+    // the list doesn't have the section record
+    if (!current_sec_last_bb){
+      bbinfo_sec_last_bb* tmp_sec_last_bb = malloc(sizeof(bbinfo_sec_last_bb));
+      memset(tmp_sec_last_bb, 0, sizeof(bbinfo_sec_last_bb));
+      // add the malloced bbinfo_sec_last_bb into the list
+      tmp_sec_last_bb->next = sec_last_bb_head;
+      tmp_sec_last_bb->offset = cur_mbb->offset;
+      tmp_sec_last_bb->sec = cur_mbb->sec;
+      sec_last_bb_head = tmp_sec_last_bb;
+    }else{
+      // we find the bbinfo_sec_last_bb
+      if (current_sec_last_bb->offset < cur_mbb->offset)
+	current_sec_last_bb->offset = cur_mbb->offset;
+    }
+  }
+
+  bb_cnt++;
+  last_mbb = cur_mbb;
+}
+
+
+// count the fixp number
+for(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;
+    cur_fixp = cur_fixp->next){
+
+  // Bug here. The fixup does not have its parent section
+  if (!cur_fixp->sec){
+    as_warn(_("Bug here. The fixup does not have its parent section\n"));
+
+#ifdef BBINFO_DEBUG_MSG
+    if (bbinfo_file_name){
+      save_to_tmp_directory(bbinfo_file_name);
+      bbinfo_file_name = NULL;
+    }
+#endif
+    continue;
+  }
+
+  if (bbinfo_is_new_sec_frag(cur_fixp->sec) == 1)
+    cur_fixp->is_new_section = 1;
+
+  const char* sec_name =cur_fixp->sec->name;
+  if (strstr(sec_name, ".text"))
+    text_fixp_cnt++;
+  else if(strstr(sec_name, ".rodata"))
+    rodata_fixp_cnt++;
+  else if(strstr(sec_name, ".init_array"))
+    init_fixp_cnt++;
+  else if(strstr(sec_name, ".data.rel.ro"))
+    datarel_fixp_cnt++;
+  else if(strstr(sec_name, ".data"))
+    data_fixp_cnt++;
+}
+
+ShuffleInfo__ReorderInfo__LayoutInfo **layout;
+layout = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo *) * bb_cnt);
+unsigned index = 0;
+unsigned obj_size = 0;
+asection* last_sec = NULL;
+
+#ifdef BBINFO_DEBUG_MSG
+unsigned bb_fix_num = 0;
+#endif
+
+for(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;
+    cur_mbb = cur_mbb->next){
+
+  // Bug here. The basic block does not have its parent section
+  if (!cur_mbb->sec){
+
+// debug, save the failed asm file into /tmp/bbinfo/ directory
+#ifdef BBINFO_DEBUG_MSG
+    as_warn(_("The basic block[%d] does not have its parent section, its size is %d"), cur_mbb->ID, cur_mbb->size);
+    if (bbinfo_file_name && cur_mbb->size){
+      save_to_tmp_directory(bbinfo_file_name);
+      bbinfo_file_name = NULL;
+    }
+#endif
+    continue;
+  }
+  if (!cur_mbb->size)
+	  continue;
+
+#ifdef BBINFO_DEBUG_MSG
+  bb_fix_num += cur_mbb->num_fixs;
+#endif
+
+  layout[index] = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo));
+
+  shuffle_info__reorder_info__layout_info__init(layout[index]);
+  layout[index]->has_type = 1;
+  layout[index]->type = cur_mbb->type;
+  layout[index]->has_bb_size = 1;
+  layout[index]->bb_size = cur_mbb->size;
+  layout[index]->has_bb_fallthrough = 1;
+  layout[index]->bb_fallthrough = cur_mbb->fall_through;
+  layout[index]->has_num_fixups = 1;
+  layout[index]->num_fixups = cur_mbb->num_fixs;
+  layout[index]->section_name = (char*)cur_mbb->sec->name;
+  layout[index]->has_padding_size= 1;
+  layout[index]->padding_size = cur_mbb->alignment;
+
+  layout[index]->has_assemble_type = 1;
+  if (cur_mbb->is_inline)
+    layout[index]->assemble_type = 1;
+  if (bbinfo_handwritten_file)
+    layout[index]->assemble_type = 2; // current file is assemble file
+  				      // so the basic block is a `fake` basic block
+  // DEBUG
+#ifdef BBINFO_DEBUG_MSG
+  if (cur_mbb->is_inline || bbinfo_handwritten_file){
+      if (bbinfo_file_name){ 
+	  save_to_tmp_directory (bbinfo_file_name);
+	  bbinfo_file_name = NULL;
+      }
+  }
+  if (cur_mbb->is_inline){
+    as_warn("[bbinfo]: basic block contains inline assemble code");
+  }
+#endif
+
+
+  unsigned char is_last_bb = 0;
+ /* if (index == bb_cnt - 1){
+    if (layout[index]->type == 1)
+      layout[index]->type = 3; // 3 represents that it is both function and object end
+    else
+      layout[index]->type = 2;
+  }
+  // the last basic block is tail of last section.
+  else if (last_sec && last_sec != cur_mbb->sec){
+    if (layout[index-1]->type == 1)
+      layout[index-1]->type = 3;
+    else
+      layout[index-1]->type = 2;
+  }*/
+  layout[index]->has_offset = 1;
+  layout[index]->offset = cur_mbb->offset;
+
+  bbinfo_sec_last_bb* cur_sec_last = sec_last_bb_head;
+  while(cur_sec_last && cur_sec_last->sec != cur_mbb->sec){
+    cur_sec_last = cur_sec_last->next;
+  }
+  // the list does not record the basic block's section
+  if (!cur_sec_last){
+    as_warn("[bbinfo]: the basic block 0x%x section %s does not record",
+		cur_mbb->offset, cur_mbb->sec->name);
+    exit(-1);
+  }
+
+  // current basic block is the end of the its section
+  if(cur_sec_last->offset == cur_mbb->offset){
+    if (layout[index]->type == 1)
+      layout[index]->type = 3; // 3 represents that it is both function and object end
+    else
+      layout[index]->type = 2;
+  }
+  
+
+#ifdef BBINFO_DEBUG_MSG
+  printf("[bbinfo]: bb%d - offset 0x%x, size 0x%x, alignment is %d, type %d, last bb added size %d, sec %s\n", 
+		  index, cur_mbb->offset, cur_mbb->size, cur_mbb->alignment, cur_mbb->type, last_mbb->parent_frag->last_bb_added_size, cur_mbb->sec->name);
+#endif
+
+  index++;
+  
+  obj_size += cur_mbb->size;
+  last_sec = cur_mbb->sec;
+}
+
+// mark the last basic block as the end of object
+/*if (index > 0){
+  if (layout[index-1]->type == 1)
+    layout[index-1]->type = 3; // 3 represents that it is both function and object end
+  else
+    layout[index-1]->type = 2;
+}
+
+// FIXME: specifal case: function .cold part and its main part will seperate.
+if (index > 1){
+ if (layout[index-1]->offset != (layout[index-2]->offset + layout[index-2]->bb_size)){ // the last basic block may be the .cold part
+#ifdef BBINFO_DEBUG_MSG
+   as_warn("[bbinfo]: The last basic block offset: 0x%x may be the .cold part", layout[index-1]->offset);
+#endif
+   if (layout[index-2]->type == 1)
+     layout[index-2]->type = 3;
+   else
+     layout[index-2]->type = 2;
+ }
+}
+*/
+
+#ifdef BBINFO_DEBUG_MSG
+if (bb_fix_num != text_fixp_cnt){
+  as_warn(_("basic block's fixup number[%d] does not equal to total fixups number[%d]"), bb_fix_num, text_fixp_cnt);
+if (bbinfo_file_name){
+    save_to_tmp_directory(bbinfo_file_name);
+    bbinfo_file_name = NULL;
+  }
+}
+#endif
+
+binary_info.has_obj_sz = 1;
+binary_info.obj_sz = obj_size;
+
+// update layout_info
+reorder_info.n_layout = index;
+reorder_info.layout = layout;
+
+ShuffleInfo__ReorderInfo__FixupInfo **fixup;
+fixup = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo *) * 1);
+fixup[0] = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo));
+shuffle_info__reorder_info__fixup_info__init(fixup[0]);
+
+ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text_fixp = NULL;
+ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata_fixp = NULL;
+ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data_fixp = NULL;
+ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel_fixp = NULL;
+ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **init_fixp = NULL;
+
+if (text_fixp_cnt)
+  text_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) * 
+    								text_fixp_cnt);
+if (rodata_fixp_cnt)
+  rodata_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
+    								rodata_fixp_cnt);
+if (data_fixp_cnt)
+  data_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
+      								data_fixp_cnt);
+if (init_fixp_cnt)
+  init_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
+      								init_fixp_cnt);
+if (datarel_fixp_cnt)
+  datarel_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
+      								datarel_fixp_cnt);
+unsigned cur_text_index = 0;
+unsigned cur_rodata_index = 0;
+unsigned cur_data_index = 0;
+unsigned cur_datarel_index = 0;
+unsigned cur_init_index = 0;
+
+for (bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;
+    					cur_fixp = cur_fixp->next){
+  if (!cur_fixp->sec)
+    continue;
+
+  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *cur_fixp_tuple =
+    		malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple));
+  shuffle_info__reorder_info__fixup_info__fixup_tuple__init(cur_fixp_tuple); 
+  cur_fixp_tuple->offset = cur_fixp->offset;
+  cur_fixp_tuple->deref_sz = cur_fixp->size;
+  cur_fixp_tuple->is_rela = cur_fixp->is_rela;
+  cur_fixp_tuple->section_name = (char*) cur_fixp->sec->name;
+  // jump table information
+  if (cur_fixp->table_size){
+    cur_fixp_tuple->has_num_jt_entries = 1;
+    cur_fixp_tuple->num_jt_entries = cur_fixp->table_size;
+    cur_fixp_tuple->has_jt_entry_sz = 1;
+    cur_fixp_tuple->jt_entry_sz = cur_fixp->entry_size;
+  }
+
+  cur_fixp_tuple->has_type = 1;
+  if (cur_fixp->is_new_section){
+    cur_fixp_tuple->type = 4; // let linker know if there are multiple .text sections
+  }else{
+    cur_fixp_tuple->type = 0; // c2c, c2d, d2c, d2d default=0; should be updated by linker
+  }
+
+  int discard_cnt = 0;
+  const char* sec_name =cur_fixp->sec->name;
+  if (strstr(sec_name, ".text"))
+    text_fixp[cur_text_index++] = cur_fixp_tuple;  
+  else if(strstr(sec_name, ".rodata"))
+    rodata_fixp[cur_rodata_index++] = cur_fixp_tuple;
+  else if(strstr(sec_name, ".init_array"))
+    init_fixp[cur_init_index++] = cur_fixp_tuple;
+  else if(strstr(sec_name, ".data.rel.ro"))
+    datarel_fixp[cur_datarel_index++] = cur_fixp_tuple;
+  else if(strstr(sec_name, ".data"))
+    data_fixp[cur_data_index++] = cur_fixp_tuple;
+}
+
+// store the fixup information into protobuf
+fixup[0]->n_text = text_fixp_cnt;
+fixup[0]->text = text_fixp;
+fixup[0]->n_rodata = rodata_fixp_cnt;
+fixup[0]->rodata = rodata_fixp;
+fixup[0]->n_data = data_fixp_cnt;
+fixup[0]->data = data_fixp;
+fixup[0]->n_datarel = datarel_fixp_cnt;
+fixup[0]->datarel = datarel_fixp;
+fixup[0]->n_initarray = init_fixp_cnt;
+fixup[0]->initarray = init_fixp;
+
+reorder_info.n_fixup = 1;
+reorder_info.fixup = fixup;
+
+bbinfo_shuffle_info_buf_len = protobuf_c_message_get_packed_size(&reorder_info); // get protobuf bytes length
+
+bbinfo_shuffle_info_buf = malloc(bbinfo_shuffle_info_buf_len);
+protobuf_c_message_pack(&reorder_info, bbinfo_shuffle_info_buf); // Pack reorder_info into buf
+
+// free the malloced space
+
+// free layouts
+for(index = 0; index < bb_cnt; index++){
+  free(layout[index]);
+}
+free(layout);
+
+// free fixups
+for (index = 0; index < text_fixp_cnt; index++){
+  free (text_fixp[index]);
+}
+for (index = 0; index < data_fixp_cnt; index++){
+  free (data_fixp[index]);
+}
+for (index = 0; index < rodata_fixp_cnt; index++){
+  free (rodata_fixp[index]);
+}
+for (index = 0; index < init_fixp_cnt; index++){
+  free (init_fixp[index]);
+}
+for (index = 0; index < datarel_fixp_cnt; index++){
+  free (datarel_fixp[index]);
+}
+if (text_fixp_cnt)
+ free (text_fixp); 
+if (rodata_fixp_cnt)
+ free (rodata_fixp);
+if (data_fixp_cnt)
+ free (data_fixp);
+if (init_fixp_cnt)
+ free (init_fixp);
+if (datarel_fixp_cnt)
+ free (datarel_fixp); 
+}
+#ifdef BBINFO_DEBUG_MSG
+// debug function
+int count_fixup_list_num(){
+  bbinfo_fixup* fixp;
+  int cnt = 0;
+  for (fixp = fixups_list_head; fixp; fixp = fixp->next, cnt++);
+  return cnt;
+}
+#endif
+
+// init the fixup struct and insert it into fixups_list serially
+bbinfo_fixup* bbinfo_init_insert_fixup(asection* sec, int offset){
+
+  bbinfo_fixup* result_fixup = malloc(sizeof(bbinfo_fixup));
+  // init
+  memset (result_fixup, 0, sizeof(bbinfo_fixup));
+  
+
+  if (fixups_list_head == NULL){
+    fixups_list_head = result_fixup;
+    return result_fixup;
+  }
+ 
+  bbinfo_fixup* prev = NULL;
+  bbinfo_fixup* cur = fixups_list_head;
+  // find the section that is equal to sec
+  while(cur && cur->sec != sec){
+    prev = cur;
+    cur = cur->next;
+  }
+
+  // The list does not have section sec
+  if (!cur){
+    prev->next = result_fixup;
+    return result_fixup;
+  }
+
+  // find the proper place accourding to its offset
+  while(cur && offset > cur->offset && cur->sec == sec){
+    prev = cur;
+    cur = cur->next;
+  }
+
+  // insert into the head
+  if (!prev){
+    result_fixup->next = fixups_list_head;
+    fixups_list_head = result_fixup;
+    return result_fixup;
+  }
+  prev->next = result_fixup;
+  result_fixup->next = cur;
+  return result_fixup;
+}
+
+/*
+// init the fixup struct
+bbinfo_fixup* bbinfo_init_fixup(void){
+  bbinfo_fixup *result_fixup = malloc(sizeof(bbinfo_fixup));
+  // init
+  memset(result_fixup, 0, sizeof(bbinfo_fixup)); 
+
+  // put it into the global fixups list
+  if (fixups_list_head == NULL){
+    fixups_list_head = result_fixup;
+  }else{
+    fixups_list_tail->next = result_fixup;
+  }
+  fixups_list_tail = result_fixup;
+  return result_fixup;
+}*/
+
+// check if this is the new section
+// TODO(binpang). Add it into a part of function bbinfo_is_new_sec
+char bbinfo_is_new_sec_frag(asection *sec){
+  // TODO. add new sections, such as .ctors, .fini_array, .dtors, .eh_frame ....
+  if (!sec){
+    as_warn(_("[bbinfo]: in function bbinfo_is_new_sec. The section is NULL"));
+    return -1;
+  }
+  const char* sec_name = sec->name;
+  char* tmp_pointer = NULL;
+  char returned_value = -1;
+  if ((tmp_pointer = strstr(sec_name, ".text")) &&
+      tmp_pointer == sec_name){
+
+    if (!text_sec_frag_cnt){
+      text_sec_frag_cnt++;
+      bbinfo_text_sec = sec;
+      returned_value = 0;
+    }
+    else{
+      returned_value = (bbinfo_text_sec == sec) ? 0 : 1;
+      if(returned_value) text_sec_frag_cnt++;
+      bbinfo_text_sec = sec;
+    }
+    return returned_value;
+  }
+
+  if ((tmp_pointer = strstr(sec_name, ".rodata")) && 
+	tmp_pointer == sec_name){
+
+    if (!rodata_sec_frag_cnt){
+      rodata_sec_frag_cnt++;
+      bbinfo_rodata_sec = sec;
+      returned_value = 0;
+    }else{
+      returned_value = (bbinfo_rodata_sec == sec) ? 0 : 1;
+      if (returned_value) rodata_sec_frag_cnt++;
+      bbinfo_rodata_sec = sec;
+    }
+    return returned_value;
+   }
+
+  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&
+      tmp_pointer == sec_name){
+    
+    if (!init_sec_frag_cnt){
+      init_sec_frag_cnt++;
+      bbinfo_init_sec = sec;
+      returned_value = 0;
+    } else {
+      returned_value = (bbinfo_init_sec == sec) ? 0 : 1;
+      if (returned_value) init_sec_frag_cnt++;
+      bbinfo_init_sec = sec;
+    }
+    return returned_value;
+  }
+
+  if ((tmp_pointer = strstr(sec_name, ".data")) &&
+      tmp_pointer == sec_name){
+
+    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&
+	tmp_pointer == sec_name){
+
+      if (!datarel_sec_frag_cnt){
+	datarel_sec_frag_cnt++;
+	bbinfo_datarel_sec = sec;
+	returned_value = 0;
+      } else {
+	returned_value = (bbinfo_datarel_sec == sec) ? 0 : 1;
+	if (returned_value) datarel_sec_frag_cnt++;
+	bbinfo_datarel_sec = sec;
+      }
+      return returned_value;
+    }
+
+    if (!data_sec_frag_cnt){
+      data_sec_frag_cnt++;
+      bbinfo_data_sec = sec;
+      returned_value = 0;
+    } else {
+      returned_value = (bbinfo_data_sec == sec) ? 0 : 1;
+      if (returned_value) data_sec_frag_cnt++;
+      bbinfo_data_sec = sec;
+    }
+
+    return returned_value;
+  }
+  return -1;
+}
+
+// if this section is the collected section
+// .text, .data.xxx, .rodata.xxxx, .init.xxx, .data.rel
+char bbinfo_is_collect_sec(asection *sec){
+  if (!sec){
+    as_warn(_("[bbinfo]: in function bbinfo_is_new_sec. The section is NULL"));
+    return -1;
+  }
+  const char* sec_name = sec->name;
+  char* tmp_pointer = NULL;
+  if ((tmp_pointer = strstr(sec_name, ".text")) &&
+      tmp_pointer == sec_name){
+      return 1;
+  }
+
+  if ((tmp_pointer = strstr(sec_name, ".rodata")) && 
+	tmp_pointer == sec_name){
+	return 1;
+      }
+
+  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&
+      tmp_pointer == sec_name){
+      return 1;
+  }
+
+  if ((tmp_pointer = strstr(sec_name, ".data")) &&
+      tmp_pointer == sec_name){
+
+    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&
+	tmp_pointer == sec_name){
+	return 1;
+    }
+      return 1;
+  }
+#ifdef BBINFO_DEBUG_MSG
+  as_warn("discard fixup in section %s", sec_name);
+#endif
+  return 0;
+}
+
+// init the bbinfo struct
+bbinfo_mbb* init_basic_block(){
+  // malloc space
+  bbinfo_mbb *result_mbb = malloc(sizeof(bbinfo_mbb));
+  memset(result_mbb, 0, sizeof(bbinfo_mbb));
+  result_mbb->next = NULL;
+
+  // put it into the global basic blocks list
+  if (mbbs_list_head == NULL){
+    mbbs_list_head = result_mbb;
+  }else{
+    mbbs_list_tail->next = result_mbb;
+  } 
+  mbbs_list_tail = result_mbb;
+  return result_mbb;
+}
+
+// handle bbinfo_jmptbl directive
+void jmptable_bbInfo_handler(int ignored ATTRIBUTE_UNUSED){
+    offsetT table_size, entry_size;
+    table_size = get_absolute_expression();
+    SKIP_WHITESPACE();
+    entry_size = get_absolute_expression();
+    if (last_symbol == NULL){
+	printf("Sorry, the last symbol is null\n");
+	return;
+    }
+    // update the jump table related information of the symbol
+    S_SET_JMPTBL_SIZE(last_symbol, table_size);
+    S_SET_JMPTBL_ENTRY_SZ(last_symbol, entry_size);
+    // debug
+    //printf("last_symbol is %s\n", S_GET_NAME(last_symbol));
+}
+
+void handwritten_funcb_bbinfo_handler(){
+  // make sure that current file is handwritten file
+  if (!bbinfo_handwritten_file)
+    return;
+  // if the last basic block is not used, we don't need initialize another basic block
+  if (mbbs_list_tail && mbbs_list_tail->is_begin)
+   return;
+ 
+  // we type the last basic block type as the end of the function
+  if (mbbs_list_tail){
+    //mbbs_list_tail->type = 1;
+    _mbbs_tmp_prev = mbbs_list_tail;
+  }
+  
+  
+    bbinfo_mbb *cur_mbb = init_basic_block();
+    cur_mbb->ID = cur_block_id++;
+    cur_mbb->type = 0;
+    cur_mbb->offset = -1;
+    cur_mbb->size = 0;
+    cur_mbb->alignment = 0;
+    cur_mbb->num_fixs = 0;
+    cur_mbb->fall_through = 0;
+    cur_mbb->sec = NULL;
+    cur_mbb->parent_id = cur_function_id;
+    cur_mbb->is_begin = 1;
+}
+
+void handwritten_funce_bbinfo_handler(){
+  if (!bbinfo_handwritten_file)
+    return;
+  if (!mbbs_list_tail)
+     as_fatal("[bbinfo]: funce_bbinfo_handler. the mbbs_list_tail is null");
+
+  if (mbbs_list_tail->is_begin && mbbs_list_tail->size == 0){
+    if (_mbbs_tmp_prev){
+      _mbbs_tmp_prev->type = 0;
+      free(mbbs_list_tail);
+      mbbs_list_tail = _mbbs_tmp_prev;
+      _mbbs_tmp_prev = NULL;
+    }
+    return;
+  }
+  mbbs_list_tail->type = 1;
+}
+
+// handle bbinfo_funcb directive, it represents function begin
+void funcb_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
+    prev_function_id = cur_function_id;
+    cur_function_id++;
+    function_head = 1;
+
+    // current file is c/c++ file
+    if (bbinfo_handwritten_file){
+      bbinfo_handwritten_file = 0;
+    }
+
+    if (mbbs_list_tail && mbbs_list_tail->is_begin)
+      return;
+
+    // Here, we initialize the bbinfo_mbb
+    // For some specifal case(such as c++ non-virtual thunk to function)
+    // gcc can't output basic block information
+    bbinfo_mbb *cur_mbb = init_basic_block();
+    cur_mbb->ID = cur_block_id++;
+    cur_mbb->type = 0;
+    cur_mbb->offset = -1;
+    cur_mbb->size = 0;
+    cur_mbb->alignment = 0;
+    cur_mbb->num_fixs = 0;
+    cur_mbb->fall_through = 0;
+    cur_mbb->sec = NULL;
+    cur_mbb->parent_id = cur_function_id;
+    cur_mbb->is_begin = 1;
+}
+
+// handle bbinfo_funce directive, it represents function end
+void funce_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
+   cur_function_end_id++;
+   if (!mbbs_list_tail){
+     as_fatal("[bbinfo]: funce_bbinfo_handler. the mbbs_list_tail is null");
+     exit(-1);
+   }
+   mbbs_list_tail->type = 1;
+   if (cur_function_end_id != cur_function_id)
+     as_warn(_("[bbInfo]: current function end id don not match current function id")); 
+}
+
+// For handwritten file, add `fake` basic block.
+void bbinfo_initbb_handwritten(void){
+    bbinfo_mbb *cur_mbb = init_basic_block();
+
+    // init the basic_block element
+    cur_mbb->ID = cur_block_id++;
+    cur_mbb->type = 0;
+    cur_mbb->offset = -1;
+    cur_mbb->size = 0;
+    cur_mbb->alignment = 0;
+    cur_mbb->num_fixs = 0;
+    cur_mbb->fall_through = 0;
+    cur_mbb->sec = NULL;
+    cur_mbb->parent_id = 0;
+    cur_mbb->is_begin = 1;
+
+
+}
+
+// handle bbinfo_bb directive, it represents basic block begin
+void bb_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
+    // The lastest basic block doesn't contain any instruction
+    // just return;
+    if (mbbs_list_tail && mbbs_list_tail->is_begin == 1)
+      return;
+    bbinfo_mbb *cur_mbb = init_basic_block();
+
+    // current file is c/c++ file
+    if (bbinfo_handwritten_file){
+      bbinfo_handwritten_file = 0;
+    }
+
+    // init the basic_block element
+    cur_mbb->ID = cur_block_id++;
+    cur_mbb->type = 0;
+    cur_mbb->offset = -1;
+    cur_mbb->size = 0;
+    cur_mbb->alignment = 0;
+    cur_mbb->num_fixs = 0;
+    cur_mbb->fall_through = 0;
+    cur_mbb->sec = NULL;
+    cur_mbb->parent_id = cur_function_id;
+    cur_mbb->is_begin = 1;
+
+    //if (function_head){
+    //  cur_mbb->type = 1; // this basic block is the first block of a function
+    //  function_head = 0;
+   // }
+
+}
+
+// handle bbinfo_be directive, it represents basic block end
+void be_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
+    offsetT fall_through;
+    fall_through = get_absolute_expression();
+    if (fall_through == 1)
+      mbbs_list_tail->fall_through = 1;
+}
+
+void inlineb_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
+    bbinfo_app = 1;  
+    if (mbbs_list_tail){
+      mbbs_list_tail->is_inline = 1;
+    }
+    #ifdef BBINFO_DEBUG_MSG
+      as_warn(_("[bbInfo]: Handle .bbinfo_inlineb"));
+    #endif
+}
+
+void inlinee_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
+    bbinfo_app = 0;
+    #ifdef BBINFO_DEBUG_MSG
+      as_warn(_("[bbInfo]: Handle .bbinfo_inlinee"));
+    #endif
+}
diff --git a/bbInfoHandle.h b/bbInfoHandle.h
new file mode 100644
index 0000000..26d32e9
--- /dev/null
+++ b/bbInfoHandle.h
@@ -0,0 +1,122 @@
+/* bbInfoHandle.h
+ *
+ * Handle basic block related directives
+ */
+
+#ifndef BBINFOHANDLE_H
+#define BBINFOHANDLE_H
+
+// debug macro
+// #define BBINFO_DEBUG_MSG
+
+#include "as.h"
+#include "shuffleInfo.pb-c.h"
+#include <stdint.h>
+
+extern const pseudo_typeS bbInfo_pseudo_table[];
+extern int update_last_symbol(symbolS*);
+extern void init_bbinfo_global(void);
+extern void bbinfo_init(void);
+extern char bbinfo_is_collect_sec(asection*);
+extern char bbinfo_is_new_sec_frag(asection*);
+extern void handwritten_funcb_bbinfo_handler();
+extern void handwritten_funce_bbinfo_handler();
+
+#ifdef BBINFO_DEBUG_MSG
+extern char *bbinfo_file_name;
+#endif
+
+// section's last basic block
+typedef struct sec_last_bb{
+  asection *sec;
+  asection *offset;
+  struct sec_last_bb *next;
+} bbinfo_sec_last_bb;
+
+// basic block related information
+struct basic_block{
+  uint32_t ID; // basic block id, every basic block has unique id in an object
+  uint8_t type; // basic block type: basic block or function boundary.
+ 		// 0 represents basic block. 1 represents function end. 2 represents object end
+  uint32_t offset; // offset from the section
+  int size; // basic block size, include alignment size
+  uint32_t alignment; // basic block alignment size
+  uint32_t num_fixs; // number fixups
+  unsigned char fall_through; // whether the basic block is fall through
+  asection *sec; // which section the basic block belongs to
+  struct basic_block *next; // link next basic blosk
+  uint32_t parent_id; // function id
+  uint8_t is_begin; // if current instruction is the first instruction of this basic block
+  uint8_t is_inline; // if current basic block contains inline assemble code or current basic block
+  fragS *parent_frag; // this basic block belongs to which frag.
+  		      // FIXME. I'm not sure if there exists a basic block cross two fragS.
+};
+
+typedef struct basic_block bbinfo_mbb;
+
+
+// fixup information
+typedef struct fixup{
+  uint32_t offset; // offset from section
+  asection *sec; // which section the basic block belongs to
+  unsigned char is_new_section; // if its parent section is the new section that has the same name
+  unsigned char is_rela; // if this fixup is relative
+  uint32_t size; // the reference's size
+  uint32_t table_size; // for jump table reference only
+  uint32_t entry_size; // for jump table reference only
+  struct fixup *next; // link next fixup
+} bbinfo_fixup;
+
+extern bbinfo_sec_last_bb* sec_last_bb_head;
+extern bbinfo_fixup* fixups_list_head; // fixup list
+extern bbinfo_fixup* fixups_list_tail; // last element of fixups list
+extern bbinfo_mbb* mbbs_list_head; // basic blocks list
+extern bbinfo_mbb* mbbs_list_tail; // the last element of basic blocks list
+extern uint32_t cur_function_id; // current function id
+extern uint32_t prev_function_id; // prev function id
+extern uint32_t cur_function_end_id; // current function end id
+extern symbolS *last_symbol; // last user defined symbol
+extern uint32_t cur_block_id; // global current basic block id
+// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number
+extern unsigned text_sec_cnt;
+extern unsigned rodata_sec_cnt;
+extern unsigned data_sec_cnt;
+extern unsigned datarel_sec_cnt;
+extern unsigned init_sec_cnt;
+
+extern unsigned text_sec_frag_cnt;
+extern unsigned rodata_sec_frag_cnt;
+extern unsigned data_sec_frag_cnt;
+extern unsigned datarel_sec_frag_cnt;
+extern unsigned init_sec_frag_cnt;
+
+extern asection *bbinfo_text_sec;
+extern asection *bbinfo_rodata_sec;
+extern asection *bbinfo_data_sec;
+extern asection *bbinfo_init_sec;
+extern asection *bbinfo_datarel_sec;
+extern const char* handwritten_bbinfo_func_name;
+
+// This is the symbol that represent that current basic block
+// contains inline assemble code
+extern int bbinfo_app;
+
+// represents that current assemble file is hand-written file
+// For handwritten file, we can't get accurate basic block and function information,
+// so we create `fake` basic block that contains continuous instructions
+extern int bbinfo_handwritten_file;
+extern void bbinfo_initbb_handwritten(void);
+
+// it is used to begin a new `fake` basic block
+extern int bbinfo_last_inst_offset;
+extern unsigned int bbinfo_last_inst_size;
+extern fragS* bbinfo_last_frag;
+
+// shuffleInfo that CCR defines
+extern char* bbinfo_shuffle_info_buf; 
+extern unsigned bbinfo_shuffle_info_buf_len;
+
+extern bbinfo_fixup* bbinfo_init_fixup(void);
+extern bbinfo_fixup* bbinfo_init_insert_fixup(asection*, int);
+extern void bbinfo_update_shuffle_info(void);
+#endif
diff --git a/config/obj-aout.c b/config/obj-aout.c
index 3c8e867..9b5ffa2 100644
--- a/config/obj-aout.c
+++ b/config/obj-aout.c
@@ -180,6 +180,7 @@ obj_aout_type (int ignore ATTRIBUTE_UNUSED)
   char *name;
   int c;
   symbolS *sym;
+  //as_fatal("HELLO, obj_aout type!");
 
   c = get_symbol_name (&name);
   sym = symbol_find_or_make (name);
diff --git a/config/obj-elf.c b/config/obj-elf.c
index ae9b2e1..95cd4cc 100644
--- a/config/obj-elf.c
+++ b/config/obj-elf.c
@@ -68,6 +68,8 @@
 #include "elf/pru.h"
 #endif
 
+#include "bbInfoHandle.h"
+
 static void obj_elf_line (int);
 static void obj_elf_size (int);
 static void obj_elf_type (int);
@@ -1867,6 +1869,17 @@ obj_elf_size (int ignore ATTRIBUTE_UNUSED)
   expressionS exp;
   symbolS *sym;
 
+  // binpang, add.
+  // To get the handwritten function end boundary
+  if (bbinfo_handwritten_file){
+    //as_warn("[bbinfo]: DEBUG. handwritten_bbinfo_func_name is %s", handwritten_bbinfo_func_name);
+    //as_warn("[bbinfo]: DEBUG. symbol name is %s", name);
+    if (handwritten_bbinfo_func_name && !strcmp(handwritten_bbinfo_func_name, name)){
+      //as_warn("[bbinfo]: DEBUG. Hello, call handwritten_funce_bbinfo_handler()!");
+      handwritten_funce_bbinfo_handler();
+    }
+  }
+
   p = input_line_pointer;
   *p = c;
   SKIP_WHITESPACE_AFTER_NAME ();
@@ -1973,8 +1986,17 @@ obj_elf_type (int ignore ATTRIBUTE_UNUSED)
   type = 0;
   if (strcmp (type_name, "function") == 0
       || strcmp (type_name, "2") == 0
-      || strcmp (type_name, "STT_FUNC") == 0)
+      || strcmp (type_name, "STT_FUNC") == 0){
     type = BSF_FUNCTION;
+
+    // binpang, add.
+    // To get the handwritten function begin boundary
+    if (bbinfo_handwritten_file){
+      //as_warn("[bbinfo]: DEBUG. Hello, call handwritten_funcb_bbinfo_handler()!");
+      handwritten_funcb_bbinfo_handler();
+      handwritten_bbinfo_func_name = sym->bsym->name;
+    }
+  }
   else if (strcmp (type_name, "object") == 0
 	   || strcmp (type_name, "1") == 0
 	   || strcmp (type_name, "STT_OBJECT") == 0)
diff --git a/config/tc-i386.c b/config/tc-i386.c
index 5cd83da..25cbcc0 100644
--- a/config/tc-i386.c
+++ b/config/tc-i386.c
@@ -33,6 +33,8 @@
 #include "elf/x86-64.h"
 #include "opcodes/i386-init.h"
 
+#include "bbInfoHandle.h" //binpang add
+
 #ifndef REGISTER_WARNINGS
 #define REGISTER_WARNINGS 1
 #endif
@@ -392,6 +394,7 @@ struct _i386_insn
 
     /* Error message.  */
     enum i386_error error;
+
   };
 
 typedef struct _i386_insn i386_insn;
@@ -4618,6 +4621,12 @@ optimize_disp (void)
 	    i.types[op].bitfield.disp32 = 0;
 	    i.types[op].bitfield.disp32s = 0;
 	    i.types[op].bitfield.disp64 = 0;
+	    // binpang, add
+	    // update the basic block's fix number
+#if defined(__i386__) || defined(__x86_64__)
+	    if (mbbs_list_tail)
+	      mbbs_list_tail->num_fixs++;
+#endif
 	  }
  	else
 	  /* We only support 64bit displacement on constants.  */
@@ -6933,6 +6942,7 @@ build_modrm_byte (void)
 static void
 output_branch (void)
 {
+
   char *p;
   int size;
   int code16;
@@ -7091,6 +7101,12 @@ output_jump (void)
   fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
 		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
 
+  // binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+  if (mbbs_list_tail)
+    mbbs_list_tail->num_fixs++;
+#endif
+
   /* All jumps handled here are signed, but don't use a signed limit
      check for 32 and 16 bit jumps as we want to allow wrap around at
      4G and 64k respectively.  */
@@ -7153,9 +7169,15 @@ output_interseg_jump (void)
 	}
       md_number_to_chars (p, n, size);
     }
-  else
+  else{
     fix_new_exp (frag_now, p - frag_now->fr_literal, size,
 		 i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
+    // binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+    if (mbbs_list_tail)
+      mbbs_list_tail->num_fixs++;
+#endif
+  }
   if (i.op[0].imms->X_op != O_constant)
     as_bad (_("can't handle non absolute segment in `%s'"),
 	    i.tm.name);
@@ -7167,6 +7189,9 @@ output_insn (void)
 {
   fragS *insn_start_frag;
   offsetT insn_start_off;
+  
+  // binpang, add
+  uint32_t bbinfo_init_bb = 0;
 
   /* Tie dwarf2 debug info to the address at the start of the insn.
      We can't do this after the insn has been output as the current
@@ -7176,6 +7201,53 @@ output_insn (void)
   insn_start_frag = frag_now;
   insn_start_off = frag_now_fix ();
 
+
+#if defined(__i386__) || defined(__x86_64)
+  // update the basic block offset in current/last fragment
+  insn_start_frag->last_bb = mbbs_list_tail;
+  if (mbbs_list_tail && mbbs_list_tail->is_begin){
+    mbbs_list_tail->is_begin = 0;
+    mbbs_list_tail->offset = insn_start_off;
+    mbbs_list_tail->parent_frag = insn_start_frag;
+
+	if (bbinfo_app){
+		mbbs_list_tail->is_inline = 1;
+	}
+  } /* else if(!mbbs_list_tail){
+	  #ifdef BBINFO_DEBUG_MSG
+	  as_warn("[bbinfo]: handle handwritten file %s", bbinfo_file_name);
+	  #endif
+	  bbinfo_initbb_handwritten();
+	  mbbs_list_tail->is_begin = 0;
+	  mbbs_list_tail->offset = insn_start_off;
+	  mbbs_list_tail->parent_frag = insn_start_frag;
+  } */
+
+  // handle handwritten file
+  if (bbinfo_handwritten_file){
+	if (!mbbs_list_tail){
+		bbinfo_initbb_handwritten();
+		mbbs_list_tail->is_begin = 0;
+		mbbs_list_tail->offset = insn_start_off;
+		mbbs_list_tail->parent_frag = insn_start_frag;
+		bbinfo_last_frag = insn_start_frag;
+		insn_start_frag->last_bb = mbbs_list_tail;
+	}
+	// create a new `fake` basic block
+	else if (bbinfo_last_frag != insn_start_frag ||
+  			(bbinfo_last_inst_offset + bbinfo_last_inst_size) != insn_start_off){
+	  	bbinfo_initbb_handwritten();
+		mbbs_list_tail->is_begin = 0;
+		mbbs_list_tail->offset = insn_start_off;
+		mbbs_list_tail->parent_frag = insn_start_frag;
+		insn_start_frag->last_bb = mbbs_list_tail;
+		bbinfo_last_frag = insn_start_frag;
+	}
+	
+	bbinfo_last_inst_offset = insn_start_off;
+  }
+#endif
+
   /* Output jumps.  */
   if (i.tm.opcode_modifier.jump)
     output_branch ();
@@ -7205,6 +7277,39 @@ output_insn (void)
           offsetT val = 0x240483f0ULL;
           p = frag_more (5);
           md_number_to_chars (p, val, 5);
+
+// binpang add
+// get the last instruction size
+// the last basic block's size in fragment may change after fragment relocation 
+#if defined(__i386__) || defined(__x86_64__)
+  offsetT insn_size = 0;
+  if (insn_start_frag == frag_now){
+    insn_size = frag_now_fix() - insn_start_off; 
+  }else{
+    // last basic block in fragment may change in the frag relocation
+    // update its size after fragment relocation
+    insn_size = insn_start_frag->fr_fix - insn_start_off;
+    fragS *frag_tmp;
+    for (frag_tmp = insn_start_frag->fr_next; 
+	frag_tmp && frag_tmp != frag_now; frag_tmp = frag_tmp->fr_next){
+      insn_size += frag_tmp->fr_fix;
+      frag_tmp->last_bb = mbbs_list_tail;
+    }
+    insn_size += frag_now_fix();
+    frag_now->last_bb = mbbs_list_tail;
+  }
+
+  // update the basic block size
+  if (mbbs_list_tail)
+    mbbs_list_tail->size += (unsigned int)insn_size;
+
+  
+
+  // Attention: here, bbinfo_last_inst_size may not be the accurate instruction size
+  if (bbinfo_handwritten_file){
+	  bbinfo_last_inst_size = (unsigned int)insn_size;
+  }
+#endif
           return;
         }
 
@@ -7366,6 +7471,41 @@ check_prefix:
       pi ("" /*line*/, &i);
     }
 #endif /* DEBUG386  */
+
+// binpang add
+// get the last instruction size
+// the last basic block's size in fragment may change after fragment relocation 
+#if defined(__i386__) || defined(__x86_64__)
+  offsetT insn_size = 0;
+  if (insn_start_frag == frag_now){
+    insn_size = frag_now_fix() - insn_start_off; 
+  }else{
+    // last basic block in fragment may change in the frag relocation
+    // update its size after fragment relocation
+    insn_size = insn_start_frag->fr_fix - insn_start_off;
+    fragS *frag_tmp;
+    for (frag_tmp = insn_start_frag->fr_next; 
+	frag_tmp && frag_tmp != frag_now; frag_tmp = frag_tmp->fr_next){
+      insn_size += frag_tmp->fr_fix;
+      frag_tmp->last_bb = mbbs_list_tail;
+    }
+    insn_size += frag_now_fix();
+    frag_now->last_bb = mbbs_list_tail;
+  }
+
+  // update the basic block size
+  if (mbbs_list_tail)
+    mbbs_list_tail->size += (unsigned int)insn_size;
+  
+
+  // Attention: here, bbinfo_last_inst_size may not be the accurate instruction size
+  if (bbinfo_handwritten_file){
+	  bbinfo_last_inst_size = (unsigned int)insn_size;
+  }
+  
+#endif
+  
+  
 }
 
 /* Return the size of the displacement operand N.  */
@@ -7496,6 +7636,14 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)
 	      fixP = fix_new_exp (frag_now, p - frag_now->fr_literal,
 				  size, i.op[n].disps, pcrel,
 				  reloc_type);
+	      // binpang, add
+	      // update the basic block's fix number
+#if defined(__i386__) || defined(__x86_64__)
+	     if (mbbs_list_tail){
+	       mbbs_list_tail->num_fixs++;
+	     } 
+#endif
+
 	      /* Check for "call/jmp *mem", "mov mem, %reg",
 		 "test %reg, mem" and "binop mem, %reg" where binop
 		 is one of adc, add, and, cmp, or, sbb, sub, xor
@@ -7653,6 +7801,13 @@ output_imm (fragS *insn_start_frag, offsetT insn_start_off)
 		}
 	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
 			   i.op[n].imms, 0, reloc_type);
+	      // binpang, add
+	      // update the basic blocks fix number
+#if defined(__i386__) || defined(__x86_64__)
+	      if (mbbs_list_tail)
+		mbbs_list_tail->num_fixs++;
+#endif
+
 	    }
 	}
     }
@@ -9319,10 +9474,20 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
 	  /* Make jmp (0xeb) a (d)word displacement jump.  */
 	  opcode[0] = 0xe9;
 	  fragP->fr_fix += size;
+
 	  fix_new (fragP, old_fr_fix, size,
 		   fragP->fr_symbol,
 		   fragP->fr_offset, 1,
 		   reloc_type);
+
+	  // binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+	  if (fragP->last_bb)
+	    fragP->last_bb->num_fixs++;
+
+	  // update the added fix size
+	  fragP->last_bb_added_fix_size += size;
+#endif
 	  break;
 
 	case COND_JUMP86:
@@ -9342,6 +9507,15 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
 		       fragP->fr_symbol,
 		       fragP->fr_offset, 1,
 		       reloc_type);
+
+	  // binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+	  if (fragP->last_bb)
+	    fragP->last_bb->num_fixs++;
+
+	  // update the added fix size
+	  fragP->last_bb_added_fix_size += 2 + 2;
+#endif
 	      break;
 	    }
 	  /* Fall through.  */
@@ -9357,6 +9531,14 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
 			      fragP->fr_offset, 1,
 			      BFD_RELOC_8_PCREL);
 	      fixP->fx_signed = 1;
+	  // binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+	  if (fragP->last_bb)
+	    fragP->last_bb->num_fixs++;
+
+	  // update the added fix size
+	  fragP->last_bb_added_fix_size += 1;
+#endif
 	      break;
 	    }
 
@@ -9370,6 +9552,14 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
 		   fragP->fr_symbol,
 		   fragP->fr_offset, 1,
 		   reloc_type);
+	  // binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+	  if (fragP->last_bb)
+	    fragP->last_bb->num_fixs++;
+
+	  // update the added fix size
+	  fragP->last_bb_added_fix_size += 1 + size;
+#endif
 	  break;
 
 	default:
@@ -9399,9 +9589,13 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
 	Caller will turn frag into a ".space 0".  */
 
 void
-md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
+md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec,
                  fragS *fragP)
 {
+  // binpang, add
+  // record added opcodes size
+  unsigned add_opcodes = 0;
+
   unsigned char *opcode;
   unsigned char *where_to_put_displacement = NULL;
   offsetT target_address;
@@ -9450,6 +9644,9 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
 	case ENCODE_RELAX_STATE (COND_JUMP, BIG):
 	case ENCODE_RELAX_STATE (COND_JUMP86, BIG):
 	  extension = 5;		/* 2 opcode + 4 displacement  */
+	  // binpang, add
+	  add_opcodes = 1;
+
 	  opcode[1] = opcode[0] + 0x10;
 	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
 	  where_to_put_displacement = &opcode[2];
@@ -9457,6 +9654,9 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
 
 	case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
 	  extension = 3;		/* 2 opcode + 2 displacement  */
+	  // binpang, add
+	  add_opcodes = 1;
+
 	  opcode[1] = opcode[0] + 0x10;
 	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
 	  where_to_put_displacement = &opcode[2];
@@ -9494,6 +9694,24 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
   md_number_to_chars ((char *) where_to_put_displacement,
 		      (valueT) (displacement_from_opcode_start - extension),
 		      DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
+  
+#if defined(__i386__) || defined(__x86_64__)
+  char is_new_sec = bbinfo_is_collect_sec(sec);
+  if (is_new_sec)
+  {
+    // binpang, add fixup doesn't in fixup list
+    int tmp_offset = fragP->fr_address + fragP->fr_fix + add_opcodes;
+    bbinfo_fixup* tmp_fix = bbinfo_init_insert_fixup(sec, tmp_offset);
+    tmp_fix->sec = sec;
+    tmp_fix->offset = tmp_offset;
+    tmp_fix->is_new_section = 0;
+    tmp_fix->is_rela = 1; // this fixup is always pc-relative
+    tmp_fix->size = extension - add_opcodes;
+    if (fragP->last_bb)
+      fragP->last_bb->num_fixs++;
+  }
+#endif
+
   fragP->fr_fix += extension;
 }
 
diff --git a/config/tc-ia64.c b/config/tc-ia64.c
index 7976624..73ef1e4 100644
--- a/config/tc-ia64.c
+++ b/config/tc-ia64.c
@@ -11096,6 +11096,8 @@ ia64_cons_fix_new (fragS *f, int where, int nbytes, expressionS *exp,
 static bfd_reloc_code_real_type
 ia64_gen_real_reloc_type (struct symbol *sym, bfd_reloc_code_real_type r_type)
 {
+
+
   bfd_reloc_code_real_type newr = 0;
   const char *type = NULL, *suffix = "";
 
diff --git a/frags.c b/frags.c
index 170fd97..412f166 100644
--- a/frags.c
+++ b/frags.c
@@ -198,6 +198,14 @@ frag_new (size_t old_frags_var_max_size
   gas_assert (frchain_now->frch_last == frag_now);
 
   frag_now->fr_next = NULL;
+
+#if defined(__i386__) || defined(__x86_64__)
+  // binpang, add
+  // init frag bbInfo related element
+  frag_now->last_bb = NULL;
+  frag_now->bb_offset = 0;
+  frag_now->last_bb_added_size = 0;
+#endif
 }
 
 /* Start a new frag unless we have n more chars of room in the current frag.
diff --git a/frags.h b/frags.h
index 28205c6..312667b 100644
--- a/frags.h
+++ b/frags.h
@@ -21,7 +21,9 @@
 #ifndef FRAGS_H
 #define FRAGS_H
 
+
 struct obstack;
+struct basic_block;
 
 /* A code fragment (frag) is some known number of chars, followed by some
    unknown number of chars. Typically the unknown number of chars is an
@@ -103,6 +105,15 @@ struct frag {
   OBJ_FRAG_TYPE obj_frag_data;
 #endif
 
+// binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+struct basic_block *last_bb; // last basic block in this fragment
+unsigned int bb_offset; // basic block offset in this fragment
+offsetT last_bb_added_size; // last basic block may be added
+offsetT last_bb_added_fix_size; // fr_fix added number
+asection *parent; // which section it belongs to
+#endif
+
   /* Data begins here.  */
   char fr_literal[1];
 };
diff --git a/libshuffleInfo.so b/libshuffleInfo.so
new file mode 100755
index 0000000..466ec8e
Binary files /dev/null and b/libshuffleInfo.so differ
diff --git a/makefile.vms b/makefile.vms
index e7d88ed..421ce3f 100644
--- a/makefile.vms
+++ b/makefile.vms
@@ -43,7 +43,7 @@ OBJS:=targ-cpu.obj,obj-format.obj,atof-targ.obj,app.obj,as.obj,\
   frags.obj,hash.obj,input-file.obj,\
   input-scrub.obj,literal.obj,messages.obj,output-file.obj,read.obj,\
   subsegs.obj,symbols.obj,write.obj,listing.obj,ecoff.obj,stabs.obj,sb.obj,\
-  macro.obj,ehopt.obj,dw2gencfi.obj,dwarf2dbg.obj,remap.obj
+  macro.obj,ehopt.obj,dw2gencfi.obj,dwarf2dbg.obj,remap.obj,bbInfoHandle.obj
 
 ifeq ($(ARCH),IA64)
 OBJS:=$(OBJS),te-vms.obj
diff --git a/patch_8dd86a1 b/patch_8dd86a1
new file mode 100644
index 0000000..fc13bd5
--- /dev/null
+++ b/patch_8dd86a1
@@ -0,0 +1,8960 @@
+diff --git a/.c b/.c
+new file mode 100644
+index 0000000..3d186c2
+--- /dev/null
++++ b/.c
+@@ -0,0 +1,89 @@
++/* bbInfoHandle.h
++ *
++ * Handle basic block related directives
++ */
++
++#ifndef BBINFOHANDLE_H
++#define BBINFOHANDLE_H
++
++#include "as.h"
++#include "shuffleInfo.pb-c.h"
++#include <stdint.h>
++
++extern const pseudo_typeS bbInfo_pseudo_table[];
++extern int update_last_symbol(symbolS*);
++extern void init_bbinfo_global(void);
++extern void bbinfo_init(void);
++extern char bbinfo_is_new_sec(asection*);
++extern char bbinfo_is_new_sec_frag(asection*);
++
++
++
++// basic block related information
++struct basic_block{
++  uint32_t ID; // basic block id, every basic block has unique id in an object
++  uint8_t type; // basic block type: basic block or function boundary.
++ 		// 0 represents basic block. 1 represents function start. 2 represents object end
++  uint32_t offset; // offset from the section
++  int size; // basic block size
++  uint32_t alignment; // basic block alignment
++  uint32_t num_fixs; // number fixups
++  unsigned char fall_through; // whether the basic block is fall through
++  asection *sec; // which section the basic block belongs to
++  struct basic_block *next; // link next basic blosk
++  uint32_t parent_id; // function id
++  uint8_t is_begin; // if current instruction is the first instruction of this basic block
++  fragS *parent_frag; // this basic block belongs to which frag.
++  		      // FIXME. I'm not sure if there exists a basic block cross two fragS.
++};
++
++typedef struct basic_block bbinfo_mbb;
++
++
++// fixup information
++typedef struct fixup{
++  uint32_t offset; // offset from section
++  asection *sec; // which section the basic block belongs to
++  unsigned char is_new_section; // if its parent section is the new section that has the same name
++  unsigned char is_rela; // if this fixup is relative
++  uint32_t size; // the reference's size
++  uint32_t table_size; // for jump table reference only
++  uint32_t entry_size; // for jump table reference only
++  struct fixup *next; // link next fixup
++} bbinfo_fixup;
++
++extern bbinfo_fixup* fixups_list_head; // fixup list
++extern bbinfo_fixup* fixups_list_tail; // last element of fixups list
++extern bbinfo_mbb* mbbs_list_head; // basic blocks list
++extern bbinfo_mbb* mbbs_list_tail; // the last element of basic blocks list
++extern uint32_t cur_function_id; // current function id
++extern uint32_t prev_function_id; // prev function id
++extern uint32_t cur_function_end_id; // current function end id
++extern symbolS *last_symbol; // last user defined symbol
++extern uint32_t cur_block_id; // global current basic block id
++// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number
++extern unsigned text_sec_cnt;
++extern unsigned rodata_sec_cnt;
++extern unsigned data_sec_cnt;
++extern unsigned datarel_sec_cnt;
++extern unsigned init_sec_cnt;
++
++extern unsigned text_sec_frag_cnt;
++extern unsigned rodata_sec_frag_cnt;
++extern unsigned data_sec_frag_cnt;
++extern unsigned datarel_sec_frag_cnt;
++extern unsigned init_sec_frag_cnt;
++
++extern asection *bbinfo_text_sec;
++extern asection *bbinfo_rodata_sec;
++extern asection *bbinfo_data_sec;
++extern asection *bbinfo_init_sec;
++extern asection *bbinfo_datarel_sec;
++
++// shuffleInfo that CCR defines
++extern char* bbinfo_shuffle_info_buf; 
++extern unsigned bbinfo_shuffle_info_buf_len;
++
++extern bbinfo_fixup* bbinfo_init_fixup(void);
++extern void bbinfo_update_shuffle_info(void);
++#endif
+diff --git a/Makefile.am b/Makefile.am
+index 5aa68f3..e882179 100644
+--- a/Makefile.am
++++ b/Makefile.am
+@@ -70,6 +70,8 @@ GAS_CFILES = \
+ 	depend.c \
+ 	dwarf2dbg.c \
+ 	dw2gencfi.c \
++	bbInfoHandle.c \
++	shuffleInfo.pb-c.c \
+ 	ecoff.c \
+ 	ehopt.c \
+ 	expr.c \
+@@ -104,6 +106,8 @@ HFILES = \
+ 	compress-debug.h \
+ 	dwarf2dbg.h \
+ 	dw2gencfi.h \
++	bbInfoHandle.h \
++	shuffleInfo.pb-c.h \
+ 	ecoff.h \
+ 	emul-target.h \
+ 	emul.h \
+diff --git a/Makefile.in b/Makefile.in
+index 51e96e5..57629ff 100644
+--- a/Makefile.in
++++ b/Makefile.in
+@@ -117,7 +117,9 @@ am__objects_1 = app.$(OBJEXT) as.$(OBJEXT) atof-generic.$(OBJEXT) \
+ 	listing.$(OBJEXT) literal.$(OBJEXT) macro.$(OBJEXT) \
+ 	messages.$(OBJEXT) output-file.$(OBJEXT) read.$(OBJEXT) \
+ 	remap.$(OBJEXT) sb.$(OBJEXT) stabs.$(OBJEXT) subsegs.$(OBJEXT) \
+-	symbols.$(OBJEXT) write.$(OBJEXT)
++	symbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) \
++	shuffleInfo.pb-c.$(OBJEXT)
++	
+ am_as_new_OBJECTS = $(am__objects_1)
+ as_new_OBJECTS = $(am_as_new_OBJECTS)
+ am__DEPENDENCIES_1 =
+@@ -367,6 +369,8 @@ GAS_CFILES = \
+ 	depend.c \
+ 	dwarf2dbg.c \
+ 	dw2gencfi.c \
++	bbInfoHandle.c \
++	shuffleInfo.pb-c.c \
+ 	ecoff.c \
+ 	ehopt.c \
+ 	expr.c \
+@@ -400,6 +404,8 @@ HFILES = \
+ 	compress-debug.h \
+ 	dwarf2dbg.h \
+ 	dw2gencfi.h \
++	bbInfoHandle.h \
++	shuffleInfo.pb-c.h \
+ 	ecoff.h \
+ 	emul-target.h \
+ 	emul.h \
+@@ -820,6 +826,7 @@ distclean-compile:
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/depend.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dw2gencfi.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dwarf2dbg.Po@am__quote@
++@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bbInfoHandle.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-crisaout.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-criself.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/e-i386aout.Po@am__quote@
+diff --git a/README b/README.as
+similarity index 100%
+rename from README
+rename to README.as
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..ea65688
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,35 @@
++binutils-2.30
++
++- handle basic block dummy directives [06/08/2019]
++- fix basic block size and fixups [18/08/2019]
++
++## TODO
++
++- [ ] Handle assemble file and inline assemble statement
++- [x] Handle the new section for fragment
++- [x] fix basic block size
++- [x] basic block's fixup number equal to total fixup number in .text.xxx section
++- [x] figure out what are .text.startup, .text.hot, .text.exit and .text.unlikely section
++- [x] Support LTO optimization
++- [ ] Handle other sections' fixups(.eh\_frame .etc)
++- [x] add padding size of basic block
++- [ ] There is problem that compile with static link: `-static-libstdc++ -static-libgcc`
++- [ ] .fini\_array section's fixups
++- [ ] handle .init and .fini section
++
++## Problems
++
++- Can't handle fixups in section .plt and .got.plt
++- Can't handle the linker added functions. (We may handle it by compiling the glibc with our tool, but it seems that gold linker can't work correctly of compiling glibc)
++
++## Build
++
++- Install protobuf-c [link](https://github.com/protobuf-c/protobuf-c)
++
++- set CFLAGS and LDFLAGS
++```
++CFLAGS=`pkg-config --cflags 'libprotobuf-c >= 1.0.0'`
++LDFLAGS=`pkg-config --libs 'libprotobuf-c >= 1.0.0'`
++```
++
++
+diff --git a/as.c b/as.c
+index f6da1b1..45a5583 100644
+--- a/as.c
++++ b/as.c
+@@ -56,6 +56,11 @@
+ extern void gas_cgen_begin (void);
+ #endif
+ 
++// binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++#include "bbInfoHandle.h"
++#endif
++
+ /* We build a list of defsyms as we read the options, and then define
+    them after we have initialized everything.  */
+ struct defsym_list
+@@ -1252,6 +1257,11 @@ main (int argc, char ** argv)
+   itbl_init ();
+ 
+   dwarf2_init ();
++  
++  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++  bbinfo_init();
++#endif
+ 
+   local_symbol_make (".gasversion.", absolute_section,
+ 		     BFD_VERSION / 10000UL, &predefined_address_frag);
+diff --git a/autom4te.cache/output.0 b/autom4te.cache/output.0
+new file mode 100644
+index 0000000..e69de29
+diff --git a/autom4te.cache/output.1t b/autom4te.cache/output.1t
+new file mode 100644
+index 0000000..ec88dfd
+--- /dev/null
++++ b/autom4te.cache/output.1t
+@@ -0,0 +1 @@
++@%:@! /bin/sh
+diff --git a/autom4te.cache/requests b/autom4te.cache/requests
+new file mode 100644
+index 0000000..6d18deb
+--- /dev/null
++++ b/autom4te.cache/requests
+@@ -0,0 +1,79 @@
++# This file was generated by Autom4te Sun Aug 20 23:09:08 UTC 2017.
++# It contains the lists of macros which have been traced.
++# It can be safely removed.
++
++@request = (
++             bless( [
++                      '0',
++                      1,
++                      [
++                        '/usr/share/autoconf'
++                      ],
++                      [
++                        '/usr/share/autoconf/autoconf/autoconf.m4f',
++                        'aclocal.m4',
++                        'Makefile.am'
++                      ],
++                      {
++                        'AC_FC_PP_DEFINE' => 1,
++                        '_LT_AC_TAGCONFIG' => 1,
++                        'AC_INIT' => 1,
++                        'AC_CONFIG_SUBDIRS' => 1,
++                        'AM_PROG_CXX_C_O' => 1,
++                        'AM_SILENT_RULES' => 1,
++                        'AM_PATH_GUILE' => 1,
++                        'AC_CONFIG_AUX_DIR' => 1,
++                        'AC_LIBSOURCE' => 1,
++                        'AM_AUTOMAKE_VERSION' => 1,
++                        'AC_CANONICAL_BUILD' => 1,
++                        '_AM_MAKEFILE_INCLUDE' => 1,
++                        'AC_REQUIRE_AUX_FILE' => 1,
++                        'AM_XGETTEXT_OPTION' => 1,
++                        'AC_SUBST' => 1,
++                        'AC_CANONICAL_SYSTEM' => 1,
++                        'AC_PROG_LIBTOOL' => 1,
++                        'AC_CANONICAL_HOST' => 1,
++                        'm4_pattern_forbid' => 1,
++                        'AM_ENABLE_MULTILIB' => 1,
++                        'm4_include' => 1,
++                        'AM_PROG_LIBTOOL' => 1,
++                        '_m4_warn' => 1,
++                        'AM_GNU_GETTEXT_INTL_SUBDIR' => 1,
++                        'AC_CANONICAL_TARGET' => 1,
++                        'AC_FC_FREEFORM' => 1,
++                        'LT_CONFIG_LTDL_DIR' => 1,
++                        'AM_MAINTAINER_MODE' => 1,
++                        'include' => 1,
++                        'AM_MAKEFILE_INCLUDE' => 1,
++                        'AC_DEFINE_TRACE_LITERAL' => 1,
++                        '_AM_COND_ENDIF' => 1,
++                        'AC_CONFIG_FILES' => 1,
++                        'sinclude' => 1,
++                        'm4_pattern_allow' => 1,
++                        'AM_NLS' => 1,
++                        'AM_INIT_AUTOMAKE' => 1,
++                        'AC_FC_PP_SRCEXT' => 1,
++                        '_AM_COND_IF' => 1,
++                        'LT_SUPPORTED_TAG' => 1,
++                        'AC_CONFIG_LIBOBJ_DIR' => 1,
++                        'AC_SUBST_TRACE' => 1,
++                        'AC_CONFIG_HEADERS' => 1,
++                        'm4_sinclude' => 1,
++                        'AM_PROG_AR' => 1,
++                        'AM_PROG_MOC' => 1,
++                        'AM_GNU_GETTEXT' => 1,
++                        'AC_FC_SRCEXT' => 1,
++                        'AM_PROG_F77_C_O' => 1,
++                        'LT_INIT' => 1,
++                        'AM_PROG_FC_C_O' => 1,
++                        '_AM_COND_ELSE' => 1,
++                        'AM_CONDITIONAL' => 1,
++                        'AC_CONFIG_LINKS' => 1,
++                        '_AM_SUBST_NOTMAKE' => 1,
++                        'AH_OUTPUT' => 1,
++                        'AM_PROG_CC_C_O' => 1,
++                        'AM_POT_TOOLS' => 1
++                      }
++                    ], 'Autom4te::Request' )
++           );
++
+diff --git a/autom4te.cache/traces.0 b/autom4te.cache/traces.0
+new file mode 100644
+index 0000000..363ac05
+--- /dev/null
++++ b/autom4te.cache/traces.0
+@@ -0,0 +1,20 @@
++m4trace:aclocal.m4:1012: -1- m4_include([../bfd/acinclude.m4])
++m4trace:aclocal.m4:1013: -1- m4_include([../bfd/warning.m4])
++m4trace:aclocal.m4:1014: -1- m4_include([../config/acx.m4])
++m4trace:aclocal.m4:1015: -1- m4_include([../config/depstand.m4])
++m4trace:aclocal.m4:1016: -1- m4_include([../config/gettext-sister.m4])
++m4trace:aclocal.m4:1017: -1- m4_include([../config/largefile.m4])
++m4trace:aclocal.m4:1018: -1- m4_include([../config/lcmessage.m4])
++m4trace:aclocal.m4:1019: -1- m4_include([../config/lead-dot.m4])
++m4trace:aclocal.m4:1020: -1- m4_include([../config/nls.m4])
++m4trace:aclocal.m4:1021: -1- m4_include([../config/override.m4])
++m4trace:aclocal.m4:1022: -1- m4_include([../config/plugins.m4])
++m4trace:aclocal.m4:1023: -1- m4_include([../config/po.m4])
++m4trace:aclocal.m4:1024: -1- m4_include([../config/progtest.m4])
++m4trace:aclocal.m4:1025: -1- m4_include([../config/zlib.m4])
++m4trace:aclocal.m4:1026: -1- m4_include([../libtool.m4])
++m4trace:aclocal.m4:1027: -1- m4_include([../ltoptions.m4])
++m4trace:aclocal.m4:1028: -1- m4_include([../ltsugar.m4])
++m4trace:aclocal.m4:1029: -1- m4_include([../ltversion.m4])
++m4trace:aclocal.m4:1030: -1- m4_include([../lt~obsolete.m4])
++m4trace:aclocal.m4:1031: -1- m4_include([acinclude.m4])
+diff --git a/autom4te.cache/traces.1t b/autom4te.cache/traces.1t
+new file mode 100644
+index 0000000..b9416dc
+--- /dev/null
++++ b/autom4te.cache/traces.1t
+@@ -0,0 +1,172 @@
++m4trace:aclocal.m4:1012: -1- m4_include([../bfd/acinclude.m4])
++m4trace:aclocal.m4:1013: -1- m4_include([../bfd/warning.m4])
++m4trace:aclocal.m4:1014: -1- m4_include([../config/acx.m4])
++m4trace:aclocal.m4:1015: -1- m4_include([../config/depstand.m4])
++m4trace:aclocal.m4:1016: -1- m4_include([../config/gettext-sister.m4])
++m4trace:aclocal.m4:1017: -1- m4_include([../config/largefile.m4])
++m4trace:aclocal.m4:1018: -1- m4_include([../config/lcmessage.m4])
++m4trace:aclocal.m4:1019: -1- m4_include([../config/lead-dot.m4])
++m4trace:aclocal.m4:1020: -1- m4_include([../config/nls.m4])
++m4trace:aclocal.m4:1021: -1- m4_include([../config/override.m4])
++m4trace:aclocal.m4:1022: -1- m4_include([../config/plugins.m4])
++m4trace:aclocal.m4:1023: -1- m4_include([../config/po.m4])
++m4trace:aclocal.m4:1024: -1- m4_include([../config/progtest.m4])
++m4trace:aclocal.m4:1025: -1- m4_include([../config/zlib.m4])
++m4trace:aclocal.m4:1026: -1- m4_include([../libtool.m4])
++m4trace:aclocal.m4:1027: -1- m4_include([../ltoptions.m4])
++m4trace:aclocal.m4:1028: -1- m4_include([../ltsugar.m4])
++m4trace:aclocal.m4:1029: -1- m4_include([../ltversion.m4])
++m4trace:aclocal.m4:1030: -1- m4_include([../lt~obsolete.m4])
++m4trace:aclocal.m4:1031: -1- m4_include([acinclude.m4])
++m4trace:configure.ac:24: -1- m4_include([../bfd/version.m4])
++m4trace:configure.ac:25: -1- AC_INIT([gas], [2.30])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?A[CHUM]_])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([_AC_])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^LIBOBJS$], [do not use LIBOBJS directly, use AC_LIBOBJ (see section `AC_LIBOBJ vs LIBOBJS'])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^AS_FLAGS$])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?m4_])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^dnl$])
++m4trace:configure.ac:25: -1- m4_pattern_forbid([^_?AS_])
++m4trace:configure.ac:25: -1- AC_SUBST([SHELL])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([SHELL])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^SHELL$])
++m4trace:configure.ac:25: -1- AC_SUBST([PATH_SEPARATOR])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PATH_SEPARATOR])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PATH_SEPARATOR$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_NAME], [m4_ifdef([AC_PACKAGE_NAME],      ['AC_PACKAGE_NAME'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_NAME])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_NAME$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_TARNAME], [m4_ifdef([AC_PACKAGE_TARNAME],   ['AC_PACKAGE_TARNAME'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_TARNAME])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_TARNAME$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_VERSION], [m4_ifdef([AC_PACKAGE_VERSION],   ['AC_PACKAGE_VERSION'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_VERSION])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_VERSION$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_STRING], [m4_ifdef([AC_PACKAGE_STRING],    ['AC_PACKAGE_STRING'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_STRING])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_STRING$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_BUGREPORT], [m4_ifdef([AC_PACKAGE_BUGREPORT], ['AC_PACKAGE_BUGREPORT'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_BUGREPORT])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])
++m4trace:configure.ac:25: -1- AC_SUBST([PACKAGE_URL], [m4_ifdef([AC_PACKAGE_URL],       ['AC_PACKAGE_URL'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([PACKAGE_URL])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_URL$])
++m4trace:configure.ac:25: -1- AC_SUBST([exec_prefix], [NONE])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([exec_prefix])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^exec_prefix$])
++m4trace:configure.ac:25: -1- AC_SUBST([prefix], [NONE])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([prefix])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^prefix$])
++m4trace:configure.ac:25: -1- AC_SUBST([program_transform_name], [s,x,x,])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([program_transform_name])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^program_transform_name$])
++m4trace:configure.ac:25: -1- AC_SUBST([bindir], ['${exec_prefix}/bin'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([bindir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^bindir$])
++m4trace:configure.ac:25: -1- AC_SUBST([sbindir], ['${exec_prefix}/sbin'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sbindir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^sbindir$])
++m4trace:configure.ac:25: -1- AC_SUBST([libexecdir], ['${exec_prefix}/libexec'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([libexecdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^libexecdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([datarootdir], ['${prefix}/share'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([datarootdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^datarootdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([datadir], ['${datarootdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([datadir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^datadir$])
++m4trace:configure.ac:25: -1- AC_SUBST([sysconfdir], ['${prefix}/etc'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sysconfdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^sysconfdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([sharedstatedir], ['${prefix}/com'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([sharedstatedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^sharedstatedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([localstatedir], ['${prefix}/var'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([localstatedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^localstatedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([runstatedir], ['${localstatedir}/run'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([runstatedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^runstatedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([includedir], ['${prefix}/include'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([includedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^includedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([oldincludedir], ['/usr/include'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([oldincludedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^oldincludedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([docdir], [m4_ifset([AC_PACKAGE_TARNAME],
++				     ['${datarootdir}/doc/${PACKAGE_TARNAME}'],
++				     ['${datarootdir}/doc/${PACKAGE}'])])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([docdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^docdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([infodir], ['${datarootdir}/info'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([infodir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^infodir$])
++m4trace:configure.ac:25: -1- AC_SUBST([htmldir], ['${docdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([htmldir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^htmldir$])
++m4trace:configure.ac:25: -1- AC_SUBST([dvidir], ['${docdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([dvidir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^dvidir$])
++m4trace:configure.ac:25: -1- AC_SUBST([pdfdir], ['${docdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([pdfdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^pdfdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([psdir], ['${docdir}'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([psdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^psdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([libdir], ['${exec_prefix}/lib'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([libdir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^libdir$])
++m4trace:configure.ac:25: -1- AC_SUBST([localedir], ['${datarootdir}/locale'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([localedir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^localedir$])
++m4trace:configure.ac:25: -1- AC_SUBST([mandir], ['${datarootdir}/man'])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([mandir])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^mandir$])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_NAME])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_NAME$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_NAME], [/* Define to the full name of this package. */
++@%:@undef PACKAGE_NAME])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_TARNAME])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_TARNAME$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_TARNAME], [/* Define to the one symbol short name of this package. */
++@%:@undef PACKAGE_TARNAME])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_VERSION])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_VERSION$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_VERSION], [/* Define to the version of this package. */
++@%:@undef PACKAGE_VERSION])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_STRING])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_STRING$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_STRING], [/* Define to the full name and version of this package. */
++@%:@undef PACKAGE_STRING])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_BUGREPORT])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_BUGREPORT], [/* Define to the address where bug reports for this package should be sent. */
++@%:@undef PACKAGE_BUGREPORT])
++m4trace:configure.ac:25: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_URL])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^PACKAGE_URL$])
++m4trace:configure.ac:25: -1- AH_OUTPUT([PACKAGE_URL], [/* Define to the home page for this package. */
++@%:@undef PACKAGE_URL])
++m4trace:configure.ac:25: -1- AC_SUBST([DEFS])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([DEFS])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^DEFS$])
++m4trace:configure.ac:25: -1- AC_SUBST([ECHO_C])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_C])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_C$])
++m4trace:configure.ac:25: -1- AC_SUBST([ECHO_N])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_N])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_N$])
++m4trace:configure.ac:25: -1- AC_SUBST([ECHO_T])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([ECHO_T])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^ECHO_T$])
++m4trace:configure.ac:25: -1- AC_SUBST([LIBS])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([LIBS])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^LIBS$])
++m4trace:configure.ac:25: -1- AC_SUBST([build_alias])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([build_alias])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^build_alias$])
++m4trace:configure.ac:25: -1- AC_SUBST([host_alias])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([host_alias])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^host_alias$])
++m4trace:configure.ac:25: -1- AC_SUBST([target_alias])
++m4trace:configure.ac:25: -1- AC_SUBST_TRACE([target_alias])
++m4trace:configure.ac:25: -1- m4_pattern_allow([^target_alias$])
+diff --git a/bbInfoHandle.c b/bbInfoHandle.c
+new file mode 100644
+index 0000000..7c9b5f0
+--- /dev/null
++++ b/bbInfoHandle.c
+@@ -0,0 +1,721 @@
++/*
++ * bbInfoHandle.c
++ */
++
++#include "bbInfoHandle.h"
++#include "struc-symbol.h"
++#include <time.h>
++#include <stdlib.h>
++#include <string.h>
++#include <stdio.h>
++
++static void jmptable_bbInfo_handler (int);
++static void funcb_bbInfo_handler (int);
++static void funce_bbInfo_handler (int);
++static void bb_bbInfo_handler (int);
++static void be_bbInfo_handler (int);
++void bbinfo_update_shuffle_info(void);
++bbinfo_mbb* init_basic_block(void);
++bbinfo_fixup* bbinfo_init_fixup();
++bbinfo_fixup* bbinfo_init_insert_fixup(asection*, int);
++char bbinfo_is_collect_sec(asection*);
++char bbinfo_is_new_sec_frag(asection*);
++
++#ifdef BBINFO_DEBUG_MSG
++char *bbinfo_file_name = NULL;
++#endif
++
++const pseudo_typeS bbInfo_pseudo_table[] = {
++    {"bbinfo_jmptbl", jmptable_bbInfo_handler, 0},
++    {"bbinfo_funb", funcb_bbInfo_handler, 0},
++    {"bbinfo_fune", funce_bbInfo_handler, 0},
++    {"bbinfo_bb", bb_bbInfo_handler, 0},
++    {"bbinfo_be", be_bbInfo_handler, 0}
++};
++
++// debug related symbol
++const char* symbol_blacklist[] = {
++  ".Ldebug",
++  ".LASF"
++};
++
++// global variable
++bbinfo_fixup* fixups_list_head; // fixup list
++bbinfo_mbb* mbbs_list_head;   // first element of basic blocks list
++bbinfo_mbb* mbbs_list_tail; // last element of basic blocks list
++uint32_t cur_function_id;  // current functin id
++uint32_t cur_function_end_id; // current function end id
++uint32_t prev_function_id; // prev function id
++symbolS *last_symbol; // last user defined symbol
++uint32_t cur_block_id; // global current basic block id 
++unsigned char function_head; // represent that the current basic block is current function's first entry
++
++// to record if fixups is in a new section(such as .text.xxx)
++//unsigned text_sec_cnt;
++//unsigned rodata_sec_cnt;
++//unsigned data_sec_cnt;
++//unsigned datarel_sec_cnt;
++//unsigned init_sec_cnt;
++
++unsigned text_sec_frag_cnt;
++unsigned rodata_sec_frag_cnt;
++unsigned data_sec_frag_cnt;
++unsigned datarel_sec_frag_cnt;
++unsigned init_sec_frag_cnt;
++
++asection* bbinfo_text_sec;
++asection* bbinfo_rodata_sec;
++asection* bbinfo_data_sec;
++asection* bbinfo_init_sec;
++asection* bbinfo_datarel_sec;
++
++// store the shuffle information
++char* bbinfo_shuffle_info_buf = NULL;
++unsigned bbinfo_shuffle_info_buf_len = 0;
++
++
++// init the global variables
++void bbinfo_init(){
++  fixups_list_head = NULL;
++  mbbs_list_head = NULL;
++  mbbs_list_tail = NULL;
++  cur_function_id = 0;
++  cur_function_end_id = 0;
++  prev_function_id = 0;
++  last_symbol = NULL;
++  cur_block_id = 0;
++  function_head = 0;
++
++  text_sec_frag_cnt = 0;
++  rodata_sec_frag_cnt = 0;
++  data_sec_frag_cnt = 0;
++  datarel_sec_frag_cnt = 0;
++  init_sec_frag_cnt = 0;
++
++  bbinfo_text_sec = NULL;
++  bbinfo_rodata_sec = NULL;
++  bbinfo_data_sec = NULL;
++  bbinfo_init_sec = NULL;
++  bbinfo_datarel_sec = NULL;
++}
++
++// update the last_symbol global variable
++// exclude dedug defined label
++int update_last_symbol(symbolS *sym){
++  unsigned int size = sizeof(symbol_blacklist) / sizeof(char*);
++  const char* symbol_name = S_GET_NAME(sym);
++
++  if (!strcmp(symbol_name, "")){
++    as_warn (_("[bbInfo]: the symbol name is null"));
++    return -1;
++  }
++// check if the symbol_name is in black list
++  for (unsigned int i = 0; i < size; i++){
++    if(strstr(symbol_name, symbol_blacklist[i]))
++      return -1;
++  } 
++  last_symbol = sym;
++  return 0;
++}
++
++#ifdef BBINFO_DEBUG_MSG
++void save_to_tmp_directory(const char* file){
++  if (!file)
++    return;
++  char* tmp_file = "/tmp/bbinfo/";
++  char buf[100];
++  strcpy(buf, tmp_file);
++  srand(time(0));
++  unsigned rand_num = rand();
++  sprintf(buf, "cp %s /tmp/bbinfo/case_%x.s", file, rand_num);
++
++  as_warn(_("Execute %s"), buf);
++  system(buf);
++}
++#endif
++
++// generate shuffleInfo into protobuf
++void bbinfo_update_shuffle_info(void){
++ShuffleInfo__ReorderInfo reorder_info = SHUFFLE_INFO__REORDER_INFO__INIT;
++ShuffleInfo__ReorderInfo__BinaryInfo binary_info = 
++  SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;
++
++binary_info.has_rand_obj_offset = 1;
++binary_info.rand_obj_offset = 0; // should be update at linking time
++binary_info.has_main_addr_offset = 1;
++binary_info.main_addr_offset = 0; // should be update at linking time
++
++// 0 is ordinary c/c++ file. 
++// 1 is a source file contains inline assembly
++// 2 is standalone assembly file
++// TODO(binpang). Identify assemble file and inline 
++binary_info.has_src_type = 1;
++binary_info.src_type = 0;
++
++reorder_info.bin = &binary_info;
++
++unsigned bb_cnt = 0;
++unsigned text_fixp_cnt = 0;
++unsigned rodata_fixp_cnt = 0;
++unsigned data_fixp_cnt = 0;
++unsigned datarel_fixp_cnt = 0;
++unsigned init_fixp_cnt = 0;
++
++bbinfo_mbb* last_mbb = NULL;
++// count the basic block number
++for(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;
++    cur_mbb = cur_mbb->next){
++  if (!cur_mbb->sec){
++    continue;
++  }
++  //debug
++  if (last_mbb)
++    if (last_mbb->size + last_mbb->offset != cur_mbb->offset && last_mbb->sec == cur_mbb->sec){
++    as_warn(_("bb#%d, from %x to %x. last_mbb %d, its section is %s, last_mbb from %x to %x, last basic block added size %d\n"), 
++	bb_cnt, cur_mbb->offset, cur_mbb->offset + cur_mbb->size-1, (last_mbb->parent_frag->last_bb == last_mbb), cur_mbb->sec->name, last_mbb->offset, last_mbb->size+last_mbb->offset-1, last_mbb->parent_frag->last_bb_added_size);
++    
++#ifdef BBINFO_DEBUG_MSG
++    if (bbinfo_file_name){
++      save_to_tmp_directory (bbinfo_file_name);
++      bbinfo_file_name = NULL;
++    }
++#endif
++    }
++
++  bb_cnt++;
++  last_mbb = cur_mbb;
++}
++
++
++// count the fixp number
++for(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;
++    cur_fixp = cur_fixp->next){
++
++  // Bug here. The fixup does not have its parent section
++  if (!cur_fixp->sec){
++    as_warn(_("Bug here. The fixup does not have its parent section\n"));
++
++#ifdef BBINFO_DEBUG_MSG
++    if (bbinfo_file_name){
++      save_to_tmp_directory(bbinfo_file_name);
++      bbinfo_file_name = NULL;
++    }
++#endif
++    continue;
++  }
++
++  if (bbinfo_is_new_sec_frag(cur_fixp->sec) == 1)
++    cur_fixp->is_new_section = 1;
++
++  const char* sec_name =cur_fixp->sec->name;
++  if (strstr(sec_name, ".text"))
++    text_fixp_cnt++;
++  else if(strstr(sec_name, ".rodata"))
++    rodata_fixp_cnt++;
++  else if(strstr(sec_name, ".init_array"))
++    init_fixp_cnt++;
++  else if(strstr(sec_name, ".data.rel.ro"))
++    datarel_fixp_cnt++;
++  else if(strstr(sec_name, ".data"))
++    data_fixp_cnt++;
++}
++
++ShuffleInfo__ReorderInfo__LayoutInfo **layout;
++layout = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo *) * bb_cnt);
++unsigned index = 0;
++unsigned obj_size = 0;
++asection* last_sec = NULL;
++
++#ifdef BBINFO_DEBUG_MSG
++unsigned bb_fix_num = 0;
++#endif
++
++for(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;
++    cur_mbb = cur_mbb->next){
++
++  // Bug here. The basic block does not have its parent section
++  if (!cur_mbb->sec){
++    as_warn(_("The basic block[%d] does not have its parent section, its size is %d"), cur_mbb->ID, cur_mbb->size);
++
++// debug, save the failed asm file into /tmp/bbinfo/ directory
++#ifdef BBINFO_DEBUG_MSG
++    if (bbinfo_file_name && cur_mbb->size){
++      save_to_tmp_directory(bbinfo_file_name);
++      bbinfo_file_name = NULL;
++    }
++#endif
++    continue;
++  }
++
++#ifdef BBINFO_DEBUG_MSG
++  bb_fix_num += cur_mbb->num_fixs;
++#endif
++
++  layout[index] = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo));
++
++  shuffle_info__reorder_info__layout_info__init(layout[index]);
++  layout[index]->has_type = 1;
++  layout[index]->type = cur_mbb->type;
++  layout[index]->has_bb_size = 1;
++  layout[index]->bb_size = cur_mbb->size;
++  layout[index]->has_bb_fallthrough = 1;
++  layout[index]->bb_fallthrough = cur_mbb->fall_through;
++  layout[index]->has_num_fixups = 1;
++  layout[index]->num_fixups = cur_mbb->num_fixs;
++  layout[index]->section_name = (char*)cur_mbb->sec->name;
++  layout[index]->has_padding_size= 1;
++  layout[index]->padding_size = cur_mbb->alignment;
++  unsigned char is_last_bb = 0;
++  if (index == bb_cnt - 1){
++    if (layout[index]->type == 1)
++      layout[index]->type = 3; // 3 represents that it is both function and object end
++    else
++      layout[index]->type = 2;
++  }
++  // the last basic block is tail of last section.
++  else if (last_sec && last_sec != cur_mbb->sec){
++    if (layout[index-1]->type == 1)
++      layout[index-1]->type = 3;
++    else
++      layout[index-1]->type = 2;
++  }
++  layout[index]->has_offset = 1;
++  layout[index]->offset = cur_mbb->offset;
++
++#ifdef BBINFO_DEBUG_MSG
++  printf("[bbinfo]: bb%d - offset 0x%x, size 0x%x, alignment is %d, type %d, sec %s\n", 
++		  index, cur_mbb->offset, cur_mbb->size, cur_mbb->alignment, cur_mbb->type, cur_mbb->sec->name);
++#endif
++
++  index++;
++  
++  obj_size += cur_mbb->size;
++  last_sec = cur_mbb->sec;
++}
++
++#ifdef BBINFO_DEBUG_MSG
++if (bb_fix_num != text_fixp_cnt){
++  as_warn(_("basic block's fixup number[%d] does not equal to total fixups number[%d]"), bb_fix_num, text_fixp_cnt);
++if (bbinfo_file_name){
++    save_to_tmp_directory(bbinfo_file_name);
++    bbinfo_file_name = NULL;
++  }
++}
++#endif
++
++binary_info.has_obj_sz = 1;
++binary_info.obj_sz = obj_size;
++
++// update layout_info
++reorder_info.n_layout = index;
++reorder_info.layout = layout;
++
++ShuffleInfo__ReorderInfo__FixupInfo **fixup;
++fixup = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo *) * 1);
++fixup[0] = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo));
++shuffle_info__reorder_info__fixup_info__init(fixup[0]);
++
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text_fixp = NULL;
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata_fixp = NULL;
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data_fixp = NULL;
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel_fixp = NULL;
++ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **init_fixp = NULL;
++
++if (text_fixp_cnt)
++  text_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) * 
++    								text_fixp_cnt);
++if (rodata_fixp_cnt)
++  rodata_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
++    								rodata_fixp_cnt);
++if (data_fixp_cnt)
++  data_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
++      								data_fixp_cnt);
++if (init_fixp_cnt)
++  init_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
++      								init_fixp_cnt);
++if (datarel_fixp_cnt)
++  datarel_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *
++      								datarel_fixp_cnt);
++unsigned cur_text_index = 0;
++unsigned cur_rodata_index = 0;
++unsigned cur_data_index = 0;
++unsigned cur_datarel_index = 0;
++unsigned cur_init_index = 0;
++
++for (bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;
++    					cur_fixp = cur_fixp->next){
++  if (!cur_fixp->sec)
++    continue;
++
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *cur_fixp_tuple =
++    		malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple));
++  shuffle_info__reorder_info__fixup_info__fixup_tuple__init(cur_fixp_tuple); 
++  cur_fixp_tuple->offset = cur_fixp->offset;
++  cur_fixp_tuple->deref_sz = cur_fixp->size;
++  cur_fixp_tuple->is_rela = cur_fixp->is_rela;
++  cur_fixp_tuple->section_name = (char*) cur_fixp->sec->name;
++  // jump table information
++  if (cur_fixp->table_size){
++    cur_fixp_tuple->has_num_jt_entries = 1;
++    cur_fixp_tuple->num_jt_entries = cur_fixp->table_size;
++    cur_fixp_tuple->has_jt_entry_sz = 1;
++    cur_fixp_tuple->jt_entry_sz = cur_fixp->entry_size;
++  }
++
++  cur_fixp_tuple->has_type = 1;
++  if (cur_fixp->is_new_section){
++    cur_fixp_tuple->type = 4; // let linker know if there are multiple .text sections
++  }else{
++    cur_fixp_tuple->type = 0; // c2c, c2d, d2c, d2d default=0; should be updated by linker
++  }
++
++  int discard_cnt = 0;
++  const char* sec_name =cur_fixp->sec->name;
++  if (strstr(sec_name, ".text"))
++    text_fixp[cur_text_index++] = cur_fixp_tuple;  
++  else if(strstr(sec_name, ".rodata"))
++    rodata_fixp[cur_rodata_index++] = cur_fixp_tuple;
++  else if(strstr(sec_name, ".init_array"))
++    init_fixp[cur_init_index++] = cur_fixp_tuple;
++  else if(strstr(sec_name, ".data.rel.ro"))
++    datarel_fixp[cur_datarel_index++] = cur_fixp_tuple;
++  else if(strstr(sec_name, ".data"))
++    data_fixp[cur_data_index++] = cur_fixp_tuple;
++}
++
++// store the fixup information into protobuf
++fixup[0]->n_text = text_fixp_cnt;
++fixup[0]->text = text_fixp;
++fixup[0]->n_rodata = rodata_fixp_cnt;
++fixup[0]->rodata = rodata_fixp;
++fixup[0]->n_data = data_fixp_cnt;
++fixup[0]->data = data_fixp;
++fixup[0]->n_datarel = datarel_fixp_cnt;
++fixup[0]->datarel = datarel_fixp;
++fixup[0]->n_initarray = init_fixp_cnt;
++fixup[0]->initarray = init_fixp;
++
++reorder_info.n_fixup = 1;
++reorder_info.fixup = fixup;
++
++bbinfo_shuffle_info_buf_len = protobuf_c_message_get_packed_size(&reorder_info); // get protobuf bytes length
++
++bbinfo_shuffle_info_buf = malloc(bbinfo_shuffle_info_buf_len);
++protobuf_c_message_pack(&reorder_info, bbinfo_shuffle_info_buf); // Pack reorder_info into buf
++
++// free the malloced space
++
++// free layouts
++for(index = 0; index < bb_cnt; index++){
++  free(layout[index]);
++}
++free(layout);
++
++// free fixups
++for (index = 0; index < text_fixp_cnt; index++){
++  free (text_fixp[index]);
++}
++for (index = 0; index < data_fixp_cnt; index++){
++  free (data_fixp[index]);
++}
++for (index = 0; index < rodata_fixp_cnt; index++){
++  free (rodata_fixp[index]);
++}
++for (index = 0; index < init_fixp_cnt; index++){
++  free (init_fixp[index]);
++}
++for (index = 0; index < datarel_fixp_cnt; index++){
++  free (datarel_fixp[index]);
++}
++if (text_fixp_cnt)
++ free (text_fixp); 
++if (rodata_fixp_cnt)
++ free (rodata_fixp);
++if (data_fixp_cnt)
++ free (data_fixp);
++if (init_fixp_cnt)
++ free (init_fixp);
++if (datarel_fixp_cnt)
++ free (datarel_fixp); 
++}
++#ifdef BBINFO_DEBUG_MSG
++// debug function
++int count_fixup_list_num(){
++  bbinfo_fixup* fixp;
++  int cnt = 0;
++  for (fixp = fixups_list_head; fixp; fixp = fixp->next, cnt++);
++  return cnt;
++}
++#endif
++
++// init the fixup struct and insert it into fixups_list serially
++bbinfo_fixup* bbinfo_init_insert_fixup(asection* sec, int offset){
++
++  bbinfo_fixup* result_fixup = malloc(sizeof(bbinfo_fixup));
++  // init
++  memset (result_fixup, 0, sizeof(bbinfo_fixup));
++  
++
++  if (fixups_list_head == NULL){
++    fixups_list_head = result_fixup;
++    return result_fixup;
++  }
++ 
++  bbinfo_fixup* prev = NULL;
++  bbinfo_fixup* cur = fixups_list_head;
++  // find the section that is equal to sec
++  while(cur && cur->sec != sec){
++    prev = cur;
++    cur = cur->next;
++  }
++
++  // The list does not have section sec
++  if (!cur){
++    prev->next = result_fixup;
++    return result_fixup;
++  }
++
++  // find the proper place accourding to its offset
++  while(cur && offset > cur->offset && cur->sec == sec){
++    prev = cur;
++    cur = cur->next;
++  }
++
++  // insert into the head
++  if (!prev){
++    result_fixup->next = fixups_list_head;
++    fixups_list_head = result_fixup;
++    return result_fixup;
++  }
++  prev->next = result_fixup;
++  result_fixup->next = cur;
++  return result_fixup;
++}
++
++/*
++// init the fixup struct
++bbinfo_fixup* bbinfo_init_fixup(void){
++  bbinfo_fixup *result_fixup = malloc(sizeof(bbinfo_fixup));
++  // init
++  memset(result_fixup, 0, sizeof(bbinfo_fixup)); 
++
++  // put it into the global fixups list
++  if (fixups_list_head == NULL){
++    fixups_list_head = result_fixup;
++  }else{
++    fixups_list_tail->next = result_fixup;
++  }
++  fixups_list_tail = result_fixup;
++  return result_fixup;
++}*/
++
++// check if this is the new section
++// TODO(binpang). Add it into a part of function bbinfo_is_new_sec
++char bbinfo_is_new_sec_frag(asection *sec){
++  // TODO. add new sections, such as .ctors, .fini_array, .dtors, .eh_frame ....
++  if (!sec){
++    as_warn(_("[bbinfo]: in function bbinfo_is_new_sec. The section is NULL"));
++    return -1;
++  }
++  const char* sec_name = sec->name;
++  char* tmp_pointer = NULL;
++  char returned_value = -1;
++  if ((tmp_pointer = strstr(sec_name, ".text")) &&
++      tmp_pointer == sec_name){
++
++    if (!text_sec_frag_cnt){
++      text_sec_frag_cnt++;
++      bbinfo_text_sec = sec;
++      returned_value = 0;
++    }
++    else{
++      returned_value = (bbinfo_text_sec == sec) ? 0 : 1;
++      if(returned_value) text_sec_frag_cnt++;
++      bbinfo_text_sec = sec;
++    }
++    return returned_value;
++  }
++
++  if ((tmp_pointer = strstr(sec_name, ".rodata")) && 
++	tmp_pointer == sec_name){
++
++    if (!rodata_sec_frag_cnt){
++      rodata_sec_frag_cnt++;
++      bbinfo_rodata_sec = sec;
++      returned_value = 0;
++    }else{
++      returned_value = (bbinfo_rodata_sec == sec) ? 0 : 1;
++      if (returned_value) rodata_sec_frag_cnt++;
++      bbinfo_rodata_sec = sec;
++    }
++    return returned_value;
++   }
++
++  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&
++      tmp_pointer == sec_name){
++    
++    if (!init_sec_frag_cnt){
++      init_sec_frag_cnt++;
++      bbinfo_init_sec = sec;
++      returned_value = 0;
++    } else {
++      returned_value = (bbinfo_init_sec == sec) ? 0 : 1;
++      if (returned_value) init_sec_frag_cnt++;
++      bbinfo_init_sec = sec;
++    }
++    return returned_value;
++  }
++
++  if ((tmp_pointer = strstr(sec_name, ".data")) &&
++      tmp_pointer == sec_name){
++
++    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&
++	tmp_pointer == sec_name){
++
++      if (!datarel_sec_frag_cnt){
++	datarel_sec_frag_cnt++;
++	bbinfo_datarel_sec = sec;
++	returned_value = 0;
++      } else {
++	returned_value = (bbinfo_datarel_sec == sec) ? 0 : 1;
++	if (returned_value) datarel_sec_frag_cnt++;
++	bbinfo_datarel_sec = sec;
++      }
++      return returned_value;
++    }
++
++    if (!data_sec_frag_cnt){
++      data_sec_frag_cnt++;
++      bbinfo_data_sec = sec;
++      returned_value = 0;
++    } else {
++      returned_value = (bbinfo_data_sec == sec) ? 0 : 1;
++      if (returned_value) data_sec_frag_cnt++;
++      bbinfo_data_sec = sec;
++    }
++
++    return returned_value;
++  }
++  return -1;
++}
++
++// if this section is the collected section
++// .text, .data.xxx, .rodata.xxxx, .init.xxx, .data.rel
++char bbinfo_is_collect_sec(asection *sec){
++  if (!sec){
++    as_warn(_("[bbinfo]: in function bbinfo_is_new_sec. The section is NULL"));
++    return -1;
++  }
++  const char* sec_name = sec->name;
++  char* tmp_pointer = NULL;
++  if ((tmp_pointer = strstr(sec_name, ".text")) &&
++      tmp_pointer == sec_name){
++      return 1;
++  }
++
++  if ((tmp_pointer = strstr(sec_name, ".rodata")) && 
++	tmp_pointer == sec_name){
++	return 1;
++      }
++
++  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&
++      tmp_pointer == sec_name){
++      return 1;
++  }
++
++  if ((tmp_pointer = strstr(sec_name, ".data")) &&
++      tmp_pointer == sec_name){
++
++    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&
++	tmp_pointer == sec_name){
++	return 1;
++    }
++      return 1;
++  }
++  as_warn("discard fixup in section %s", sec_name);
++  return 0;
++}
++
++// init the bbinfo struct
++bbinfo_mbb* init_basic_block(){
++  // malloc space
++  bbinfo_mbb *result_mbb = malloc(sizeof(bbinfo_mbb));
++  memset(result_mbb, 0, sizeof(bbinfo_mbb));
++  result_mbb->next = NULL;
++
++  // put it into the global basic blocks list
++  if (mbbs_list_head == NULL){
++    mbbs_list_head = result_mbb;
++  }else{
++    mbbs_list_tail->next = result_mbb;
++  } 
++  mbbs_list_tail = result_mbb;
++  return result_mbb;
++}
++
++// handle bbinfo_jmptbl directive
++void jmptable_bbInfo_handler(int ignored ATTRIBUTE_UNUSED){
++    offsetT table_size, entry_size;
++    table_size = get_absolute_expression();
++    SKIP_WHITESPACE();
++    entry_size = get_absolute_expression();
++    if (last_symbol == NULL){
++	printf("Sorry, the last symbol is null\n");
++	return;
++    }
++    // update the jump table related information of the symbol
++    S_SET_JMPTBL_SIZE(last_symbol, table_size);
++    S_SET_JMPTBL_ENTRY_SZ(last_symbol, entry_size);
++    // debug
++    printf("last_symbol is %s\n", S_GET_NAME(last_symbol));
++}
++
++// handle bbinfo_funcb directive, it represents function begin
++void funcb_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
++    prev_function_id = cur_function_id;
++    cur_function_id++;
++    function_head = 1;
++}
++
++// handle bbinfo_funce directive, it represents function end
++void funce_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
++   cur_function_end_id++;
++   if (!mbbs_list_tail){
++     as_fatal("[bbinfo]: funce_bbinfo_handler. the mbbs_list_tail is null");
++     exit(-1);
++   }
++   mbbs_list_tail->type = 1;
++   if (cur_function_end_id != cur_function_id)
++     as_warn(_("[bbInfo]: current function end id don not match current function id")); 
++}
++
++// handle bbinfo_bb directive, it represents basic block begin
++void bb_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
++    bbinfo_mbb *cur_mbb = init_basic_block();
++
++    // init the basic_block element
++    cur_mbb->ID = cur_block_id++;
++    cur_mbb->type = 0;
++    cur_mbb->offset = -1;
++    cur_mbb->size = 0;
++    cur_mbb->alignment = 0;
++    cur_mbb->num_fixs = 0;
++    cur_mbb->fall_through = 0;
++    cur_mbb->sec = NULL;
++    cur_mbb->parent_id = cur_function_id;
++    cur_mbb->is_begin = 1;
++
++    //if (function_head){
++    //  cur_mbb->type = 1; // this basic block is the first block of a function
++    //  function_head = 0;
++   // }
++
++}
++
++// handle bbinfo_be directive, it represents basic block end
++void be_bbInfo_handler (int ignored ATTRIBUTE_UNUSED){
++    offsetT fall_through;
++    fall_through = get_absolute_expression();
++    if (fall_through == 1)
++      mbbs_list_tail->fall_through = 1;
++}
+diff --git a/bbInfoHandle.h b/bbInfoHandle.h
+new file mode 100644
+index 0000000..bd655e6
+--- /dev/null
++++ b/bbInfoHandle.h
+@@ -0,0 +1,96 @@
++/* bbInfoHandle.h
++ *
++ * Handle basic block related directives
++ */
++
++#ifndef BBINFOHANDLE_H
++#define BBINFOHANDLE_H
++
++#define BBINFO_DEBUG_MSG
++
++#include "as.h"
++#include "shuffleInfo.pb-c.h"
++#include <stdint.h>
++
++extern const pseudo_typeS bbInfo_pseudo_table[];
++extern int update_last_symbol(symbolS*);
++extern void init_bbinfo_global(void);
++extern void bbinfo_init(void);
++extern char bbinfo_is_collect_sec(asection*);
++extern char bbinfo_is_new_sec_frag(asection*);
++
++#ifdef BBINFO_DEBUG_MSG
++extern char *bbinfo_file_name;
++#endif
++
++
++
++// basic block related information
++struct basic_block{
++  uint32_t ID; // basic block id, every basic block has unique id in an object
++  uint8_t type; // basic block type: basic block or function boundary.
++ 		// 0 represents basic block. 1 represents function start. 2 represents object end
++  uint32_t offset; // offset from the section
++  int size; // basic block size, include alignment size
++  uint32_t alignment; // basic block alignment size
++  uint32_t num_fixs; // number fixups
++  unsigned char fall_through; // whether the basic block is fall through
++  asection *sec; // which section the basic block belongs to
++  struct basic_block *next; // link next basic blosk
++  uint32_t parent_id; // function id
++  uint8_t is_begin; // if current instruction is the first instruction of this basic block
++  fragS *parent_frag; // this basic block belongs to which frag.
++  		      // FIXME. I'm not sure if there exists a basic block cross two fragS.
++};
++
++typedef struct basic_block bbinfo_mbb;
++
++
++// fixup information
++typedef struct fixup{
++  uint32_t offset; // offset from section
++  asection *sec; // which section the basic block belongs to
++  unsigned char is_new_section; // if its parent section is the new section that has the same name
++  unsigned char is_rela; // if this fixup is relative
++  uint32_t size; // the reference's size
++  uint32_t table_size; // for jump table reference only
++  uint32_t entry_size; // for jump table reference only
++  struct fixup *next; // link next fixup
++} bbinfo_fixup;
++
++extern bbinfo_fixup* fixups_list_head; // fixup list
++extern bbinfo_fixup* fixups_list_tail; // last element of fixups list
++extern bbinfo_mbb* mbbs_list_head; // basic blocks list
++extern bbinfo_mbb* mbbs_list_tail; // the last element of basic blocks list
++extern uint32_t cur_function_id; // current function id
++extern uint32_t prev_function_id; // prev function id
++extern uint32_t cur_function_end_id; // current function end id
++extern symbolS *last_symbol; // last user defined symbol
++extern uint32_t cur_block_id; // global current basic block id
++// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number
++extern unsigned text_sec_cnt;
++extern unsigned rodata_sec_cnt;
++extern unsigned data_sec_cnt;
++extern unsigned datarel_sec_cnt;
++extern unsigned init_sec_cnt;
++
++extern unsigned text_sec_frag_cnt;
++extern unsigned rodata_sec_frag_cnt;
++extern unsigned data_sec_frag_cnt;
++extern unsigned datarel_sec_frag_cnt;
++extern unsigned init_sec_frag_cnt;
++
++extern asection *bbinfo_text_sec;
++extern asection *bbinfo_rodata_sec;
++extern asection *bbinfo_data_sec;
++extern asection *bbinfo_init_sec;
++extern asection *bbinfo_datarel_sec;
++
++// shuffleInfo that CCR defines
++extern char* bbinfo_shuffle_info_buf; 
++extern unsigned bbinfo_shuffle_info_buf_len;
++
++extern bbinfo_fixup* bbinfo_init_fixup(void);
++extern bbinfo_fixup* bbinfo_init_insert_fixup(asection*, int);
++extern void bbinfo_update_shuffle_info(void);
++#endif
+diff --git a/config/tc-i386.c b/config/tc-i386.c
+index 5cd83da..21c4458 100644
+--- a/config/tc-i386.c
++++ b/config/tc-i386.c
+@@ -33,6 +33,8 @@
+ #include "elf/x86-64.h"
+ #include "opcodes/i386-init.h"
+ 
++#include "bbInfoHandle.h" //binpang add
++
+ #ifndef REGISTER_WARNINGS
+ #define REGISTER_WARNINGS 1
+ #endif
+@@ -392,6 +394,7 @@ struct _i386_insn
+ 
+     /* Error message.  */
+     enum i386_error error;
++
+   };
+ 
+ typedef struct _i386_insn i386_insn;
+@@ -4618,6 +4621,12 @@ optimize_disp (void)
+ 	    i.types[op].bitfield.disp32 = 0;
+ 	    i.types[op].bitfield.disp32s = 0;
+ 	    i.types[op].bitfield.disp64 = 0;
++	    // binpang, add
++	    // update the basic block's fix number
++#if defined(__i386__) || defined(__x86_64__)
++	    if (mbbs_list_tail)
++	      mbbs_list_tail->num_fixs++;
++#endif
+ 	  }
+  	else
+ 	  /* We only support 64bit displacement on constants.  */
+@@ -6933,6 +6942,7 @@ build_modrm_byte (void)
+ static void
+ output_branch (void)
+ {
++
+   char *p;
+   int size;
+   int code16;
+@@ -7091,6 +7101,12 @@ output_jump (void)
+   fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+ 		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
+ 
++  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++  if (mbbs_list_tail)
++    mbbs_list_tail->num_fixs++;
++#endif
++
+   /* All jumps handled here are signed, but don't use a signed limit
+      check for 32 and 16 bit jumps as we want to allow wrap around at
+      4G and 64k respectively.  */
+@@ -7153,9 +7169,15 @@ output_interseg_jump (void)
+ 	}
+       md_number_to_chars (p, n, size);
+     }
+-  else
++  else{
+     fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+ 		 i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
++    // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++    if (mbbs_list_tail)
++      mbbs_list_tail->num_fixs++;
++#endif
++  }
+   if (i.op[0].imms->X_op != O_constant)
+     as_bad (_("can't handle non absolute segment in `%s'"),
+ 	    i.tm.name);
+@@ -7176,6 +7198,17 @@ output_insn (void)
+   insn_start_frag = frag_now;
+   insn_start_off = frag_now_fix ();
+ 
++
++#if defined(__i386__) || defined(__x86_64)
++  // update the basic block offset in current/last fragment
++  insn_start_frag->last_bb = mbbs_list_tail;
++  if (mbbs_list_tail && mbbs_list_tail->is_begin){
++    mbbs_list_tail->is_begin = 0;
++    mbbs_list_tail->offset = insn_start_off;
++    mbbs_list_tail->parent_frag = insn_start_frag;
++  }
++#endif
++
+   /* Output jumps.  */
+   if (i.tm.opcode_modifier.jump)
+     output_branch ();
+@@ -7205,6 +7238,32 @@ output_insn (void)
+           offsetT val = 0x240483f0ULL;
+           p = frag_more (5);
+           md_number_to_chars (p, val, 5);
++
++// binpang add
++// get the last instruction size
++// the last basic block's size in fragment may change after fragment relocation 
++#if defined(__i386__) || defined(__x86_64__)
++  offsetT insn_size = 0;
++  if (insn_start_frag == frag_now){
++    insn_size = frag_now_fix() - insn_start_off; 
++  }else{
++    // last basic block in fragment may change in the frag relocation
++    // update its size after fragment relocation
++    insn_size = insn_start_frag->fr_fix - insn_start_off;
++    fragS *frag_tmp;
++    for (frag_tmp = insn_start_frag->fr_next; 
++	frag_tmp && frag_tmp != frag_now; frag_tmp = frag_tmp->fr_next){
++      insn_size += frag_tmp->fr_fix;
++      frag_tmp->last_bb = mbbs_list_tail;
++    }
++    insn_size += frag_now_fix();
++    frag_now->last_bb = mbbs_list_tail;
++  }
++
++  // update the basic block size
++  if (mbbs_list_tail)
++    mbbs_list_tail->size += (unsigned int)insn_size;
++#endif
+           return;
+         }
+ 
+@@ -7366,6 +7425,34 @@ check_prefix:
+       pi ("" /*line*/, &i);
+     }
+ #endif /* DEBUG386  */
++
++// binpang add
++// get the last instruction size
++// the last basic block's size in fragment may change after fragment relocation 
++#if defined(__i386__) || defined(__x86_64__)
++  offsetT insn_size = 0;
++  if (insn_start_frag == frag_now){
++    insn_size = frag_now_fix() - insn_start_off; 
++  }else{
++    // last basic block in fragment may change in the frag relocation
++    // update its size after fragment relocation
++    insn_size = insn_start_frag->fr_fix - insn_start_off;
++    fragS *frag_tmp;
++    for (frag_tmp = insn_start_frag->fr_next; 
++	frag_tmp && frag_tmp != frag_now; frag_tmp = frag_tmp->fr_next){
++      insn_size += frag_tmp->fr_fix;
++      frag_tmp->last_bb = mbbs_list_tail;
++    }
++    insn_size += frag_now_fix();
++    frag_now->last_bb = mbbs_list_tail;
++  }
++
++  // update the basic block size
++  if (mbbs_list_tail)
++    mbbs_list_tail->size += (unsigned int)insn_size;
++#endif
++  
++  
+ }
+ 
+ /* Return the size of the displacement operand N.  */
+@@ -7496,6 +7583,14 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)
+ 	      fixP = fix_new_exp (frag_now, p - frag_now->fr_literal,
+ 				  size, i.op[n].disps, pcrel,
+ 				  reloc_type);
++	      // binpang, add
++	      // update the basic block's fix number
++#if defined(__i386__) || defined(__x86_64__)
++	     if (mbbs_list_tail){
++	       mbbs_list_tail->num_fixs++;
++	     } 
++#endif
++
+ 	      /* Check for "call/jmp *mem", "mov mem, %reg",
+ 		 "test %reg, mem" and "binop mem, %reg" where binop
+ 		 is one of adc, add, and, cmp, or, sbb, sub, xor
+@@ -7653,6 +7748,13 @@ output_imm (fragS *insn_start_frag, offsetT insn_start_off)
+ 		}
+ 	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
+ 			   i.op[n].imms, 0, reloc_type);
++	      // binpang, add
++	      // update the basic blocks fix number
++#if defined(__i386__) || defined(__x86_64__)
++	      if (mbbs_list_tail)
++		mbbs_list_tail->num_fixs++;
++#endif
++
+ 	    }
+ 	}
+     }
+@@ -9319,10 +9421,20 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 	  /* Make jmp (0xeb) a (d)word displacement jump.  */
+ 	  opcode[0] = 0xe9;
+ 	  fragP->fr_fix += size;
++
+ 	  fix_new (fragP, old_fr_fix, size,
+ 		   fragP->fr_symbol,
+ 		   fragP->fr_offset, 1,
+ 		   reloc_type);
++
++	  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	  if (fragP->last_bb)
++	    fragP->last_bb->num_fixs++;
++
++	  // update the added fix size
++	  fragP->last_bb_added_fix_size += size;
++#endif
+ 	  break;
+ 
+ 	case COND_JUMP86:
+@@ -9342,6 +9454,15 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 		       fragP->fr_symbol,
+ 		       fragP->fr_offset, 1,
+ 		       reloc_type);
++
++	  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	  if (fragP->last_bb)
++	    fragP->last_bb->num_fixs++;
++
++	  // update the added fix size
++	  fragP->last_bb_added_fix_size += 2 + 2;
++#endif
+ 	      break;
+ 	    }
+ 	  /* Fall through.  */
+@@ -9357,6 +9478,14 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 			      fragP->fr_offset, 1,
+ 			      BFD_RELOC_8_PCREL);
+ 	      fixP->fx_signed = 1;
++	  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	  if (fragP->last_bb)
++	    fragP->last_bb->num_fixs++;
++
++	  // update the added fix size
++	  fragP->last_bb_added_fix_size += 1;
++#endif
+ 	      break;
+ 	    }
+ 
+@@ -9370,6 +9499,14 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 		   fragP->fr_symbol,
+ 		   fragP->fr_offset, 1,
+ 		   reloc_type);
++	  // binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	  if (fragP->last_bb)
++	    fragP->last_bb->num_fixs++;
++
++	  // update the added fix size
++	  fragP->last_bb_added_fix_size += 1 + size;
++#endif
+ 	  break;
+ 
+ 	default:
+@@ -9399,9 +9536,13 @@ md_estimate_size_before_relax (fragS *fragP, segT segment)
+ 	Caller will turn frag into a ".space 0".  */
+ 
+ void
+-md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
++md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec,
+                  fragS *fragP)
+ {
++  // binpang, add
++  // record added opcodes size
++  unsigned add_opcodes = 0;
++
+   unsigned char *opcode;
+   unsigned char *where_to_put_displacement = NULL;
+   offsetT target_address;
+@@ -9450,6 +9591,9 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
+ 	case ENCODE_RELAX_STATE (COND_JUMP, BIG):
+ 	case ENCODE_RELAX_STATE (COND_JUMP86, BIG):
+ 	  extension = 5;		/* 2 opcode + 4 displacement  */
++	  // binpang, add
++	  add_opcodes = 1;
++
+ 	  opcode[1] = opcode[0] + 0x10;
+ 	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
+ 	  where_to_put_displacement = &opcode[2];
+@@ -9457,6 +9601,9 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
+ 
+ 	case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
+ 	  extension = 3;		/* 2 opcode + 2 displacement  */
++	  // binpang, add
++	  add_opcodes = 1;
++
+ 	  opcode[1] = opcode[0] + 0x10;
+ 	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
+ 	  where_to_put_displacement = &opcode[2];
+@@ -9494,6 +9641,24 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,
+   md_number_to_chars ((char *) where_to_put_displacement,
+ 		      (valueT) (displacement_from_opcode_start - extension),
+ 		      DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
++  
++#if defined(__i386__) || defined(__x86_64__)
++  char is_new_sec = bbinfo_is_collect_sec(sec);
++  if (is_new_sec)
++  {
++    // binpang, add fixup doesn't in fixup list
++    int tmp_offset = fragP->fr_address + fragP->fr_fix + add_opcodes;
++    bbinfo_fixup* tmp_fix = bbinfo_init_insert_fixup(sec, tmp_offset);
++    tmp_fix->sec = sec;
++    tmp_fix->offset = tmp_offset;
++    tmp_fix->is_new_section = 0;
++    tmp_fix->is_rela = 1; // this fixup is always pc-relative
++    tmp_fix->size = extension - add_opcodes;
++    if (fragP->last_bb)
++      fragP->last_bb->num_fixs++;
++  }
++#endif
++
+   fragP->fr_fix += extension;
+ }
+ 
+diff --git a/config/tc-ia64.c b/config/tc-ia64.c
+index 7976624..73ef1e4 100644
+--- a/config/tc-ia64.c
++++ b/config/tc-ia64.c
+@@ -11096,6 +11096,8 @@ ia64_cons_fix_new (fragS *f, int where, int nbytes, expressionS *exp,
+ static bfd_reloc_code_real_type
+ ia64_gen_real_reloc_type (struct symbol *sym, bfd_reloc_code_real_type r_type)
+ {
++
++
+   bfd_reloc_code_real_type newr = 0;
+   const char *type = NULL, *suffix = "";
+ 
+diff --git a/frags.c b/frags.c
+index 170fd97..412f166 100644
+--- a/frags.c
++++ b/frags.c
+@@ -198,6 +198,14 @@ frag_new (size_t old_frags_var_max_size
+   gas_assert (frchain_now->frch_last == frag_now);
+ 
+   frag_now->fr_next = NULL;
++
++#if defined(__i386__) || defined(__x86_64__)
++  // binpang, add
++  // init frag bbInfo related element
++  frag_now->last_bb = NULL;
++  frag_now->bb_offset = 0;
++  frag_now->last_bb_added_size = 0;
++#endif
+ }
+ 
+ /* Start a new frag unless we have n more chars of room in the current frag.
+diff --git a/frags.h b/frags.h
+index 28205c6..312667b 100644
+--- a/frags.h
++++ b/frags.h
+@@ -21,7 +21,9 @@
+ #ifndef FRAGS_H
+ #define FRAGS_H
+ 
++
+ struct obstack;
++struct basic_block;
+ 
+ /* A code fragment (frag) is some known number of chars, followed by some
+    unknown number of chars. Typically the unknown number of chars is an
+@@ -103,6 +105,15 @@ struct frag {
+   OBJ_FRAG_TYPE obj_frag_data;
+ #endif
+ 
++// binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++struct basic_block *last_bb; // last basic block in this fragment
++unsigned int bb_offset; // basic block offset in this fragment
++offsetT last_bb_added_size; // last basic block may be added
++offsetT last_bb_added_fix_size; // fr_fix added number
++asection *parent; // which section it belongs to
++#endif
++
+   /* Data begins here.  */
+   char fr_literal[1];
+ };
+diff --git a/libshuffleInfo.so b/libshuffleInfo.so
+new file mode 100755
+index 0000000..466ec8e
+Binary files /dev/null and b/libshuffleInfo.so differ
+diff --git a/makefile.vms b/makefile.vms
+index e7d88ed..421ce3f 100644
+--- a/makefile.vms
++++ b/makefile.vms
+@@ -43,7 +43,7 @@ OBJS:=targ-cpu.obj,obj-format.obj,atof-targ.obj,app.obj,as.obj,\
+   frags.obj,hash.obj,input-file.obj,\
+   input-scrub.obj,literal.obj,messages.obj,output-file.obj,read.obj,\
+   subsegs.obj,symbols.obj,write.obj,listing.obj,ecoff.obj,stabs.obj,sb.obj,\
+-  macro.obj,ehopt.obj,dw2gencfi.obj,dwarf2dbg.obj,remap.obj
++  macro.obj,ehopt.obj,dw2gencfi.obj,dwarf2dbg.obj,remap.obj,bbInfoHandle.obj
+ 
+ ifeq ($(ARCH),IA64)
+ OBJS:=$(OBJS),te-vms.obj
+diff --git a/read.c b/read.c
+index cf1bdec..66b84f3 100644
+--- a/read.c
++++ b/read.c
+@@ -40,6 +40,10 @@
+ #include "dw2gencfi.h"
+ #include "wchar.h"
+ 
++#if defined(__i386__) || defined(__x86_64__)
++#include "bbInfoHandle.h" // binpang, add
++#endif
++
+ #ifndef TC_START_LABEL
+ #define TC_START_LABEL(STR, NUL_CHAR, NEXT_CHAR) (NEXT_CHAR == ':')
+ #endif
+@@ -534,6 +538,11 @@ pop_insert (const pseudo_typeS *table)
+ #define cfi_pop_insert()	pop_insert(cfi_pseudo_table)
+ #endif
+ 
++// binpang, add. Handle basic block related information
++#if !defined(bbInfo_pop_insert) && (defined(__i386__) || defined (__x86_64__))
++#define bbInfo_pop_insert()    pop_insert(bbInfo_pseudo_table)
++#endif
++
+ static void
+ pobegin (void)
+ {
+@@ -556,8 +565,16 @@ pobegin (void)
+   pop_table_name = "cfi";
+   pop_override_ok = 1;
+   cfi_pop_insert ();
++
++// binpang, add.
++#if defined(__i386__) || defined(__x86_64__)
++  /* Now bbInfo ones. */
++  pop_table_name = "bbInfo";
++  bbInfo_pop_insert();
++#endif
++
+ }
+-
++
+ #define HANDLE_CONDITIONAL_ASSEMBLY(num_read)				\
+   if (ignore_input ())							\
+     {									\
+@@ -818,6 +835,13 @@ read_a_source_file (const char *name)
+   int temp;
+   pseudo_typeS *pop;
+ 
++// binpang, add. debug
++#ifdef BBINFO_DEBUG_MSG
++  bbinfo_file_name = name;
++// emmm, printf the information will get the gold linker LTO crashes...
++  as_warn(_("file name is %s\n"), bbinfo_file_name);
++#endif
++
+ #ifdef WARN_COMMENTS
+   found_comment = 0;
+ #endif
+@@ -845,8 +869,6 @@ read_a_source_file (const char *name)
+       while (input_line_pointer < buffer_limit)
+ 	{
+ 	  
+-          //binpang: debug
+-	  printf("New line %s", input_line_pointer);
+ 	  bfd_boolean was_new_line;
+ 	  /* We have more of this buffer to parse.  */
+ 
+@@ -1018,6 +1040,10 @@ read_a_source_file (const char *name)
+ 		    }
+ 
+ 		  line_label = colon (s);	/* User-defined label.  */
++		  //binpang add, record the last user defined label
++#if defined(__i386__) || defined(__x86_64__)
++		  update_last_symbol(line_label);
++#endif
+ 		  restore_line_pointer (nul_char);
+ 		  ++ input_line_pointer;
+ #ifdef tc_check_label
+@@ -1391,6 +1417,7 @@ read_a_source_file (const char *name)
+ 		     "first comment found here");
+   }
+ #endif
++
+ }
+ 
+ /* Convert O_constant expression EXP into the equivalent O_big representation.
+diff --git "a/set\033:q" "b/set\033:q"
+new file mode 100644
+index 0000000..0941808
+--- /dev/null
++++ "b/set\033:q"
+@@ -0,0 +1,484 @@
++[1mdiff --git a/Makefile.am b/Makefile.am[m
++[1mindex e183855..e882179 100644[m
++[1m--- a/Makefile.am[m
++[1m+++ b/Makefile.am[m
++[36m@@ -71,6 +71,7 @@[m [mGAS_CFILES = \[m
++ 	dwarf2dbg.c \[m
++ 	dw2gencfi.c \[m
++ 	bbInfoHandle.c \[m
++[32m+[m	[32mshuffleInfo.pb-c.c \[m
++ 	ecoff.c \[m
++ 	ehopt.c \[m
++ 	expr.c \[m
++[36m@@ -106,6 +107,7 @@[m [mHFILES = \[m
++ 	dwarf2dbg.h \[m
++ 	dw2gencfi.h \[m
++ 	bbInfoHandle.h \[m
++[32m+[m	[32mshuffleInfo.pb-c.h \[m
++ 	ecoff.h \[m
++ 	emul-target.h \[m
++ 	emul.h \[m
++[1mdiff --git a/Makefile.in b/Makefile.in[m
++[1mindex 161d5ca..57629ff 100644[m
++[1m--- a/Makefile.in[m
++[1m+++ b/Makefile.in[m
++[36m@@ -117,7 +117,9 @@[m [mam__objects_1 = app.$(OBJEXT) as.$(OBJEXT) atof-generic.$(OBJEXT) \[m
++ 	listing.$(OBJEXT) literal.$(OBJEXT) macro.$(OBJEXT) \[m
++ 	messages.$(OBJEXT) output-file.$(OBJEXT) read.$(OBJEXT) \[m
++ 	remap.$(OBJEXT) sb.$(OBJEXT) stabs.$(OBJEXT) subsegs.$(OBJEXT) \[m
++[31m-	symbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) [m
++[32m+[m	[32msymbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) \[m
++[32m+[m	[32mshuffleInfo.pb-c.$(OBJEXT)[m
++[32m+[m[41m	[m
++ am_as_new_OBJECTS = $(am__objects_1)[m
++ as_new_OBJECTS = $(am_as_new_OBJECTS)[m
++ am__DEPENDENCIES_1 =[m
++[36m@@ -368,6 +370,7 @@[m [mGAS_CFILES = \[m
++ 	dwarf2dbg.c \[m
++ 	dw2gencfi.c \[m
++ 	bbInfoHandle.c \[m
++[32m+[m	[32mshuffleInfo.pb-c.c \[m
++ 	ecoff.c \[m
++ 	ehopt.c \[m
++ 	expr.c \[m
++[36m@@ -402,6 +405,7 @@[m [mHFILES = \[m
++ 	dwarf2dbg.h \[m
++ 	dw2gencfi.h \[m
++ 	bbInfoHandle.h \[m
++[32m+[m	[32mshuffleInfo.pb-c.h \[m
++ 	ecoff.h \[m
++ 	emul-target.h \[m
++ 	emul.h \[m
++[1mdiff --git a/bbInfoHandle.c b/bbInfoHandle.c[m
++[1mindex bed65bf..9bd08bb 100644[m
++[1m--- a/bbInfoHandle.c[m
++[1m+++ b/bbInfoHandle.c[m
++[36m@@ -10,6 +10,7 @@[m [mstatic void funcb_bbInfo_handler (int);[m
++ static void funce_bbInfo_handler (int);[m
++ static void bb_bbInfo_handler (int);[m
++ static void be_bbInfo_handler (int);[m
++[32m+[m[32mvoid bbinfo_update_shuffle_info(void);[m
++ bbinfo_mbb* init_basic_block(void);[m
++ bbinfo_fixup* bbinfo_init_fixup(void);[m
++ [m
++[36m@@ -39,6 +40,17 @@[m [msymbolS *last_symbol; // last user defined symbol[m
++ uint32_t cur_block_id; // global current basic block id [m
++ unsigned char function_head; // represent that the current basic block is current function's first entry[m
++ [m
++[32m+[m[32munsigned text_sec_cnt;[m
++[32m+[m[32munsigned rodata_sec_cnt;[m
++[32m+[m[32munsigned data_sec_cnt;[m
++[32m+[m[32munsigned datarel_sec_cnt;[m
++[32m+[m[32munsigned init_sec_cnt;[m
++[32m+[m
++[32m+[m[32m// store the shuffle information[m
++[32m+[m[32mchar* bbinfo_shuffle_info_buf = NULL;[m
++[32m+[m[32munsigned bbinfo_shuffle_info_buf_len = 0;[m
++[32m+[m
++[32m+[m
++ // init the global variables[m
++ void bbinfo_init(){[m
++   fixups_list_head = NULL;[m
++[36m@@ -51,6 +63,11 @@[m [mvoid bbinfo_init(){[m
++   last_symbol = NULL;[m
++   cur_block_id = 0;[m
++   function_head = 0;[m
++[32m+[m[32m  text_sec_cnt = 0;[m
++[32m+[m[32m  data_sec_cnt = 0;[m
++[32m+[m[32m  datarel_sec_cnt = 0;[m
++[32m+[m[32m  rodata_sec_cnt = 0;[m
++[32m+[m[32m  init_sec_cnt = 0;[m
++ }[m
++ [m
++ // update the last_symbol global variable[m
++[36m@@ -72,6 +89,211 @@[m [mint update_last_symbol(symbolS *sym){[m
++   return 0;[m
++ }[m
++ [m
++[32m+[m[32m// generate shuffleInfo into protobuf[m
++[32m+[m[32mvoid bbinfo_update_shuffle_info(void){[m
++[32m+[m[32mShuffleInfo__ReorderInfo reorder_info = SHUFFLE_INFO__REORDER_INFO__INIT;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__BinaryInfo binary_info =[m[41m [m
++[32m+[m[32m  SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;[m
++[32m+[m
++[32m+[m[32mbinary_info.has_rand_obj_offset = 1;[m
++[32m+[m[32mbinary_info.rand_obj_offset = 0; // should be update at linking time[m
++[32m+[m[32mbinary_info.has_main_addr_offset = 1;[m
++[32m+[m[32mbinary_info.main_addr_offset = 0; // should be update at linking time[m
++[32m+[m
++[32m+[m[32m// 0 is ordinary c/c++ file.[m[41m [m
++[32m+[m[32m// 1 is a source file contains inline assembly[m
++[32m+[m[32m// 2 is standalone assembly file[m
++[32m+[m[32m// TODO(binpang). Identify assemble file and inline[m[41m [m
++[32m+[m[32mbinary_info.has_src_type = 1;[m
++[32m+[m[32mbinary_info.src_type = 0;[m
++[32m+[m
++[32m+[m[32mreorder_info.bin = &binary_info;[m
++[32m+[m
++[32m+[m[32munsigned bb_cnt = 0;[m
++[32m+[m[32munsigned text_fixp_cnt = 0;[m
++[32m+[m[32munsigned rodata_fixp_cnt = 0;[m
++[32m+[m[32munsigned data_fixp_cnt = 0;[m
++[32m+[m[32munsigned datarel_fixp_cnt = 0;[m
++[32m+[m[32munsigned init_fixp_cnt = 0;[m
++[32m+[m
++[32m+[m[32m// count the basic block number[m
++[32m+[m[32mfor(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;[m
++[32m+[m[32m    cur_mbb = cur_mbb->next){[m
++[32m+[m[32m  bb_cnt++;[m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m[32m// count the fixp number[m
++[32m+[m[32mfor(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;[m
++[32m+[m[32m    cur_fixp = cur_fixp->next){[m
++[32m+[m[32m  const char* sec_name =cur_fixp->sec->name;[m
++[32m+[m[32m  if (strstr(sec_name, ".text"))[m
++[32m+[m[32m    text_fixp_cnt++;[m
++[32m+[m[32m  else if(strstr(sec_name, ".rodata"))[m
++[32m+[m[32m    rodata_fixp_cnt++;[m
++[32m+[m[32m  else if(strstr(sec_name, ".init_array"))[m
++[32m+[m[32m    init_fixp_cnt++;[m
++[32m+[m[32m  else if(strstr(sec_name, ".data.rel.ro"))[m
++[32m+[m[32m    datarel_fixp_cnt++;[m
++[32m+[m[32m  else if(strstr(sec_name, ".data"))[m
++[32m+[m[32m    data_fixp_cnt++;[m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m[32mShuffleInfo__ReorderInfo__LayoutInfo **layout;[m
++[32m+[m[32mlayout = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo *) * bb_cnt);[m
++[32m+[m[32munsigned index = 0;[m
++[32m+[m[32munsigned obj_size = 0;[m
++[32m+[m[32mfor(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;[m
++[32m+[m[32m    cur_mbb = cur_mbb->next){[m
++[32m+[m[32m  layout[index] = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo));[m
++[32m+[m
++[32m+[m[32m  shuffle_info__reorder_info__layout_info__init(layout[index]);[m
++[32m+[m[32m  layout[index]->has_type = 1;[m
++[32m+[m[32m  layout[index]->type = cur_mbb->type;[m
++[32m+[m[32m  layout[index]->has_bb_size = 1;[m
++[32m+[m[32m  layout[index]->bb_size = cur_mbb->size;[m
++[32m+[m[32m  layout[index]->has_bb_fallthrough = 1;[m
++[32m+[m[32m  layout[index]->bb_fallthrough = cur_mbb->fall_through;[m
++[32m+[m[32m  //TODO, add basic block offset in shuffle.proto[m
++[32m+[m[32m  //TODO, collect num_fixups in gcc toolchain[m
++[32m+[m[32m  layout[index]->section_name = (char*)cur_mbb->sec->name;[m
++[32m+[m[32m  index++;[m
++[32m+[m[41m  [m
++[32m+[m[32m  obj_size += cur_mbb->size;[m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m[32mbinary_info.has_obj_sz;[m
++[32m+[m[32mbinary_info.obj_sz = obj_size;[m
++[32m+[m
++[32m+[m[32m// update layout_info[m
++[32m+[m[32mreorder_info.n_layout = index;[m
++[32m+[m[32mreorder_info.layout = layout;[m
++[32m+[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo **fixup;[m
++[32m+[m[32mfixup = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo *) * 1);[m
++[32m+[m[32mfixup[0] = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo));[m
++[32m+[m[32mshuffle_info__reorder_info__fixup_info__init(fixup[0]);[m
++[32m+[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text_fixp = NULL;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata_fixp = NULL;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data_fixp = NULL;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel_fixp = NULL;[m
++[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **init_fixp = NULL;[m
++[32m+[m
++[32m+[m[32mif (text_fixp_cnt)[m
++[32m+[m[32m  text_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m[41m [m
++[32m+[m[41m    [m								[32mtext_fixp_cnt);[m
++[32m+[m[32mif (rodata_fixp_cnt)[m
++[32m+[m[32m  rodata_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
++[32m+[m[41m    [m								[32mrodata_fixp_cnt);[m
++[32m+[m[32mif (data_fixp_cnt)[m
++[32m+[m[32m  data_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
++[32m+[m[41m      [m								[32mdata_fixp_cnt);[m
++[32m+[m[32mif (init_fixp_cnt)[m
++[32m+[m[32m  init_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
++[32m+[m[41m      [m								[32minit_fixp_cnt);[m
++[32m+[m[32mif (datarel_fixp_cnt)[m
++[32m+[m[32m  datarel_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
++[32m+[m[41m      [m								[32mdatarel_fixp_cnt);[m
++[32m+[m[32munsigned cur_text_index = 0;[m
++[32m+[m[32munsigned cur_rodata_index = 0;[m
++[32m+[m[32munsigned cur_data_index = 0;[m
++[32m+[m[32munsigned cur_datarel_index = 0;[m
++[32m+[m[32munsigned cur_init_index = 0;[m
++[32m+[m
++[32m+[m[32mfor (bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;[m
++[32m+[m[41m    [m					[32mcur_fixp = cur_fixp->next){[m
++[32m+[m[32m  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *cur_fixp_tuple =[m
++[32m+[m[41m    [m		[32mmalloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple));[m
++[32m+[m[32m  shuffle_info__reorder_info__fixup_info__fixup_tuple__init(cur_fixp_tuple);[m[41m [m
++[32m+[m[32m  cur_fixp_tuple->offset = cur_fixp->offset;[m
++[32m+[m[32m  cur_fixp_tuple->deref_sz = cur_fixp->size;[m
++[32m+[m[32m  cur_fixp_tuple->is_rela = cur_fixp->is_rela;[m
++[32m+[m[32m  cur_fixp_tuple->section_name = (char*) cur_fixp->sec->name;[m
++[32m+[m[32m  // jump table information[m
++[32m+[m[32m  if (cur_fixp->table_size){[m
++[32m+[m[32m    cur_fixp_tuple->has_num_jt_entries = 1;[m
++[32m+[m[32m    cur_fixp_tuple->num_jt_entries = cur_fixp->table_size;[m
++[32m+[m[32m    cur_fixp_tuple->has_jt_entry_sz = 1;[m
++[32m+[m[32m    cur_fixp_tuple->jt_entry_sz = cur_fixp->entry_size;[m
++[32m+[m[32m  }[m
++[32m+[m
++[32m+[m[32m  cur_fixp_tuple->has_type = 1;[m
++[32m+[m[32m  if (cur_fixp->is_new_section){[m
++[32m+[m[32m    cur_fixp_tuple->type = 4; // let linker know if there are multiple .text sections[m
++[32m+[m[32m  }else{[m
++[32m+[m[32m    cur_fixp_tuple->type = 0; // c2c, c2d, d2c, d2d default=0; should be updated by linker[m
++[32m+[m[32m  }[m
++[32m+[m
++[32m+[m[32m  const char* sec_name =cur_fixp->sec->name;[m
++[32m+[m[32m  if (strstr(sec_name, ".text"))[m
++[32m+[m[32m    text_fixp[cur_text_index++] = cur_fixp_tuple;[m[41m  [m
++[32m+[m[32m  else if(strstr(sec_name, ".rodata"))[m
++[32m+[m[32m    rodata_fixp[cur_rodata_index++] = cur_fixp_tuple;[m
++[32m+[m[32m  else if(strstr(sec_name, ".init_array"))[m
++[32m+[m[32m    init_fixp[cur_init_index++] = cur_fixp_tuple;[m
++[32m+[m[32m  else if(strstr(sec_name, ".data.rel.ro"))[m
++[32m+[m[32m    datarel_fixp[cur_datarel_index++] = cur_fixp_tuple;[m
++[32m+[m[32m  else if(strstr(sec_name, ".data"))[m
++[32m+[m[32m    data_fixp[cur_data_index++] = cur_fixp_tuple;[m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m[32m// store the fixup information into protobuf[m
++[32m+[m[32mfixup[0]->n_text = text_fixp_cnt;[m
++[32m+[m[32mfixup[0]->text = text_fixp;[m
++[32m+[m[32mfixup[0]->n_rodata = rodata_fixp_cnt;[m
++[32m+[m[32mfixup[0]->rodata = rodata_fixp;[m
++[32m+[m[32mfixup[0]->n_data = data_fixp_cnt;[m
++[32m+[m[32mfixup[0]->data = data_fixp;[m
++[32m+[m[32mfixup[0]->n_datarel = datarel_fixp_cnt;[m
++[32m+[m[32mfixup[0]->datarel = datarel_fixp;[m
++[32m+[m[32mfixup[0]->n_initarray = init_fixp_cnt;[m
++[32m+[m[32mfixup[0]->initarray = init_fixp;[m
++[32m+[m
++[32m+[m[32mreorder_info.n_fixup = 1;[m
++[32m+[m[32mreorder_info.fixup = fixup;[m
++[32m+[m
++[32m+[m[32mbbinfo_shuffle_info_buf_len = protobuf_c_message_get_packed_size(&reorder_info); // get protobuf bytes length[m
++[32m+[m
++[32m+[m[32mbbinfo_shuffle_info_buf = malloc(bbinfo_shuffle_info_buf_len);[m
++[32m+[m[32mprotobuf_c_message_pack(&reorder_info, bbinfo_shuffle_info_buf); // Pack reorder_info into buf[m
++[32m+[m
++[32m+[m[32m// free the malloced space[m
++[32m+[m
++[32m+[m[32m// free layouts[m
++[32m+[m[32mfor(index = 0; index < bb_cnt; index++){[m
++[32m+[m[32m  free(layout[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfree(layout);[m
++[32m+[m
++[32m+[m[32m// free fixups[m
++[32m+[m[32mfor (index = 0; index < text_fixp_cnt; index++){[m
++[32m+[m[32m  free (text_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfor (index = 0; index < data_fixp_cnt; index++){[m
++[32m+[m[32m  free (data_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfor (index = 0; index < rodata_fixp_cnt; index++){[m
++[32m+[m[32m  free (rodata_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfor (index = 0; index < init_fixp_cnt; index++){[m
++[32m+[m[32m  free (init_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mfor (index = 0; index < datarel_fixp_cnt; index++){[m
++[32m+[m[32m  free (datarel_fixp[index]);[m
++[32m+[m[32m}[m
++[32m+[m[32mif (text_fixp_cnt)[m
++[32m+[m[32m free (text_fixp);[m[41m [m
++[32m+[m[32mif (rodata_fixp_cnt)[m
++[32m+[m[32m free (rodata_fixp);[m
++[32m+[m[32mif (data_fixp_cnt)[m
++[32m+[m[32m free (data_fixp);[m
++[32m+[m[32mif (init_fixp_cnt)[m
++[32m+[m[32m free (init_fixp);[m
++[32m+[m[32mif (datarel_fixp_cnt)[m
++[32m+[m[32m free (datarel_fixp);[m[41m [m
++[32m+[m[32m}[m
++[32m+[m
++[32m+[m
++ // init the fixup struct[m
++ bbinfo_fixup* bbinfo_init_fixup(void){[m
++   bbinfo_fixup* result_fixup = malloc(sizeof(bbinfo_fixup));[m
++[36m@@ -88,6 +310,58 @@[m [mbbinfo_fixup* bbinfo_init_fixup(void){[m
++   return result_fixup;[m
++ }[m
++ [m
++[32m+[m[32m// if this is the new section[m
++[32m+[m[32mchar bbinfo_is_new_sec(asection *sec){[m
++[32m+[m[32m  const char* sec_name = sec->name;[m
++[32m+[m[32m  char* tmp_pointer = NULL;[m
++[32m+[m
++[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".text")) &&[m
++[32m+[m[32m      tmp_pointer == sec_name){[m
++[32m+[m[32m    text_sec_cnt++;[m
++[32m+[m[32m    if (text_sec_cnt == 1)[m
++[32m+[m[32m      return 0;[m
++[32m+[m[32m    else[m
++[32m+[m[32m      return 1;[m
++[32m+[m[32m  }[m
++[32m+[m
++[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".rodata")) &&[m[41m [m
++[32m+[m	[32mtmp_pointer == sec_name){[m
++[32m+[m[32m      rodata_sec_cnt++;[m
++[32m+[m[32m      if (rodata_sec_cnt == 1)[m
++[32m+[m	[32mreturn 0;[m
++[32m+[m[32m      else[m
++[32m+[m	[32mreturn 1;[m
++[32m+[m[32m      }[m
++[32m+[m
++[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&[m
++[32m+[m[32m      tmp_pointer == sec_name){[m
++[32m+[m[32m    init_sec_cnt++;[m
++[32m+[m[32m    if (init_sec_cnt == 1)[m
++[32m+[m[32m      return 0;[m
++[32m+[m[32m    else[m
++[32m+[m[32m      return 1;[m
++[32m+[m[32m  }[m
++[32m+[m
++[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".data")) &&[m
++[32m+[m[32m      tmp_pointer == sec_name){[m
++[32m+[m
++[32m+[m[32m    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&[m
++[32m+[m	[32mtmp_pointer == sec_name){[m
++[32m+[m[32m      datarel_sec_cnt++;[m
++[32m+[m[32m      if (datarel_sec_cnt == 1)[m
++[32m+[m	[32mreturn 0;[m
++[32m+[m[32m      else[m
++[32m+[m	[32mreturn 1;[m
++[32m+[m[32m    }[m
++[32m+[m
++[32m+[m[32m    data_sec_cnt++;[m
++[32m+[m[32m    if (data_sec_cnt == 1)[m
++[32m+[m[32m      return 0;[m
++[32m+[m[32m    else[m
++[32m+[m[32m      return 1;[m
++[32m+[m[32m  }[m
++[32m+[m[32m  return -1;[m
++[32m+[m[32m}[m
++ // init the bbinfo struct[m
++ bbinfo_mbb* init_basic_block(){[m
++   // malloc space[m
++[1mdiff --git a/bbInfoHandle.h b/bbInfoHandle.h[m
++[1mindex ac3b8c4..edc727b 100644[m
++[1m--- a/bbInfoHandle.h[m
++[1m+++ b/bbInfoHandle.h[m
++[36m@@ -7,12 +7,14 @@[m
++ #define BBINFOHANDLE_H[m
++ [m
++ #include "as.h"[m
++[32m+[m[32m#include "shuffleInfo.pb-c.h"[m
++ #include <stdint.h>[m
++ [m
++ extern const pseudo_typeS bbInfo_pseudo_table[];[m
++ extern int update_last_symbol(symbolS*);[m
++ extern void init_bbinfo_global(void);[m
++ extern void bbinfo_init(void);[m
++[32m+[m[32mextern char bbinfo_is_new_sec(asection*);[m
++ [m
++ [m
++ [m
++[36m@@ -41,6 +43,7 @@[m [mtypedef struct basic_block bbinfo_mbb;[m
++ typedef struct fixup{[m
++   uint32_t offset; // offset from section[m
++   asection *sec; // which section the basic block belongs to[m
++[32m+[m[32m  unsigned char is_new_section; // if its parent section is the new section that has the same name[m
++   unsigned char is_rela; // if this fixup is relative[m
++   uint32_t size; // the reference's size[m
++   uint32_t table_size; // for jump table reference only[m
++[36m@@ -57,6 +60,17 @@[m [mextern uint32_t prev_function_id; // prev function id[m
++ extern uint32_t cur_function_end_id; // current function end id[m
++ extern symbolS *last_symbol; // last user defined symbol[m
++ extern uint32_t cur_block_id; // global current basic block id[m
++[32m+[m[32m// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number[m
++[32m+[m[32mextern unsigned text_sec_cnt;[m
++[32m+[m[32mextern unsigned rodata_sec_cnt;[m
++[32m+[m[32mextern unsigned data_sec_cnt;[m
++[32m+[m[32mextern unsigned datarel_sec_cnt;[m
++[32m+[m[32mextern unsigned init_sec_cnt;[m
++[32m+[m
++[32m+[m[32m// shuffleInfo that CCR defines[m
++[32m+[m[32mextern char* bbinfo_shuffle_info_buf;[m[41m [m
++[32m+[m[32mextern unsigned bbinfo_shuffle_info_buf_len;[m
++ [m
++ extern bbinfo_fixup* bbinfo_init_fixup(void);[m
++[32m+[m[32mextern void bbinfo_update_shuffle_info(void);[m
++ #endif[m
++[1mdiff --git a/write.c b/write.c[m
++[1mindex 46a22e5..ab5ad70 100644[m
++[1m--- a/write.c[m
++[1m+++ b/write.c[m
++[36m@@ -1198,7 +1198,6 @@[m [mfix_segment (bfd *abfd ATTRIBUTE_UNUSED,[m
++  * binpang, add. [m
++  * collect fixup information before fixup resolved.[m
++  */[m
++[31m-[m
++ static void [m
++ bbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
++     	     asection *sec,[m
++[36m@@ -1206,6 +1205,12 @@[m [mbbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
++ {[m
++   fixS *fixp;[m
++   segment_info_type *seginfo = seg_info (sec);[m
++[32m+[m[32m  char is_new_sec = is_new_sec = bbinfo_is_new_sec(sec);[m
++[32m+[m[41m  [m
++[32m+[m[32m  // we only collect .text, .rodata, .init_array, .data, .data.rel.ro sections[m
++[32m+[m[32m  // FIXME[m
++[32m+[m[32m  if (is_new_sec == -1)[m
++[32m+[m[32m    return;[m
++   [m
++  /*[m
++   * TODO(binpang), add relocation information that .realoc directive defined[m
++[36m@@ -1225,9 +1230,11 @@[m [mbbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
++       tmp_fixp->table_size = S_GET_JMPTBL_SIZE(tmp_sym);[m
++       tmp_fixp->entry_size = S_GET_JMPTBL_ENTRY_SZ(tmp_sym);[m
++     }[m
++[32m+[m[32m    if (is_new_sec){[m
++[32m+[m[32m      tmp_fixp->is_new_section = 1;[m
++[32m+[m[32m    }[m
++   }[m
++ [m
++[31m-[m
++ }[m
++ static void[m
++ install_reloc (asection *sec, arelent *reloc, fragS *fragp,[m
++[36m@@ -1658,6 +1665,19 @@[m [mwrite_contents (bfd *abfd ATTRIBUTE_UNUSED,[m
++   segment_info_type *seginfo = seg_info (sec);[m
++   addressT offset = 0;[m
++   fragS *f;[m
++[32m+[m[41m  [m
++[32m+[m[32m  /*[m
++[32m+[m[32m   * binpang, add[m
++[32m+[m[32m   * output the section .rand[m
++[32m+[m[32m   */[m[41m [m
++[32m+[m[32m  if (!strcmp(sec->name, ".rand")){[m
++[32m+[m[32m    unsigned result = bfd_set_section_contents(stdoutput, sec, bbinfo_shuffle_info_buf,[m[41m [m
++[32m+[m			[32m(file_ptr) 0, (bfd_size_type) bbinfo_shuffle_info_buf_len);[m
++[32m+[m[41m    [m
++[32m+[m[32m    if(!result)[m
++[32m+[m[32m      as_warn(_("can't write data into .rand"));[m
++[32m+[m[32m    return;[m
++[32m+[m[32m  }[m
++ [m
++   /* Write out the frags.  */[m
++   if (seginfo == NULL[m
++[36m@@ -2348,6 +2368,16 @@[m [mwrite_object_file (void)[m
++       bfd_map_over_sections (stdoutput, compress_debug, (char *) 0);[m
++     }[m
++ [m
++[32m+[m[32m  /*[m
++[32m+[m[32m   * binpang, add[m
++[32m+[m[32m   * create .rand section[m
++[32m+[m[32m   */[m
++[32m+[m[32m  asection* rand_sec = bfd_make_section (stdoutput, ".rand");[m
++[32m+[m[32m  bfd_set_section_flags(stdoutput, rand_sec, SEC_HAS_CONTENTS);[m
++[32m+[m[32m  bbinfo_update_shuffle_info();[m
++[32m+[m[32m  // BUG? why should at here specify size. But in write_contents fuction, it can't work.[m
++[32m+[m[32m  rand_sec->size = bbinfo_shuffle_info_buf_len;[m
++[32m+[m
++   bfd_map_over_sections (stdoutput, write_contents, (char *) 0);[m
++ [m
++ // binpang, add. debug.[m
+diff --git a/shuffleInfo.pb-c.c b/shuffleInfo.pb-c.c
+new file mode 100644
+index 0000000..07b2a82
+--- /dev/null
++++ b/shuffleInfo.pb-c.c
+@@ -0,0 +1,598 @@
++/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
++/* Generated from: shuffleInfo.proto */
++
++/* Do not generate deprecated warnings for self */
++#ifndef PROTOBUF_C__NO_DEPRECATED
++#define PROTOBUF_C__NO_DEPRECATED
++#endif
++
++#include "shuffleInfo.pb-c.h"
++void   shuffle_info__reorder_info__binary_info__init
++                     (ShuffleInfo__ReorderInfo__BinaryInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo__BinaryInfo init_value = SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__layout_info__init
++                     (ShuffleInfo__ReorderInfo__LayoutInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo__LayoutInfo init_value = SHUFFLE_INFO__REORDER_INFO__LAYOUT_INFO__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__fixup_info__fixup_tuple__init
++                     (ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple         *message)
++{
++  static const ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple init_value = SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__FIXUP_TUPLE__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__fixup_info__init
++                     (ShuffleInfo__ReorderInfo__FixupInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo__FixupInfo init_value = SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__source_info__init
++                     (ShuffleInfo__ReorderInfo__SourceInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo__SourceInfo init_value = SHUFFLE_INFO__REORDER_INFO__SOURCE_INFO__INIT;
++  *message = init_value;
++}
++void   shuffle_info__reorder_info__init
++                     (ShuffleInfo__ReorderInfo         *message)
++{
++  static const ShuffleInfo__ReorderInfo init_value = SHUFFLE_INFO__REORDER_INFO__INIT;
++  *message = init_value;
++}
++size_t shuffle_info__reorder_info__get_packed_size
++                     (const ShuffleInfo__ReorderInfo *message)
++{
++  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
++  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
++}
++size_t shuffle_info__reorder_info__pack
++                     (const ShuffleInfo__ReorderInfo *message,
++                      uint8_t       *out)
++{
++  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
++  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
++}
++size_t shuffle_info__reorder_info__pack_to_buffer
++                     (const ShuffleInfo__ReorderInfo *message,
++                      ProtobufCBuffer *buffer)
++{
++  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
++  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
++}
++ShuffleInfo__ReorderInfo *
++       shuffle_info__reorder_info__unpack
++                     (ProtobufCAllocator  *allocator,
++                      size_t               len,
++                      const uint8_t       *data)
++{
++  return (ShuffleInfo__ReorderInfo *)
++     protobuf_c_message_unpack (&shuffle_info__reorder_info__descriptor,
++                                allocator, len, data);
++}
++void   shuffle_info__reorder_info__free_unpacked
++                     (ShuffleInfo__ReorderInfo *message,
++                      ProtobufCAllocator *allocator)
++{
++  if(!message)
++    return;
++  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
++  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
++}
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__binary_info__field_descriptors[4] =
++{
++  {
++    "rand_obj_offset",
++    1,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_rand_obj_offset),
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, rand_obj_offset),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "main_addr_offset",
++    2,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_main_addr_offset),
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, main_addr_offset),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "obj_sz",
++    3,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_obj_sz),
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, obj_sz),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "src_type",
++    4,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_src_type),
++    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, src_type),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__binary_info__field_indices_by_name[] = {
++  1,   /* field[1] = main_addr_offset */
++  2,   /* field[2] = obj_sz */
++  0,   /* field[0] = rand_obj_offset */
++  3,   /* field[3] = src_type */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__binary_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 4 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__binary_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.BinaryInfo",
++  "BinaryInfo",
++  "ShuffleInfo__ReorderInfo__BinaryInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__BinaryInfo),
++  4,
++  shuffle_info__reorder_info__binary_info__field_descriptors,
++  shuffle_info__reorder_info__binary_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__binary_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__binary_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__layout_info__field_descriptors[7] =
++{
++  {
++    "bb_size",
++    1,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_bb_size),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, bb_size),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "type",
++    2,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_type),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, type),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "num_fixups",
++    3,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_num_fixups),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, num_fixups),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "bb_fallthrough",
++    4,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_BOOL,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_bb_fallthrough),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, bb_fallthrough),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "section_name",
++    5,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_STRING,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, section_name),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "offset",
++    6,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_offset),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, offset),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "padding_size",
++    7,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_padding_size),
++    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, padding_size),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__layout_info__field_indices_by_name[] = {
++  3,   /* field[3] = bb_fallthrough */
++  0,   /* field[0] = bb_size */
++  2,   /* field[2] = num_fixups */
++  5,   /* field[5] = offset */
++  6,   /* field[6] = padding_size */
++  4,   /* field[4] = section_name */
++  1,   /* field[1] = type */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__layout_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 7 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__layout_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.LayoutInfo",
++  "LayoutInfo",
++  "ShuffleInfo__ReorderInfo__LayoutInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__LayoutInfo),
++  7,
++  shuffle_info__reorder_info__layout_info__field_descriptors,
++  shuffle_info__reorder_info__layout_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__layout_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__layout_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__field_descriptors[7] =
++{
++  {
++    "offset",
++    1,
++    PROTOBUF_C_LABEL_REQUIRED,
++    PROTOBUF_C_TYPE_UINT32,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, offset),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "deref_sz",
++    2,
++    PROTOBUF_C_LABEL_REQUIRED,
++    PROTOBUF_C_TYPE_UINT32,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, deref_sz),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "is_rela",
++    3,
++    PROTOBUF_C_LABEL_REQUIRED,
++    PROTOBUF_C_TYPE_BOOL,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, is_rela),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "type",
++    4,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_type),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, type),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "section_name",
++    5,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_STRING,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, section_name),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "num_jt_entries",
++    6,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_num_jt_entries),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, num_jt_entries),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "jt_entry_sz",
++    7,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_jt_entry_sz),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, jt_entry_sz),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__fixup_info__fixup_tuple__field_indices_by_name[] = {
++  1,   /* field[1] = deref_sz */
++  2,   /* field[2] = is_rela */
++  6,   /* field[6] = jt_entry_sz */
++  5,   /* field[5] = num_jt_entries */
++  0,   /* field[0] = offset */
++  4,   /* field[4] = section_name */
++  3,   /* field[3] = type */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__fixup_info__fixup_tuple__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 7 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple",
++  "FixupTuple",
++  "ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple),
++  7,
++  shuffle_info__reorder_info__fixup_info__fixup_tuple__field_descriptors,
++  shuffle_info__reorder_info__fixup_info__fixup_tuple__field_indices_by_name,
++  1,  shuffle_info__reorder_info__fixup_info__fixup_tuple__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__fixup_info__fixup_tuple__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__fixup_info__field_descriptors[5] =
++{
++  {
++    "text",
++    1,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_text),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, text),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "rodata",
++    2,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_rodata),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, rodata),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "data",
++    3,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_data),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, data),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "datarel",
++    4,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_datarel),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, datarel),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "initarray",
++    5,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_initarray),
++    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, initarray),
++    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__fixup_info__field_indices_by_name[] = {
++  2,   /* field[2] = data */
++  3,   /* field[3] = datarel */
++  4,   /* field[4] = initarray */
++  1,   /* field[1] = rodata */
++  0,   /* field[0] = text */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__fixup_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 5 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.FixupInfo",
++  "FixupInfo",
++  "ShuffleInfo__ReorderInfo__FixupInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__FixupInfo),
++  5,
++  shuffle_info__reorder_info__fixup_info__field_descriptors,
++  shuffle_info__reorder_info__fixup_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__fixup_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__fixup_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__source_info__field_descriptors[1] =
++{
++  {
++    "src_type",
++    1,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_UINT32,
++    offsetof(ShuffleInfo__ReorderInfo__SourceInfo, n_src_type),
++    offsetof(ShuffleInfo__ReorderInfo__SourceInfo, src_type),
++    NULL,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__source_info__field_indices_by_name[] = {
++  0,   /* field[0] = src_type */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__source_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 1 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__source_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo.SourceInfo",
++  "SourceInfo",
++  "ShuffleInfo__ReorderInfo__SourceInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo__SourceInfo),
++  1,
++  shuffle_info__reorder_info__source_info__field_descriptors,
++  shuffle_info__reorder_info__source_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__source_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__source_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
++static const ProtobufCFieldDescriptor shuffle_info__reorder_info__field_descriptors[4] =
++{
++  {
++    "bin",
++    1,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_MESSAGE,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo, bin),
++    &shuffle_info__reorder_info__binary_info__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "layout",
++    2,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo, n_layout),
++    offsetof(ShuffleInfo__ReorderInfo, layout),
++    &shuffle_info__reorder_info__layout_info__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "fixup",
++    3,
++    PROTOBUF_C_LABEL_REPEATED,
++    PROTOBUF_C_TYPE_MESSAGE,
++    offsetof(ShuffleInfo__ReorderInfo, n_fixup),
++    offsetof(ShuffleInfo__ReorderInfo, fixup),
++    &shuffle_info__reorder_info__fixup_info__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++  {
++    "source",
++    4,
++    PROTOBUF_C_LABEL_OPTIONAL,
++    PROTOBUF_C_TYPE_MESSAGE,
++    0,   /* quantifier_offset */
++    offsetof(ShuffleInfo__ReorderInfo, source),
++    &shuffle_info__reorder_info__source_info__descriptor,
++    NULL,
++    0,             /* flags */
++    0,NULL,NULL    /* reserved1,reserved2, etc */
++  },
++};
++static const unsigned shuffle_info__reorder_info__field_indices_by_name[] = {
++  0,   /* field[0] = bin */
++  2,   /* field[2] = fixup */
++  1,   /* field[1] = layout */
++  3,   /* field[3] = source */
++};
++static const ProtobufCIntRange shuffle_info__reorder_info__number_ranges[1 + 1] =
++{
++  { 1, 0 },
++  { 0, 4 }
++};
++const ProtobufCMessageDescriptor shuffle_info__reorder_info__descriptor =
++{
++  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
++  "ShuffleInfo.ReorderInfo",
++  "ReorderInfo",
++  "ShuffleInfo__ReorderInfo",
++  "ShuffleInfo",
++  sizeof(ShuffleInfo__ReorderInfo),
++  4,
++  shuffle_info__reorder_info__field_descriptors,
++  shuffle_info__reorder_info__field_indices_by_name,
++  1,  shuffle_info__reorder_info__number_ranges,
++  (ProtobufCMessageInit) shuffle_info__reorder_info__init,
++  NULL,NULL,NULL    /* reserved[123] */
++};
+diff --git a/shuffleInfo.pb-c.h b/shuffleInfo.pb-c.h
+new file mode 100644
+index 0000000..d036bbf
+--- /dev/null
++++ b/shuffleInfo.pb-c.h
+@@ -0,0 +1,265 @@
++/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
++/* Generated from: shuffleInfo.proto */
++
++#ifndef PROTOBUF_C_shuffleInfo_2eproto__INCLUDED
++#define PROTOBUF_C_shuffleInfo_2eproto__INCLUDED
++
++#include <protobuf-c/protobuf-c.h>
++
++PROTOBUF_C__BEGIN_DECLS
++
++#if PROTOBUF_C_VERSION_NUMBER < 1000000
++# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
++#elif 1003001 < PROTOBUF_C_MIN_COMPILER_VERSION
++# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
++#endif
++
++
++typedef struct _ShuffleInfo__ReorderInfo ShuffleInfo__ReorderInfo;
++typedef struct _ShuffleInfo__ReorderInfo__BinaryInfo ShuffleInfo__ReorderInfo__BinaryInfo;
++typedef struct _ShuffleInfo__ReorderInfo__LayoutInfo ShuffleInfo__ReorderInfo__LayoutInfo;
++typedef struct _ShuffleInfo__ReorderInfo__FixupInfo ShuffleInfo__ReorderInfo__FixupInfo;
++typedef struct _ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple;
++typedef struct _ShuffleInfo__ReorderInfo__SourceInfo ShuffleInfo__ReorderInfo__SourceInfo;
++
++
++/* --- enums --- */
++
++
++/* --- messages --- */
++
++/*
++ * Binary info from ld or ld.gold; reordering range and main offset
++ */
++struct  _ShuffleInfo__ReorderInfo__BinaryInfo
++{
++  ProtobufCMessage base;
++  /*
++   * PLACEHOLDER FOR LINKER
++   */
++  protobuf_c_boolean has_rand_obj_offset;
++  uint32_t rand_obj_offset;
++  /*
++   * PLACEHOLDER FOR LINKER
++   */
++  protobuf_c_boolean has_main_addr_offset;
++  uint32_t main_addr_offset;
++  /*
++   * Verification purpose
++   */
++  protobuf_c_boolean has_obj_sz;
++  uint32_t obj_sz;
++  /*
++   * See the SourceInfo message
++   */
++  protobuf_c_boolean has_src_type;
++  uint32_t src_type;
++};
++#define SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__binary_info__descriptor) \
++    , 0, 0, 0, 0, 0, 0, 0, 0 }
++
++
++/*
++ * Code layout Info (.text) from LLVM
++ * Embeded info ([#func|#fixup]/obj, [#bbk|#fixup]/func, objSz/ea, funcSz/ea)
++ */
++struct  _ShuffleInfo__ReorderInfo__LayoutInfo
++{
++  ProtobufCMessage base;
++  /*
++   * UPDATE AT LINKTIME WITH OBJ ALIGNMENTs
++   */
++  protobuf_c_boolean has_bb_size;
++  uint32_t bb_size;
++  /*
++   * All alignments between fn/bbl are included here
++   */
++  /*
++   * Represents the end of [OBJ|FUN|BBL]
++   */
++  protobuf_c_boolean has_type;
++  uint32_t type;
++  protobuf_c_boolean has_num_fixups;
++  uint32_t num_fixups;
++  protobuf_c_boolean has_bb_fallthrough;
++  protobuf_c_boolean bb_fallthrough;
++  /*
++   * section identifier for c++ mutiple sections
++   */
++  char *section_name;
++  /*
++   * update at linking when combining sections
++   */
++  protobuf_c_boolean has_offset;
++  uint32_t offset;
++  protobuf_c_boolean has_padding_size;
++  uint32_t padding_size;
++};
++#define SHUFFLE_INFO__REORDER_INFO__LAYOUT_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__layout_info__descriptor) \
++    , 0, 0, 0, 0, 0, 0, 0, 0, NULL, 0, 0, 0, 0 }
++
++
++struct  _ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple
++{
++  ProtobufCMessage base;
++  /*
++   * UPDATE AT LINKTIME WHEN COMBINING SECTIONS
++   */
++  uint32_t offset;
++  uint32_t deref_sz;
++  protobuf_c_boolean is_rela;
++  /*
++   * c2c, c2d, d2c, d2d = (0-3)
++   */
++  protobuf_c_boolean has_type;
++  uint32_t type;
++  /*
++   * section identifier for c++ mutiple sections
++   */
++  char *section_name;
++  /*
++   * fixup has a jump table (.rodata) for pic/pie use
++   */
++  /*
++   * number of the jump table entries
++   */
++  protobuf_c_boolean has_num_jt_entries;
++  uint32_t num_jt_entries;
++  /*
++   * size of each jump table entry in byte
++   */
++  protobuf_c_boolean has_jt_entry_sz;
++  uint32_t jt_entry_sz;
++};
++#define SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__FIXUP_TUPLE__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor) \
++    , 0, 0, 0, 0, 0, NULL, 0, 0, 0, 0 }
++
++
++/*
++ * Fixup info in ELF from LLVM
++ */
++struct  _ShuffleInfo__ReorderInfo__FixupInfo
++{
++  ProtobufCMessage base;
++  size_t n_text;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text;
++  size_t n_rodata;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata;
++  size_t n_data;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data;
++  size_t n_datarel;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel;
++  size_t n_initarray;
++  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **initarray;
++};
++#define SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__fixup_info__descriptor) \
++    , 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL }
++
++
++/*
++ * Source info [generalSource(=0) | hasInlineAssembly(=1) | standaloneAssembly(=2)]
++ */
++struct  _ShuffleInfo__ReorderInfo__SourceInfo
++{
++  ProtobufCMessage base;
++  /*
++   * the src_type placeholder for linker
++   */
++  size_t n_src_type;
++  uint32_t *src_type;
++};
++#define SHUFFLE_INFO__REORDER_INFO__SOURCE_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__source_info__descriptor) \
++    , 0,NULL }
++
++
++struct  _ShuffleInfo__ReorderInfo
++{
++  ProtobufCMessage base;
++  ShuffleInfo__ReorderInfo__BinaryInfo *bin;
++  size_t n_layout;
++  ShuffleInfo__ReorderInfo__LayoutInfo **layout;
++  size_t n_fixup;
++  ShuffleInfo__ReorderInfo__FixupInfo **fixup;
++  ShuffleInfo__ReorderInfo__SourceInfo *source;
++};
++#define SHUFFLE_INFO__REORDER_INFO__INIT \
++ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__descriptor) \
++    , NULL, 0,NULL, 0,NULL, NULL }
++
++
++/* ShuffleInfo__ReorderInfo__BinaryInfo methods */
++void   shuffle_info__reorder_info__binary_info__init
++                     (ShuffleInfo__ReorderInfo__BinaryInfo         *message);
++/* ShuffleInfo__ReorderInfo__LayoutInfo methods */
++void   shuffle_info__reorder_info__layout_info__init
++                     (ShuffleInfo__ReorderInfo__LayoutInfo         *message);
++/* ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple methods */
++void   shuffle_info__reorder_info__fixup_info__fixup_tuple__init
++                     (ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple         *message);
++/* ShuffleInfo__ReorderInfo__FixupInfo methods */
++void   shuffle_info__reorder_info__fixup_info__init
++                     (ShuffleInfo__ReorderInfo__FixupInfo         *message);
++/* ShuffleInfo__ReorderInfo__SourceInfo methods */
++void   shuffle_info__reorder_info__source_info__init
++                     (ShuffleInfo__ReorderInfo__SourceInfo         *message);
++/* ShuffleInfo__ReorderInfo methods */
++void   shuffle_info__reorder_info__init
++                     (ShuffleInfo__ReorderInfo         *message);
++size_t shuffle_info__reorder_info__get_packed_size
++                     (const ShuffleInfo__ReorderInfo   *message);
++size_t shuffle_info__reorder_info__pack
++                     (const ShuffleInfo__ReorderInfo   *message,
++                      uint8_t             *out);
++size_t shuffle_info__reorder_info__pack_to_buffer
++                     (const ShuffleInfo__ReorderInfo   *message,
++                      ProtobufCBuffer     *buffer);
++ShuffleInfo__ReorderInfo *
++       shuffle_info__reorder_info__unpack
++                     (ProtobufCAllocator  *allocator,
++                      size_t               len,
++                      const uint8_t       *data);
++void   shuffle_info__reorder_info__free_unpacked
++                     (ShuffleInfo__ReorderInfo *message,
++                      ProtobufCAllocator *allocator);
++/* --- per-message closures --- */
++
++typedef void (*ShuffleInfo__ReorderInfo__BinaryInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo__BinaryInfo *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo__LayoutInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo__LayoutInfo *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple_Closure)
++                 (const ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo__FixupInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo__FixupInfo *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo__SourceInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo__SourceInfo *message,
++                  void *closure_data);
++typedef void (*ShuffleInfo__ReorderInfo_Closure)
++                 (const ShuffleInfo__ReorderInfo *message,
++                  void *closure_data);
++
++/* --- services --- */
++
++
++/* --- descriptors --- */
++
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__binary_info__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__layout_info__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor;
++extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__source_info__descriptor;
++
++PROTOBUF_C__END_DECLS
++
++
++#endif  /* PROTOBUF_C_shuffleInfo_2eproto__INCLUDED */
+diff --git a/shuffleInfo.pb.cc b/shuffleInfo.pb.cc
+new file mode 100644
+index 0000000..dc74474
+--- /dev/null
++++ b/shuffleInfo.pb.cc
+@@ -0,0 +1,3372 @@
++// Generated by the protocol buffer compiler.  DO NOT EDIT!
++// source: shuffleInfo.proto
++
++#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
++#include "shuffleInfo.pb.h"
++
++#include <algorithm>
++
++#include <google/protobuf/stubs/common.h>
++#include <google/protobuf/stubs/port.h>
++#include <google/protobuf/stubs/once.h>
++#include <google/protobuf/io/coded_stream.h>
++#include <google/protobuf/wire_format_lite_inl.h>
++#include <google/protobuf/descriptor.h>
++#include <google/protobuf/generated_message_reflection.h>
++#include <google/protobuf/reflection_ops.h>
++#include <google/protobuf/wire_format.h>
++// @@protoc_insertion_point(includes)
++
++namespace ShuffleInfo {
++class ReorderInfo_BinaryInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_BinaryInfo> {};
++ReorderInfo_BinaryInfoDefaultTypeInternal _ReorderInfo_BinaryInfo_default_instance_;
++class ReorderInfo_LayoutInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_LayoutInfo> {};
++ReorderInfo_LayoutInfoDefaultTypeInternal _ReorderInfo_LayoutInfo_default_instance_;
++class ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_FixupInfo_FixupTuple> {};
++ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal _ReorderInfo_FixupInfo_FixupTuple_default_instance_;
++class ReorderInfo_FixupInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_FixupInfo> {};
++ReorderInfo_FixupInfoDefaultTypeInternal _ReorderInfo_FixupInfo_default_instance_;
++class ReorderInfo_SourceInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_SourceInfo> {};
++ReorderInfo_SourceInfoDefaultTypeInternal _ReorderInfo_SourceInfo_default_instance_;
++class ReorderInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo> {};
++ReorderInfoDefaultTypeInternal _ReorderInfo_default_instance_;
++
++namespace {
++
++::google::protobuf::Metadata file_level_metadata[6];
++
++}  // namespace
++
++
++const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto() GOOGLE_ATTRIBUTE_COLD;
++const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto() {
++  static const ::google::protobuf::uint32 offsets[] = {
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, rand_obj_offset_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, main_addr_offset_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, obj_sz_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, src_type_),
++    0,
++    1,
++    2,
++    3,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, bb_size_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, type_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, num_fixups_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, bb_fallthrough_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, section_name_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, offset_),
++    1,
++    2,
++    3,
++    4,
++    0,
++    5,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, offset_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, deref_sz_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, is_rela_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, type_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, section_name_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, num_jt_entries_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, jt_entry_sz_),
++    1,
++    2,
++    3,
++    4,
++    0,
++    5,
++    6,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, text_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, rodata_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, data_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, datarel_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, initarray_),
++    0,
++    1,
++    2,
++    3,
++    4,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, src_type_),
++    0,
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, _has_bits_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, _internal_metadata_),
++    ~0u,  // no _extensions_
++    ~0u,  // no _oneof_case_
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, bin_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, layout_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, fixup_),
++    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, source_),
++    0,
++    2,
++    3,
++    1,
++  };
++  return offsets;
++}
++
++static const ::google::protobuf::internal::MigrationSchema schemas[] = {
++  { 0, 8, sizeof(ReorderInfo_BinaryInfo)},
++  { 12, 22, sizeof(ReorderInfo_LayoutInfo)},
++  { 28, 39, sizeof(ReorderInfo_FixupInfo_FixupTuple)},
++  { 46, 55, sizeof(ReorderInfo_FixupInfo)},
++  { 60, 65, sizeof(ReorderInfo_SourceInfo)},
++  { 66, 74, sizeof(ReorderInfo)},
++};
++
++static const ::google::protobuf::internal::DefaultInstanceData file_default_instances[] = {
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_BinaryInfo_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_LayoutInfo_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_FixupInfo_FixupTuple_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_FixupInfo_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_SourceInfo_default_instance_), NULL},
++  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_default_instance_), NULL},
++};
++
++namespace {
++
++void protobuf_AssignDescriptors() {
++  protobuf_AddDesc_shuffleInfo_2eproto();
++  ::google::protobuf::MessageFactory* factory = NULL;
++  AssignDescriptors(
++      "shuffleInfo.proto", schemas, file_default_instances, protobuf_Offsets_shuffleInfo_2eproto(), factory,
++      file_level_metadata, NULL, NULL);
++}
++
++void protobuf_AssignDescriptorsOnce() {
++  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
++  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
++}
++
++void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
++void protobuf_RegisterTypes(const ::std::string&) {
++  protobuf_AssignDescriptorsOnce();
++  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 6);
++}
++
++}  // namespace
++
++void protobuf_ShutdownFile_shuffleInfo_2eproto() {
++  _ReorderInfo_BinaryInfo_default_instance_.Shutdown();
++  delete file_level_metadata[0].reflection;
++  _ReorderInfo_LayoutInfo_default_instance_.Shutdown();
++  delete file_level_metadata[1].reflection;
++  _ReorderInfo_FixupInfo_FixupTuple_default_instance_.Shutdown();
++  delete file_level_metadata[2].reflection;
++  _ReorderInfo_FixupInfo_default_instance_.Shutdown();
++  delete file_level_metadata[3].reflection;
++  _ReorderInfo_SourceInfo_default_instance_.Shutdown();
++  delete file_level_metadata[4].reflection;
++  _ReorderInfo_default_instance_.Shutdown();
++  delete file_level_metadata[5].reflection;
++}
++
++void protobuf_InitDefaults_shuffleInfo_2eproto_impl() {
++  GOOGLE_PROTOBUF_VERIFY_VERSION;
++
++  ::google::protobuf::internal::InitProtobufDefaults();
++  _ReorderInfo_BinaryInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_LayoutInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_FixupInfo_FixupTuple_default_instance_.DefaultConstruct();
++  _ReorderInfo_FixupInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_SourceInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_default_instance_.DefaultConstruct();
++  _ReorderInfo_default_instance_.get_mutable()->bin_ = const_cast< ::ShuffleInfo::ReorderInfo_BinaryInfo*>(
++      ::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance());
++  _ReorderInfo_default_instance_.get_mutable()->source_ = const_cast< ::ShuffleInfo::ReorderInfo_SourceInfo*>(
++      ::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance());
++}
++
++void protobuf_InitDefaults_shuffleInfo_2eproto() {
++  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
++  ::google::protobuf::GoogleOnceInit(&once, &protobuf_InitDefaults_shuffleInfo_2eproto_impl);
++}
++void protobuf_AddDesc_shuffleInfo_2eproto_impl() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  static const char descriptor[] = {
++      "\n\021shuffleInfo.proto\022\013ShuffleInfo\"\272\007\n\013Reo"
++      "rderInfo\0220\n\003bin\030\001 \001(\0132#.ShuffleInfo.Reor"
++      "derInfo.BinaryInfo\0223\n\006layout\030\002 \003(\0132#.Shu"
++      "ffleInfo.ReorderInfo.LayoutInfo\0221\n\005fixup"
++      "\030\003 \003(\0132\".ShuffleInfo.ReorderInfo.FixupIn"
++      "fo\0223\n\006source\030\004 \001(\0132#.ShuffleInfo.Reorder"
++      "Info.SourceInfo\032a\n\nBinaryInfo\022\027\n\017rand_ob"
++      "j_offset\030\001 \001(\r\022\030\n\020main_addr_offset\030\002 \001(\r"
++      "\022\016\n\006obj_sz\030\003 \001(\r\022\020\n\010src_type\030\004 \001(\r\032}\n\nLa"
++      "youtInfo\022\017\n\007bb_size\030\001 \001(\r\022\014\n\004type\030\002 \001(\r\022"
++      "\022\n\nnum_fixups\030\003 \001(\r\022\026\n\016bb_fallthrough\030\004 "
++      "\001(\010\022\024\n\014section_name\030\005 \001(\t\022\016\n\006offset\030\006 \001("
++      "\r\032\331\003\n\tFixupInfo\022;\n\004text\030\001 \003(\0132-.ShuffleI"
++      "nfo.ReorderInfo.FixupInfo.FixupTuple\022=\n\006"
++      "rodata\030\002 \003(\0132-.ShuffleInfo.ReorderInfo.F"
++      "ixupInfo.FixupTuple\022;\n\004data\030\003 \003(\0132-.Shuf"
++      "fleInfo.ReorderInfo.FixupInfo.FixupTuple"
++      "\022>\n\007datarel\030\004 \003(\0132-.ShuffleInfo.ReorderI"
++      "nfo.FixupInfo.FixupTuple\022@\n\tinitarray\030\005 "
++      "\003(\0132-.ShuffleInfo.ReorderInfo.FixupInfo."
++      "FixupTuple\032\220\001\n\nFixupTuple\022\016\n\006offset\030\001 \002("
++      "\r\022\020\n\010deref_sz\030\002 \002(\r\022\017\n\007is_rela\030\003 \002(\010\022\014\n\004"
++      "type\030\004 \001(\r\022\024\n\014section_name\030\005 \001(\t\022\026\n\016num_"
++      "jt_entries\030\006 \001(\r\022\023\n\013jt_entry_sz\030\007 \001(\r\032\036\n"
++      "\nSourceInfo\022\020\n\010src_type\030\001 \003(\r"
++  };
++  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
++      descriptor, 989);
++  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
++    "shuffleInfo.proto", &protobuf_RegisterTypes);
++  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_shuffleInfo_2eproto);
++}
++
++GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_shuffleInfo_2eproto_once_);
++void protobuf_AddDesc_shuffleInfo_2eproto() {
++  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_shuffleInfo_2eproto_once_,
++                 &protobuf_AddDesc_shuffleInfo_2eproto_impl);
++}
++// Force AddDescriptors() to be called at static initialization time.
++struct StaticDescriptorInitializer_shuffleInfo_2eproto {
++  StaticDescriptorInitializer_shuffleInfo_2eproto() {
++    protobuf_AddDesc_shuffleInfo_2eproto();
++  }
++} static_descriptor_initializer_shuffleInfo_2eproto_;
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_BinaryInfo::kRandObjOffsetFieldNumber;
++const int ReorderInfo_BinaryInfo::kMainAddrOffsetFieldNumber;
++const int ReorderInfo_BinaryInfo::kObjSzFieldNumber;
++const int ReorderInfo_BinaryInfo::kSrcTypeFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_BinaryInfo::ReorderInfo_BinaryInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.BinaryInfo)
++}
++ReorderInfo_BinaryInfo::ReorderInfo_BinaryInfo(const ReorderInfo_BinaryInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  ::memcpy(&rand_obj_offset_, &from.rand_obj_offset_,
++    reinterpret_cast<char*>(&src_type_) -
++    reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.BinaryInfo)
++}
++
++void ReorderInfo_BinaryInfo::SharedCtor() {
++  _cached_size_ = 0;
++  ::memset(&rand_obj_offset_, 0, reinterpret_cast<char*>(&src_type_) -
++    reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
++}
++
++ReorderInfo_BinaryInfo::~ReorderInfo_BinaryInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.BinaryInfo)
++  SharedDtor();
++}
++
++void ReorderInfo_BinaryInfo::SharedDtor() {
++}
++
++void ReorderInfo_BinaryInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_BinaryInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[0].descriptor;
++}
++
++const ReorderInfo_BinaryInfo& ReorderInfo_BinaryInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_BinaryInfo* ReorderInfo_BinaryInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_BinaryInfo* n = new ReorderInfo_BinaryInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_BinaryInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  if (_has_bits_[0 / 32] & 15u) {
++    ::memset(&rand_obj_offset_, 0, reinterpret_cast<char*>(&src_type_) -
++      reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
++  }
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_BinaryInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // optional uint32 rand_obj_offset = 1;
++      case 1: {
++        if (tag == 8u) {
++          set_has_rand_obj_offset();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &rand_obj_offset_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 main_addr_offset = 2;
++      case 2: {
++        if (tag == 16u) {
++          set_has_main_addr_offset();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &main_addr_offset_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 obj_sz = 3;
++      case 3: {
++        if (tag == 24u) {
++          set_has_obj_sz();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &obj_sz_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 src_type = 4;
++      case 4: {
++        if (tag == 32u) {
++          set_has_src_type();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &src_type_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.BinaryInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.BinaryInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_BinaryInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  // optional uint32 rand_obj_offset = 1;
++  if (has_rand_obj_offset()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rand_obj_offset(), output);
++  }
++
++  // optional uint32 main_addr_offset = 2;
++  if (has_main_addr_offset()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->main_addr_offset(), output);
++  }
++
++  // optional uint32 obj_sz = 3;
++  if (has_obj_sz()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->obj_sz(), output);
++  }
++
++  // optional uint32 src_type = 4;
++  if (has_src_type()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->src_type(), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.BinaryInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo_BinaryInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  // optional uint32 rand_obj_offset = 1;
++  if (has_rand_obj_offset()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->rand_obj_offset(), target);
++  }
++
++  // optional uint32 main_addr_offset = 2;
++  if (has_main_addr_offset()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->main_addr_offset(), target);
++  }
++
++  // optional uint32 obj_sz = 3;
++  if (has_obj_sz()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->obj_sz(), target);
++  }
++
++  // optional uint32 src_type = 4;
++  if (has_src_type()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->src_type(), target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.BinaryInfo)
++  return target;
++}
++
++size_t ReorderInfo_BinaryInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  if (_has_bits_[0 / 32] & 15u) {
++    // optional uint32 rand_obj_offset = 1;
++    if (has_rand_obj_offset()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->rand_obj_offset());
++    }
++
++    // optional uint32 main_addr_offset = 2;
++    if (has_main_addr_offset()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->main_addr_offset());
++    }
++
++    // optional uint32 obj_sz = 3;
++    if (has_obj_sz()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->obj_sz());
++    }
++
++    // optional uint32 src_type = 4;
++    if (has_src_type()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->src_type());
++    }
++
++  }
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_BinaryInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_BinaryInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_BinaryInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.BinaryInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.BinaryInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_BinaryInfo::MergeFrom(const ReorderInfo_BinaryInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  if (from._has_bits_[0 / 32] & 15u) {
++    if (from.has_rand_obj_offset()) {
++      set_rand_obj_offset(from.rand_obj_offset());
++    }
++    if (from.has_main_addr_offset()) {
++      set_main_addr_offset(from.main_addr_offset());
++    }
++    if (from.has_obj_sz()) {
++      set_obj_sz(from.obj_sz());
++    }
++    if (from.has_src_type()) {
++      set_src_type(from.src_type());
++    }
++  }
++}
++
++void ReorderInfo_BinaryInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_BinaryInfo::CopyFrom(const ReorderInfo_BinaryInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_BinaryInfo::IsInitialized() const {
++  return true;
++}
++
++void ReorderInfo_BinaryInfo::Swap(ReorderInfo_BinaryInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_BinaryInfo::InternalSwap(ReorderInfo_BinaryInfo* other) {
++  std::swap(rand_obj_offset_, other->rand_obj_offset_);
++  std::swap(main_addr_offset_, other->main_addr_offset_);
++  std::swap(obj_sz_, other->obj_sz_);
++  std::swap(src_type_, other->src_type_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_BinaryInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[0];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_BinaryInfo
++
++// optional uint32 rand_obj_offset = 1;
++bool ReorderInfo_BinaryInfo::has_rand_obj_offset() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++void ReorderInfo_BinaryInfo::set_has_rand_obj_offset() {
++  _has_bits_[0] |= 0x00000001u;
++}
++void ReorderInfo_BinaryInfo::clear_has_rand_obj_offset() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++void ReorderInfo_BinaryInfo::clear_rand_obj_offset() {
++  rand_obj_offset_ = 0u;
++  clear_has_rand_obj_offset();
++}
++::google::protobuf::uint32 ReorderInfo_BinaryInfo::rand_obj_offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
++  return rand_obj_offset_;
++}
++void ReorderInfo_BinaryInfo::set_rand_obj_offset(::google::protobuf::uint32 value) {
++  set_has_rand_obj_offset();
++  rand_obj_offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
++}
++
++// optional uint32 main_addr_offset = 2;
++bool ReorderInfo_BinaryInfo::has_main_addr_offset() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++void ReorderInfo_BinaryInfo::set_has_main_addr_offset() {
++  _has_bits_[0] |= 0x00000002u;
++}
++void ReorderInfo_BinaryInfo::clear_has_main_addr_offset() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++void ReorderInfo_BinaryInfo::clear_main_addr_offset() {
++  main_addr_offset_ = 0u;
++  clear_has_main_addr_offset();
++}
++::google::protobuf::uint32 ReorderInfo_BinaryInfo::main_addr_offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
++  return main_addr_offset_;
++}
++void ReorderInfo_BinaryInfo::set_main_addr_offset(::google::protobuf::uint32 value) {
++  set_has_main_addr_offset();
++  main_addr_offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
++}
++
++// optional uint32 obj_sz = 3;
++bool ReorderInfo_BinaryInfo::has_obj_sz() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++void ReorderInfo_BinaryInfo::set_has_obj_sz() {
++  _has_bits_[0] |= 0x00000004u;
++}
++void ReorderInfo_BinaryInfo::clear_has_obj_sz() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++void ReorderInfo_BinaryInfo::clear_obj_sz() {
++  obj_sz_ = 0u;
++  clear_has_obj_sz();
++}
++::google::protobuf::uint32 ReorderInfo_BinaryInfo::obj_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
++  return obj_sz_;
++}
++void ReorderInfo_BinaryInfo::set_obj_sz(::google::protobuf::uint32 value) {
++  set_has_obj_sz();
++  obj_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
++}
++
++// optional uint32 src_type = 4;
++bool ReorderInfo_BinaryInfo::has_src_type() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++void ReorderInfo_BinaryInfo::set_has_src_type() {
++  _has_bits_[0] |= 0x00000008u;
++}
++void ReorderInfo_BinaryInfo::clear_has_src_type() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++void ReorderInfo_BinaryInfo::clear_src_type() {
++  src_type_ = 0u;
++  clear_has_src_type();
++}
++::google::protobuf::uint32 ReorderInfo_BinaryInfo::src_type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
++  return src_type_;
++}
++void ReorderInfo_BinaryInfo::set_src_type(::google::protobuf::uint32 value) {
++  set_has_src_type();
++  src_type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_LayoutInfo::kBbSizeFieldNumber;
++const int ReorderInfo_LayoutInfo::kTypeFieldNumber;
++const int ReorderInfo_LayoutInfo::kNumFixupsFieldNumber;
++const int ReorderInfo_LayoutInfo::kBbFallthroughFieldNumber;
++const int ReorderInfo_LayoutInfo::kSectionNameFieldNumber;
++const int ReorderInfo_LayoutInfo::kOffsetFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_LayoutInfo::ReorderInfo_LayoutInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.LayoutInfo)
++}
++ReorderInfo_LayoutInfo::ReorderInfo_LayoutInfo(const ReorderInfo_LayoutInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  if (from.has_section_name()) {
++    section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
++  }
++  ::memcpy(&bb_size_, &from.bb_size_,
++    reinterpret_cast<char*>(&offset_) -
++    reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.LayoutInfo)
++}
++
++void ReorderInfo_LayoutInfo::SharedCtor() {
++  _cached_size_ = 0;
++  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  ::memset(&bb_size_, 0, reinterpret_cast<char*>(&offset_) -
++    reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
++}
++
++ReorderInfo_LayoutInfo::~ReorderInfo_LayoutInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.LayoutInfo)
++  SharedDtor();
++}
++
++void ReorderInfo_LayoutInfo::SharedDtor() {
++  section_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++
++void ReorderInfo_LayoutInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_LayoutInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[1].descriptor;
++}
++
++const ReorderInfo_LayoutInfo& ReorderInfo_LayoutInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_LayoutInfo* ReorderInfo_LayoutInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_LayoutInfo* n = new ReorderInfo_LayoutInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_LayoutInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  if (has_section_name()) {
++    GOOGLE_DCHECK(!section_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
++    (*section_name_.UnsafeRawStringPointer())->clear();
++  }
++  if (_has_bits_[0 / 32] & 62u) {
++    ::memset(&bb_size_, 0, reinterpret_cast<char*>(&offset_) -
++      reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
++  }
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_LayoutInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // optional uint32 bb_size = 1;
++      case 1: {
++        if (tag == 8u) {
++          set_has_bb_size();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &bb_size_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 type = 2;
++      case 2: {
++        if (tag == 16u) {
++          set_has_type();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &type_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 num_fixups = 3;
++      case 3: {
++        if (tag == 24u) {
++          set_has_num_fixups();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &num_fixups_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional bool bb_fallthrough = 4;
++      case 4: {
++        if (tag == 32u) {
++          set_has_bb_fallthrough();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
++                 input, &bb_fallthrough_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional string section_name = 5;
++      case 5: {
++        if (tag == 42u) {
++          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
++                input, this->mutable_section_name()));
++          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++            this->section_name().data(), this->section_name().length(),
++            ::google::protobuf::internal::WireFormat::PARSE,
++            "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 offset = 6;
++      case 6: {
++        if (tag == 48u) {
++          set_has_offset();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &offset_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.LayoutInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.LayoutInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_LayoutInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  // optional uint32 bb_size = 1;
++  if (has_bb_size()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->bb_size(), output);
++  }
++
++  // optional uint32 type = 2;
++  if (has_type()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
++  }
++
++  // optional uint32 num_fixups = 3;
++  if (has_num_fixups()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->num_fixups(), output);
++  }
++
++  // optional bool bb_fallthrough = 4;
++  if (has_bb_fallthrough()) {
++    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->bb_fallthrough(), output);
++  }
++
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++      this->section_name().data(), this->section_name().length(),
++      ::google::protobuf::internal::WireFormat::SERIALIZE,
++      "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
++    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
++      5, this->section_name(), output);
++  }
++
++  // optional uint32 offset = 6;
++  if (has_offset()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->offset(), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.LayoutInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo_LayoutInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  // optional uint32 bb_size = 1;
++  if (has_bb_size()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->bb_size(), target);
++  }
++
++  // optional uint32 type = 2;
++  if (has_type()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->type(), target);
++  }
++
++  // optional uint32 num_fixups = 3;
++  if (has_num_fixups()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->num_fixups(), target);
++  }
++
++  // optional bool bb_fallthrough = 4;
++  if (has_bb_fallthrough()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->bb_fallthrough(), target);
++  }
++
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++      this->section_name().data(), this->section_name().length(),
++      ::google::protobuf::internal::WireFormat::SERIALIZE,
++      "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
++    target =
++      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
++        5, this->section_name(), target);
++  }
++
++  // optional uint32 offset = 6;
++  if (has_offset()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->offset(), target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.LayoutInfo)
++  return target;
++}
++
++size_t ReorderInfo_LayoutInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  if (_has_bits_[0 / 32] & 63u) {
++    // optional string section_name = 5;
++    if (has_section_name()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::StringSize(
++          this->section_name());
++    }
++
++    // optional uint32 bb_size = 1;
++    if (has_bb_size()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->bb_size());
++    }
++
++    // optional uint32 type = 2;
++    if (has_type()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->type());
++    }
++
++    // optional uint32 num_fixups = 3;
++    if (has_num_fixups()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->num_fixups());
++    }
++
++    // optional bool bb_fallthrough = 4;
++    if (has_bb_fallthrough()) {
++      total_size += 1 + 1;
++    }
++
++    // optional uint32 offset = 6;
++    if (has_offset()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->offset());
++    }
++
++  }
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_LayoutInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_LayoutInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_LayoutInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.LayoutInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.LayoutInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_LayoutInfo::MergeFrom(const ReorderInfo_LayoutInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  if (from._has_bits_[0 / 32] & 63u) {
++    if (from.has_section_name()) {
++      set_has_section_name();
++      section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
++    }
++    if (from.has_bb_size()) {
++      set_bb_size(from.bb_size());
++    }
++    if (from.has_type()) {
++      set_type(from.type());
++    }
++    if (from.has_num_fixups()) {
++      set_num_fixups(from.num_fixups());
++    }
++    if (from.has_bb_fallthrough()) {
++      set_bb_fallthrough(from.bb_fallthrough());
++    }
++    if (from.has_offset()) {
++      set_offset(from.offset());
++    }
++  }
++}
++
++void ReorderInfo_LayoutInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_LayoutInfo::CopyFrom(const ReorderInfo_LayoutInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_LayoutInfo::IsInitialized() const {
++  return true;
++}
++
++void ReorderInfo_LayoutInfo::Swap(ReorderInfo_LayoutInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_LayoutInfo::InternalSwap(ReorderInfo_LayoutInfo* other) {
++  section_name_.Swap(&other->section_name_);
++  std::swap(bb_size_, other->bb_size_);
++  std::swap(type_, other->type_);
++  std::swap(num_fixups_, other->num_fixups_);
++  std::swap(bb_fallthrough_, other->bb_fallthrough_);
++  std::swap(offset_, other->offset_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_LayoutInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[1];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_LayoutInfo
++
++// optional uint32 bb_size = 1;
++bool ReorderInfo_LayoutInfo::has_bb_size() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_bb_size() {
++  _has_bits_[0] |= 0x00000002u;
++}
++void ReorderInfo_LayoutInfo::clear_has_bb_size() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++void ReorderInfo_LayoutInfo::clear_bb_size() {
++  bb_size_ = 0u;
++  clear_has_bb_size();
++}
++::google::protobuf::uint32 ReorderInfo_LayoutInfo::bb_size() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
++  return bb_size_;
++}
++void ReorderInfo_LayoutInfo::set_bb_size(::google::protobuf::uint32 value) {
++  set_has_bb_size();
++  bb_size_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
++}
++
++// optional uint32 type = 2;
++bool ReorderInfo_LayoutInfo::has_type() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_type() {
++  _has_bits_[0] |= 0x00000004u;
++}
++void ReorderInfo_LayoutInfo::clear_has_type() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++void ReorderInfo_LayoutInfo::clear_type() {
++  type_ = 0u;
++  clear_has_type();
++}
++::google::protobuf::uint32 ReorderInfo_LayoutInfo::type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.type)
++  return type_;
++}
++void ReorderInfo_LayoutInfo::set_type(::google::protobuf::uint32 value) {
++  set_has_type();
++  type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.type)
++}
++
++// optional uint32 num_fixups = 3;
++bool ReorderInfo_LayoutInfo::has_num_fixups() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_num_fixups() {
++  _has_bits_[0] |= 0x00000008u;
++}
++void ReorderInfo_LayoutInfo::clear_has_num_fixups() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++void ReorderInfo_LayoutInfo::clear_num_fixups() {
++  num_fixups_ = 0u;
++  clear_has_num_fixups();
++}
++::google::protobuf::uint32 ReorderInfo_LayoutInfo::num_fixups() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
++  return num_fixups_;
++}
++void ReorderInfo_LayoutInfo::set_num_fixups(::google::protobuf::uint32 value) {
++  set_has_num_fixups();
++  num_fixups_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
++}
++
++// optional bool bb_fallthrough = 4;
++bool ReorderInfo_LayoutInfo::has_bb_fallthrough() const {
++  return (_has_bits_[0] & 0x00000010u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_bb_fallthrough() {
++  _has_bits_[0] |= 0x00000010u;
++}
++void ReorderInfo_LayoutInfo::clear_has_bb_fallthrough() {
++  _has_bits_[0] &= ~0x00000010u;
++}
++void ReorderInfo_LayoutInfo::clear_bb_fallthrough() {
++  bb_fallthrough_ = false;
++  clear_has_bb_fallthrough();
++}
++bool ReorderInfo_LayoutInfo::bb_fallthrough() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
++  return bb_fallthrough_;
++}
++void ReorderInfo_LayoutInfo::set_bb_fallthrough(bool value) {
++  set_has_bb_fallthrough();
++  bb_fallthrough_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
++}
++
++// optional string section_name = 5;
++bool ReorderInfo_LayoutInfo::has_section_name() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_section_name() {
++  _has_bits_[0] |= 0x00000001u;
++}
++void ReorderInfo_LayoutInfo::clear_has_section_name() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++void ReorderInfo_LayoutInfo::clear_section_name() {
++  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  clear_has_section_name();
++}
++const ::std::string& ReorderInfo_LayoutInfo::section_name() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  return section_name_.GetNoArena();
++}
++void ReorderInfo_LayoutInfo::set_section_name(const ::std::string& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++#if LANG_CXX11
++void ReorderInfo_LayoutInfo::set_section_name(::std::string&& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(
++    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
++  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++#endif
++void ReorderInfo_LayoutInfo::set_section_name(const char* value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
++  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++void ReorderInfo_LayoutInfo::set_section_name(const char* value, size_t size) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
++      ::std::string(reinterpret_cast<const char*>(value), size));
++  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++::std::string* ReorderInfo_LayoutInfo::mutable_section_name() {
++  set_has_section_name();
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++::std::string* ReorderInfo_LayoutInfo::release_section_name() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  clear_has_section_name();
++  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++void ReorderInfo_LayoutInfo::set_allocated_section_name(::std::string* section_name) {
++  if (section_name != NULL) {
++    set_has_section_name();
++  } else {
++    clear_has_section_name();
++  }
++  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++
++// optional uint32 offset = 6;
++bool ReorderInfo_LayoutInfo::has_offset() const {
++  return (_has_bits_[0] & 0x00000020u) != 0;
++}
++void ReorderInfo_LayoutInfo::set_has_offset() {
++  _has_bits_[0] |= 0x00000020u;
++}
++void ReorderInfo_LayoutInfo::clear_has_offset() {
++  _has_bits_[0] &= ~0x00000020u;
++}
++void ReorderInfo_LayoutInfo::clear_offset() {
++  offset_ = 0u;
++  clear_has_offset();
++}
++::google::protobuf::uint32 ReorderInfo_LayoutInfo::offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
++  return offset_;
++}
++void ReorderInfo_LayoutInfo::set_offset(::google::protobuf::uint32 value) {
++  set_has_offset();
++  offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_FixupInfo_FixupTuple::kOffsetFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kDerefSzFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kIsRelaFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kTypeFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kSectionNameFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kNumJtEntriesFieldNumber;
++const int ReorderInfo_FixupInfo_FixupTuple::kJtEntrySzFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_FixupInfo_FixupTuple::ReorderInfo_FixupInfo_FixupTuple()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++}
++ReorderInfo_FixupInfo_FixupTuple::ReorderInfo_FixupInfo_FixupTuple(const ReorderInfo_FixupInfo_FixupTuple& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  if (from.has_section_name()) {
++    section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
++  }
++  ::memcpy(&offset_, &from.offset_,
++    reinterpret_cast<char*>(&jt_entry_sz_) -
++    reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::SharedCtor() {
++  _cached_size_ = 0;
++  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  ::memset(&offset_, 0, reinterpret_cast<char*>(&jt_entry_sz_) -
++    reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
++}
++
++ReorderInfo_FixupInfo_FixupTuple::~ReorderInfo_FixupInfo_FixupTuple() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  SharedDtor();
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::SharedDtor() {
++  section_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_FixupInfo_FixupTuple::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[2].descriptor;
++}
++
++const ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo_FixupTuple::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo_FixupTuple::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_FixupInfo_FixupTuple* n = new ReorderInfo_FixupInfo_FixupTuple;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  if (has_section_name()) {
++    GOOGLE_DCHECK(!section_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
++    (*section_name_.UnsafeRawStringPointer())->clear();
++  }
++  if (_has_bits_[0 / 32] & 126u) {
++    ::memset(&offset_, 0, reinterpret_cast<char*>(&jt_entry_sz_) -
++      reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
++  }
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_FixupInfo_FixupTuple::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // required uint32 offset = 1;
++      case 1: {
++        if (tag == 8u) {
++          set_has_offset();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &offset_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // required uint32 deref_sz = 2;
++      case 2: {
++        if (tag == 16u) {
++          set_has_deref_sz();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &deref_sz_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // required bool is_rela = 3;
++      case 3: {
++        if (tag == 24u) {
++          set_has_is_rela();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
++                 input, &is_rela_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 type = 4;
++      case 4: {
++        if (tag == 32u) {
++          set_has_type();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &type_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional string section_name = 5;
++      case 5: {
++        if (tag == 42u) {
++          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
++                input, this->mutable_section_name()));
++          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++            this->section_name().data(), this->section_name().length(),
++            ::google::protobuf::internal::WireFormat::PARSE,
++            "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 num_jt_entries = 6;
++      case 6: {
++        if (tag == 48u) {
++          set_has_num_jt_entries();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &num_jt_entries_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // optional uint32 jt_entry_sz = 7;
++      case 7: {
++        if (tag == 56u) {
++          set_has_jt_entry_sz();
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, &jt_entry_sz_)));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  // required uint32 offset = 1;
++  if (has_offset()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->offset(), output);
++  }
++
++  // required uint32 deref_sz = 2;
++  if (has_deref_sz()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->deref_sz(), output);
++  }
++
++  // required bool is_rela = 3;
++  if (has_is_rela()) {
++    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_rela(), output);
++  }
++
++  // optional uint32 type = 4;
++  if (has_type()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->type(), output);
++  }
++
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++      this->section_name().data(), this->section_name().length(),
++      ::google::protobuf::internal::WireFormat::SERIALIZE,
++      "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
++    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
++      5, this->section_name(), output);
++  }
++
++  // optional uint32 num_jt_entries = 6;
++  if (has_num_jt_entries()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->num_jt_entries(), output);
++  }
++
++  // optional uint32 jt_entry_sz = 7;
++  if (has_jt_entry_sz()) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->jt_entry_sz(), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++}
++
++::google::protobuf::uint8* ReorderInfo_FixupInfo_FixupTuple::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  // required uint32 offset = 1;
++  if (has_offset()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->offset(), target);
++  }
++
++  // required uint32 deref_sz = 2;
++  if (has_deref_sz()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->deref_sz(), target);
++  }
++
++  // required bool is_rela = 3;
++  if (has_is_rela()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->is_rela(), target);
++  }
++
++  // optional uint32 type = 4;
++  if (has_type()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->type(), target);
++  }
++
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
++      this->section_name().data(), this->section_name().length(),
++      ::google::protobuf::internal::WireFormat::SERIALIZE,
++      "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
++    target =
++      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
++        5, this->section_name(), target);
++  }
++
++  // optional uint32 num_jt_entries = 6;
++  if (has_num_jt_entries()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->num_jt_entries(), target);
++  }
++
++  // optional uint32 jt_entry_sz = 7;
++  if (has_jt_entry_sz()) {
++    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->jt_entry_sz(), target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  return target;
++}
++
++size_t ReorderInfo_FixupInfo_FixupTuple::RequiredFieldsByteSizeFallback() const {
++// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  size_t total_size = 0;
++
++  if (has_offset()) {
++    // required uint32 offset = 1;
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::UInt32Size(
++        this->offset());
++  }
++
++  if (has_deref_sz()) {
++    // required uint32 deref_sz = 2;
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::UInt32Size(
++        this->deref_sz());
++  }
++
++  if (has_is_rela()) {
++    // required bool is_rela = 3;
++    total_size += 1 + 1;
++  }
++
++  return total_size;
++}
++size_t ReorderInfo_FixupInfo_FixupTuple::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
++    // required uint32 offset = 1;
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::UInt32Size(
++        this->offset());
++
++    // required uint32 deref_sz = 2;
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::UInt32Size(
++        this->deref_sz());
++
++    // required bool is_rela = 3;
++    total_size += 1 + 1;
++
++  } else {
++    total_size += RequiredFieldsByteSizeFallback();
++  }
++  // optional string section_name = 5;
++  if (has_section_name()) {
++    total_size += 1 +
++      ::google::protobuf::internal::WireFormatLite::StringSize(
++        this->section_name());
++  }
++
++  if (_has_bits_[0 / 32] & 112u) {
++    // optional uint32 type = 4;
++    if (has_type()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->type());
++    }
++
++    // optional uint32 num_jt_entries = 6;
++    if (has_num_jt_entries()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->num_jt_entries());
++    }
++
++    // optional uint32 jt_entry_sz = 7;
++    if (has_jt_entry_sz()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::UInt32Size(
++          this->jt_entry_sz());
++    }
++
++  }
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_FixupInfo_FixupTuple* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_FixupInfo_FixupTuple>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::MergeFrom(const ReorderInfo_FixupInfo_FixupTuple& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  if (from._has_bits_[0 / 32] & 127u) {
++    if (from.has_section_name()) {
++      set_has_section_name();
++      section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
++    }
++    if (from.has_offset()) {
++      set_offset(from.offset());
++    }
++    if (from.has_deref_sz()) {
++      set_deref_sz(from.deref_sz());
++    }
++    if (from.has_is_rela()) {
++      set_is_rela(from.is_rela());
++    }
++    if (from.has_type()) {
++      set_type(from.type());
++    }
++    if (from.has_num_jt_entries()) {
++      set_num_jt_entries(from.num_jt_entries());
++    }
++    if (from.has_jt_entry_sz()) {
++      set_jt_entry_sz(from.jt_entry_sz());
++    }
++  }
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::CopyFrom(const ReorderInfo_FixupInfo_FixupTuple& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_FixupInfo_FixupTuple::IsInitialized() const {
++  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;
++  return true;
++}
++
++void ReorderInfo_FixupInfo_FixupTuple::Swap(ReorderInfo_FixupInfo_FixupTuple* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_FixupInfo_FixupTuple::InternalSwap(ReorderInfo_FixupInfo_FixupTuple* other) {
++  section_name_.Swap(&other->section_name_);
++  std::swap(offset_, other->offset_);
++  std::swap(deref_sz_, other->deref_sz_);
++  std::swap(is_rela_, other->is_rela_);
++  std::swap(type_, other->type_);
++  std::swap(num_jt_entries_, other->num_jt_entries_);
++  std::swap(jt_entry_sz_, other->jt_entry_sz_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_FixupInfo_FixupTuple::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[2];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_FixupInfo_FixupTuple
++
++// required uint32 offset = 1;
++bool ReorderInfo_FixupInfo_FixupTuple::has_offset() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_offset() {
++  _has_bits_[0] |= 0x00000002u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_offset() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_offset() {
++  offset_ = 0u;
++  clear_has_offset();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
++  return offset_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_offset(::google::protobuf::uint32 value) {
++  set_has_offset();
++  offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
++}
++
++// required uint32 deref_sz = 2;
++bool ReorderInfo_FixupInfo_FixupTuple::has_deref_sz() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_deref_sz() {
++  _has_bits_[0] |= 0x00000004u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_deref_sz() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_deref_sz() {
++  deref_sz_ = 0u;
++  clear_has_deref_sz();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::deref_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
++  return deref_sz_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_deref_sz(::google::protobuf::uint32 value) {
++  set_has_deref_sz();
++  deref_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
++}
++
++// required bool is_rela = 3;
++bool ReorderInfo_FixupInfo_FixupTuple::has_is_rela() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_is_rela() {
++  _has_bits_[0] |= 0x00000008u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_is_rela() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_is_rela() {
++  is_rela_ = false;
++  clear_has_is_rela();
++}
++bool ReorderInfo_FixupInfo_FixupTuple::is_rela() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
++  return is_rela_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_is_rela(bool value) {
++  set_has_is_rela();
++  is_rela_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
++}
++
++// optional uint32 type = 4;
++bool ReorderInfo_FixupInfo_FixupTuple::has_type() const {
++  return (_has_bits_[0] & 0x00000010u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_type() {
++  _has_bits_[0] |= 0x00000010u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_type() {
++  _has_bits_[0] &= ~0x00000010u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_type() {
++  type_ = 0u;
++  clear_has_type();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
++  return type_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_type(::google::protobuf::uint32 value) {
++  set_has_type();
++  type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
++}
++
++// optional string section_name = 5;
++bool ReorderInfo_FixupInfo_FixupTuple::has_section_name() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_section_name() {
++  _has_bits_[0] |= 0x00000001u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_section_name() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_section_name() {
++  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  clear_has_section_name();
++}
++const ::std::string& ReorderInfo_FixupInfo_FixupTuple::section_name() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  return section_name_.GetNoArena();
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const ::std::string& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++#if LANG_CXX11
++void ReorderInfo_FixupInfo_FixupTuple::set_section_name(::std::string&& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(
++    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
++  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++#endif
++void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
++  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value, size_t size) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
++      ::std::string(reinterpret_cast<const char*>(value), size));
++  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++::std::string* ReorderInfo_FixupInfo_FixupTuple::mutable_section_name() {
++  set_has_section_name();
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++::std::string* ReorderInfo_FixupInfo_FixupTuple::release_section_name() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  clear_has_section_name();
++  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_allocated_section_name(::std::string* section_name) {
++  if (section_name != NULL) {
++    set_has_section_name();
++  } else {
++    clear_has_section_name();
++  }
++  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++
++// optional uint32 num_jt_entries = 6;
++bool ReorderInfo_FixupInfo_FixupTuple::has_num_jt_entries() const {
++  return (_has_bits_[0] & 0x00000020u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_num_jt_entries() {
++  _has_bits_[0] |= 0x00000020u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_num_jt_entries() {
++  _has_bits_[0] &= ~0x00000020u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_num_jt_entries() {
++  num_jt_entries_ = 0u;
++  clear_has_num_jt_entries();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::num_jt_entries() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
++  return num_jt_entries_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_num_jt_entries(::google::protobuf::uint32 value) {
++  set_has_num_jt_entries();
++  num_jt_entries_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
++}
++
++// optional uint32 jt_entry_sz = 7;
++bool ReorderInfo_FixupInfo_FixupTuple::has_jt_entry_sz() const {
++  return (_has_bits_[0] & 0x00000040u) != 0;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_has_jt_entry_sz() {
++  _has_bits_[0] |= 0x00000040u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_has_jt_entry_sz() {
++  _has_bits_[0] &= ~0x00000040u;
++}
++void ReorderInfo_FixupInfo_FixupTuple::clear_jt_entry_sz() {
++  jt_entry_sz_ = 0u;
++  clear_has_jt_entry_sz();
++}
++::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::jt_entry_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
++  return jt_entry_sz_;
++}
++void ReorderInfo_FixupInfo_FixupTuple::set_jt_entry_sz(::google::protobuf::uint32 value) {
++  set_has_jt_entry_sz();
++  jt_entry_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_FixupInfo::kTextFieldNumber;
++const int ReorderInfo_FixupInfo::kRodataFieldNumber;
++const int ReorderInfo_FixupInfo::kDataFieldNumber;
++const int ReorderInfo_FixupInfo::kDatarelFieldNumber;
++const int ReorderInfo_FixupInfo::kInitarrayFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_FixupInfo::ReorderInfo_FixupInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.FixupInfo)
++}
++ReorderInfo_FixupInfo::ReorderInfo_FixupInfo(const ReorderInfo_FixupInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0),
++      text_(from.text_),
++      rodata_(from.rodata_),
++      data_(from.data_),
++      datarel_(from.datarel_),
++      initarray_(from.initarray_) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.FixupInfo)
++}
++
++void ReorderInfo_FixupInfo::SharedCtor() {
++  _cached_size_ = 0;
++}
++
++ReorderInfo_FixupInfo::~ReorderInfo_FixupInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.FixupInfo)
++  SharedDtor();
++}
++
++void ReorderInfo_FixupInfo::SharedDtor() {
++}
++
++void ReorderInfo_FixupInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_FixupInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[3].descriptor;
++}
++
++const ReorderInfo_FixupInfo& ReorderInfo_FixupInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_FixupInfo* ReorderInfo_FixupInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_FixupInfo* n = new ReorderInfo_FixupInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_FixupInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  text_.Clear();
++  rodata_.Clear();
++  data_.Clear();
++  datarel_.Clear();
++  initarray_.Clear();
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_FixupInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++      case 1: {
++        if (tag == 10u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_text()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++      case 2: {
++        if (tag == 18u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_rodata()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++      case 3: {
++        if (tag == 26u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_data()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++      case 4: {
++        if (tag == 34u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_datarel()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++      case 5: {
++        if (tag == 42u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_initarray()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.FixupInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.FixupInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_FixupInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++  for (unsigned int i = 0, n = this->text_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      1, this->text(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++  for (unsigned int i = 0, n = this->rodata_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      2, this->rodata(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      3, this->data(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++  for (unsigned int i = 0, n = this->datarel_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      4, this->datarel(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++  for (unsigned int i = 0, n = this->initarray_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      5, this->initarray(i), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.FixupInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo_FixupInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++  for (unsigned int i = 0, n = this->text_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        1, this->text(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++  for (unsigned int i = 0, n = this->rodata_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        2, this->rodata(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        3, this->data(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++  for (unsigned int i = 0, n = this->datarel_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        4, this->datarel(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++  for (unsigned int i = 0, n = this->initarray_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        5, this->initarray(i), false, target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.FixupInfo)
++  return target;
++}
++
++size_t ReorderInfo_FixupInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++  {
++    unsigned int count = this->text_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->text(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++  {
++    unsigned int count = this->rodata_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->rodata(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++  {
++    unsigned int count = this->data_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->data(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++  {
++    unsigned int count = this->datarel_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->datarel(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++  {
++    unsigned int count = this->initarray_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->initarray(i));
++    }
++  }
++
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_FixupInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_FixupInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_FixupInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.FixupInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.FixupInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_FixupInfo::MergeFrom(const ReorderInfo_FixupInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  text_.MergeFrom(from.text_);
++  rodata_.MergeFrom(from.rodata_);
++  data_.MergeFrom(from.data_);
++  datarel_.MergeFrom(from.datarel_);
++  initarray_.MergeFrom(from.initarray_);
++}
++
++void ReorderInfo_FixupInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_FixupInfo::CopyFrom(const ReorderInfo_FixupInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_FixupInfo::IsInitialized() const {
++  if (!::google::protobuf::internal::AllAreInitialized(this->text())) return false;
++  if (!::google::protobuf::internal::AllAreInitialized(this->rodata())) return false;
++  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
++  if (!::google::protobuf::internal::AllAreInitialized(this->datarel())) return false;
++  if (!::google::protobuf::internal::AllAreInitialized(this->initarray())) return false;
++  return true;
++}
++
++void ReorderInfo_FixupInfo::Swap(ReorderInfo_FixupInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_FixupInfo::InternalSwap(ReorderInfo_FixupInfo* other) {
++  text_.UnsafeArenaSwap(&other->text_);
++  rodata_.UnsafeArenaSwap(&other->rodata_);
++  data_.UnsafeArenaSwap(&other->data_);
++  datarel_.UnsafeArenaSwap(&other->datarel_);
++  initarray_.UnsafeArenaSwap(&other->initarray_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_FixupInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[3];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_FixupInfo
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++int ReorderInfo_FixupInfo::text_size() const {
++  return text_.size();
++}
++void ReorderInfo_FixupInfo::clear_text() {
++  text_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::text(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_text(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_text() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_text() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return &text_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::text() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++int ReorderInfo_FixupInfo::rodata_size() const {
++  return rodata_.size();
++}
++void ReorderInfo_FixupInfo::clear_rodata() {
++  rodata_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::rodata(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_rodata(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_rodata() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_rodata() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return &rodata_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::rodata() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++int ReorderInfo_FixupInfo::data_size() const {
++  return data_.size();
++}
++void ReorderInfo_FixupInfo::clear_data() {
++  data_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::data(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_data(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_data() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_data() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return &data_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::data() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++int ReorderInfo_FixupInfo::datarel_size() const {
++  return datarel_.size();
++}
++void ReorderInfo_FixupInfo::clear_datarel() {
++  datarel_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::datarel(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_datarel(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_datarel() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_datarel() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return &datarel_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::datarel() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++int ReorderInfo_FixupInfo::initarray_size() const {
++  return initarray_.size();
++}
++void ReorderInfo_FixupInfo::clear_initarray() {
++  initarray_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::initarray(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_initarray(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_initarray() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_initarray() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return &initarray_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::initarray() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_;
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo_SourceInfo::kSrcTypeFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo_SourceInfo::ReorderInfo_SourceInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.SourceInfo)
++}
++ReorderInfo_SourceInfo::ReorderInfo_SourceInfo(const ReorderInfo_SourceInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0),
++      src_type_(from.src_type_) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.SourceInfo)
++}
++
++void ReorderInfo_SourceInfo::SharedCtor() {
++  _cached_size_ = 0;
++}
++
++ReorderInfo_SourceInfo::~ReorderInfo_SourceInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.SourceInfo)
++  SharedDtor();
++}
++
++void ReorderInfo_SourceInfo::SharedDtor() {
++}
++
++void ReorderInfo_SourceInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo_SourceInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[4].descriptor;
++}
++
++const ReorderInfo_SourceInfo& ReorderInfo_SourceInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo_SourceInfo* ReorderInfo_SourceInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo_SourceInfo* n = new ReorderInfo_SourceInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo_SourceInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  src_type_.Clear();
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo_SourceInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // repeated uint32 src_type = 1;
++      case 1: {
++        if (tag == 8u) {
++          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 1, 8u, input, this->mutable_src_type())));
++        } else if (tag == 10u) {
++          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
++                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
++                 input, this->mutable_src_type())));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.SourceInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.SourceInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo_SourceInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  // repeated uint32 src_type = 1;
++  for (int i = 0; i < this->src_type_size(); i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
++      1, this->src_type(i), output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.SourceInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo_SourceInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  // repeated uint32 src_type = 1;
++  for (int i = 0; i < this->src_type_size(); i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      WriteUInt32ToArray(1, this->src_type(i), target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.SourceInfo)
++  return target;
++}
++
++size_t ReorderInfo_SourceInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  // repeated uint32 src_type = 1;
++  {
++    size_t data_size = 0;
++    unsigned int count = this->src_type_size();
++    for (unsigned int i = 0; i < count; i++) {
++      data_size += ::google::protobuf::internal::WireFormatLite::
++        UInt32Size(this->src_type(i));
++    }
++    total_size += 1 *
++                  ::google::protobuf::internal::FromIntSize(this->src_type_size());
++    total_size += data_size;
++  }
++
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo_SourceInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo_SourceInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_SourceInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.SourceInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.SourceInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo_SourceInfo::MergeFrom(const ReorderInfo_SourceInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  src_type_.MergeFrom(from.src_type_);
++}
++
++void ReorderInfo_SourceInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo_SourceInfo::CopyFrom(const ReorderInfo_SourceInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo_SourceInfo::IsInitialized() const {
++  return true;
++}
++
++void ReorderInfo_SourceInfo::Swap(ReorderInfo_SourceInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo_SourceInfo::InternalSwap(ReorderInfo_SourceInfo* other) {
++  src_type_.UnsafeArenaSwap(&other->src_type_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo_SourceInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[4];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_SourceInfo
++
++// repeated uint32 src_type = 1;
++int ReorderInfo_SourceInfo::src_type_size() const {
++  return src_type_.size();
++}
++void ReorderInfo_SourceInfo::clear_src_type() {
++  src_type_.Clear();
++}
++::google::protobuf::uint32 ReorderInfo_SourceInfo::src_type(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return src_type_.Get(index);
++}
++void ReorderInfo_SourceInfo::set_src_type(int index, ::google::protobuf::uint32 value) {
++  src_type_.Set(index, value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++}
++void ReorderInfo_SourceInfo::add_src_type(::google::protobuf::uint32 value) {
++  src_type_.Add(value);
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++}
++const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
++ReorderInfo_SourceInfo::src_type() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return src_type_;
++}
++::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
++ReorderInfo_SourceInfo::mutable_src_type() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return &src_type_;
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// ===================================================================
++
++#if !defined(_MSC_VER) || _MSC_VER >= 1900
++const int ReorderInfo::kBinFieldNumber;
++const int ReorderInfo::kLayoutFieldNumber;
++const int ReorderInfo::kFixupFieldNumber;
++const int ReorderInfo::kSourceFieldNumber;
++#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
++
++ReorderInfo::ReorderInfo()
++  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
++  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
++    protobuf_InitDefaults_shuffleInfo_2eproto();
++  }
++  SharedCtor();
++  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo)
++}
++ReorderInfo::ReorderInfo(const ReorderInfo& from)
++  : ::google::protobuf::Message(),
++      _internal_metadata_(NULL),
++      _has_bits_(from._has_bits_),
++      _cached_size_(0),
++      layout_(from.layout_),
++      fixup_(from.fixup_) {
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  if (from.has_bin()) {
++    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo(*from.bin_);
++  } else {
++    bin_ = NULL;
++  }
++  if (from.has_source()) {
++    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo(*from.source_);
++  } else {
++    source_ = NULL;
++  }
++  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo)
++}
++
++void ReorderInfo::SharedCtor() {
++  _cached_size_ = 0;
++  ::memset(&bin_, 0, reinterpret_cast<char*>(&source_) -
++    reinterpret_cast<char*>(&bin_) + sizeof(source_));
++}
++
++ReorderInfo::~ReorderInfo() {
++  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo)
++  SharedDtor();
++}
++
++void ReorderInfo::SharedDtor() {
++  if (this != internal_default_instance()) {
++    delete bin_;
++  }
++  if (this != internal_default_instance()) {
++    delete source_;
++  }
++}
++
++void ReorderInfo::SetCachedSize(int size) const {
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++}
++const ::google::protobuf::Descriptor* ReorderInfo::descriptor() {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[5].descriptor;
++}
++
++const ReorderInfo& ReorderInfo::default_instance() {
++  protobuf_InitDefaults_shuffleInfo_2eproto();
++  return *internal_default_instance();
++}
++
++ReorderInfo* ReorderInfo::New(::google::protobuf::Arena* arena) const {
++  ReorderInfo* n = new ReorderInfo;
++  if (arena != NULL) {
++    arena->Own(n);
++  }
++  return n;
++}
++
++void ReorderInfo::Clear() {
++// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo)
++  layout_.Clear();
++  fixup_.Clear();
++  if (_has_bits_[0 / 32] & 3u) {
++    if (has_bin()) {
++      GOOGLE_DCHECK(bin_ != NULL);
++      bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
++    }
++    if (has_source()) {
++      GOOGLE_DCHECK(source_ != NULL);
++      source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
++    }
++  }
++  _has_bits_.Clear();
++  _internal_metadata_.Clear();
++}
++
++bool ReorderInfo::MergePartialFromCodedStream(
++    ::google::protobuf::io::CodedInputStream* input) {
++#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
++  ::google::protobuf::uint32 tag;
++  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo)
++  for (;;) {
++    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
++    tag = p.first;
++    if (!p.second) goto handle_unusual;
++    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
++      // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++      case 1: {
++        if (tag == 10u) {
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
++               input, mutable_bin()));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++      case 2: {
++        if (tag == 18u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_layout()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++      case 3: {
++        if (tag == 26u) {
++          DO_(input->IncrementRecursionDepth());
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
++                input, add_fixup()));
++        } else {
++          goto handle_unusual;
++        }
++        input->UnsafeDecrementRecursionDepth();
++        break;
++      }
++
++      // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++      case 4: {
++        if (tag == 34u) {
++          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
++               input, mutable_source()));
++        } else {
++          goto handle_unusual;
++        }
++        break;
++      }
++
++      default: {
++      handle_unusual:
++        if (tag == 0 ||
++            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
++            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
++          goto success;
++        }
++        DO_(::google::protobuf::internal::WireFormat::SkipField(
++              input, tag, mutable_unknown_fields()));
++        break;
++      }
++    }
++  }
++success:
++  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo)
++  return true;
++failure:
++  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo)
++  return false;
++#undef DO_
++}
++
++void ReorderInfo::SerializeWithCachedSizes(
++    ::google::protobuf::io::CodedOutputStream* output) const {
++  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo)
++  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++  if (has_bin()) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      1, *this->bin_, output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++  for (unsigned int i = 0, n = this->layout_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      2, this->layout(i), output);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++  for (unsigned int i = 0, n = this->fixup_size(); i < n; i++) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      3, this->fixup(i), output);
++  }
++
++  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++  if (has_source()) {
++    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
++      4, *this->source_, output);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
++        unknown_fields(), output);
++  }
++  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo)
++}
++
++::google::protobuf::uint8* ReorderInfo::InternalSerializeWithCachedSizesToArray(
++    bool deterministic, ::google::protobuf::uint8* target) const {
++  (void)deterministic; // Unused
++  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo)
++  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++  if (has_bin()) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        1, *this->bin_, false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++  for (unsigned int i = 0, n = this->layout_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        2, this->layout(i), false, target);
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++  for (unsigned int i = 0, n = this->fixup_size(); i < n; i++) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        3, this->fixup(i), false, target);
++  }
++
++  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++  if (has_source()) {
++    target = ::google::protobuf::internal::WireFormatLite::
++      InternalWriteMessageNoVirtualToArray(
++        4, *this->source_, false, target);
++  }
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
++        unknown_fields(), target);
++  }
++  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo)
++  return target;
++}
++
++size_t ReorderInfo::ByteSizeLong() const {
++// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo)
++  size_t total_size = 0;
++
++  if (_internal_metadata_.have_unknown_fields()) {
++    total_size +=
++      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
++        unknown_fields());
++  }
++  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++  {
++    unsigned int count = this->layout_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->layout(i));
++    }
++  }
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++  {
++    unsigned int count = this->fixup_size();
++    total_size += 1UL * count;
++    for (unsigned int i = 0; i < count; i++) {
++      total_size +=
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          this->fixup(i));
++    }
++  }
++
++  if (_has_bits_[0 / 32] & 3u) {
++    // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++    if (has_bin()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          *this->bin_);
++    }
++
++    // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++    if (has_source()) {
++      total_size += 1 +
++        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
++          *this->source_);
++    }
++
++  }
++  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
++  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
++  _cached_size_ = cached_size;
++  GOOGLE_SAFE_CONCURRENT_WRITES_END();
++  return total_size;
++}
++
++void ReorderInfo::MergeFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  const ReorderInfo* source =
++      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo>(
++          &from);
++  if (source == NULL) {
++  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo)
++    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
++  } else {
++  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo)
++    MergeFrom(*source);
++  }
++}
++
++void ReorderInfo::MergeFrom(const ReorderInfo& from) {
++// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo)
++  GOOGLE_DCHECK_NE(&from, this);
++  _internal_metadata_.MergeFrom(from._internal_metadata_);
++  layout_.MergeFrom(from.layout_);
++  fixup_.MergeFrom(from.fixup_);
++  if (from._has_bits_[0 / 32] & 3u) {
++    if (from.has_bin()) {
++      mutable_bin()->::ShuffleInfo::ReorderInfo_BinaryInfo::MergeFrom(from.bin());
++    }
++    if (from.has_source()) {
++      mutable_source()->::ShuffleInfo::ReorderInfo_SourceInfo::MergeFrom(from.source());
++    }
++  }
++}
++
++void ReorderInfo::CopyFrom(const ::google::protobuf::Message& from) {
++// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++void ReorderInfo::CopyFrom(const ReorderInfo& from) {
++// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo)
++  if (&from == this) return;
++  Clear();
++  MergeFrom(from);
++}
++
++bool ReorderInfo::IsInitialized() const {
++  if (!::google::protobuf::internal::AllAreInitialized(this->fixup())) return false;
++  return true;
++}
++
++void ReorderInfo::Swap(ReorderInfo* other) {
++  if (other == this) return;
++  InternalSwap(other);
++}
++void ReorderInfo::InternalSwap(ReorderInfo* other) {
++  layout_.UnsafeArenaSwap(&other->layout_);
++  fixup_.UnsafeArenaSwap(&other->fixup_);
++  std::swap(bin_, other->bin_);
++  std::swap(source_, other->source_);
++  std::swap(_has_bits_[0], other->_has_bits_[0]);
++  _internal_metadata_.Swap(&other->_internal_metadata_);
++  std::swap(_cached_size_, other->_cached_size_);
++}
++
++::google::protobuf::Metadata ReorderInfo::GetMetadata() const {
++  protobuf_AssignDescriptorsOnce();
++  return file_level_metadata[5];
++}
++
++#if PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo
++
++// optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++bool ReorderInfo::has_bin() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++void ReorderInfo::set_has_bin() {
++  _has_bits_[0] |= 0x00000001u;
++}
++void ReorderInfo::clear_has_bin() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++void ReorderInfo::clear_bin() {
++  if (bin_ != NULL) bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
++  clear_has_bin();
++}
++const ::ShuffleInfo::ReorderInfo_BinaryInfo& ReorderInfo::bin() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.bin)
++  return bin_ != NULL ? *bin_
++                         : *::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance();
++}
++::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::mutable_bin() {
++  set_has_bin();
++  if (bin_ == NULL) {
++    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo;
++  }
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.bin)
++  return bin_;
++}
++::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::release_bin() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.bin)
++  clear_has_bin();
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* temp = bin_;
++  bin_ = NULL;
++  return temp;
++}
++void ReorderInfo::set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin) {
++  delete bin_;
++  bin_ = bin;
++  if (bin) {
++    set_has_bin();
++  } else {
++    clear_has_bin();
++  }
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.bin)
++}
++
++// repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++int ReorderInfo::layout_size() const {
++  return layout_.size();
++}
++void ReorderInfo::clear_layout() {
++  layout_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_LayoutInfo& ReorderInfo::layout(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::mutable_layout(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::add_layout() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
++ReorderInfo::mutable_layout() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.layout)
++  return &layout_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
++ReorderInfo::layout() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.layout)
++  return layout_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++int ReorderInfo::fixup_size() const {
++  return fixup_.size();
++}
++void ReorderInfo::clear_fixup() {
++  fixup_.Clear();
++}
++const ::ShuffleInfo::ReorderInfo_FixupInfo& ReorderInfo::fixup(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Get(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::mutable_fixup(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Mutable(index);
++}
++::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::add_fixup() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Add();
++}
++::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
++ReorderInfo::mutable_fixup() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.fixup)
++  return &fixup_;
++}
++const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
++ReorderInfo::fixup() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_;
++}
++
++// optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++bool ReorderInfo::has_source() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++void ReorderInfo::set_has_source() {
++  _has_bits_[0] |= 0x00000002u;
++}
++void ReorderInfo::clear_has_source() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++void ReorderInfo::clear_source() {
++  if (source_ != NULL) source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
++  clear_has_source();
++}
++const ::ShuffleInfo::ReorderInfo_SourceInfo& ReorderInfo::source() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.source)
++  return source_ != NULL ? *source_
++                         : *::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance();
++}
++::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::mutable_source() {
++  set_has_source();
++  if (source_ == NULL) {
++    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo;
++  }
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.source)
++  return source_;
++}
++::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::release_source() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.source)
++  clear_has_source();
++  ::ShuffleInfo::ReorderInfo_SourceInfo* temp = source_;
++  source_ = NULL;
++  return temp;
++}
++void ReorderInfo::set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source) {
++  delete source_;
++  source_ = source;
++  if (source) {
++    set_has_source();
++  } else {
++    clear_has_source();
++  }
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.source)
++}
++
++#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
++
++// @@protoc_insertion_point(namespace_scope)
++
++}  // namespace ShuffleInfo
++
++// @@protoc_insertion_point(global_scope)
+diff --git a/shuffleInfo.pb.h b/shuffleInfo.pb.h
+new file mode 100644
+index 0000000..aea266f
+--- /dev/null
++++ b/shuffleInfo.pb.h
+@@ -0,0 +1,1771 @@
++// Generated by the protocol buffer compiler.  DO NOT EDIT!
++// source: shuffleInfo.proto
++
++#ifndef PROTOBUF_shuffleInfo_2eproto__INCLUDED
++#define PROTOBUF_shuffleInfo_2eproto__INCLUDED
++
++#include <string>
++
++#include <google/protobuf/stubs/common.h>
++
++#if GOOGLE_PROTOBUF_VERSION < 3001000
++#error This file was generated by a newer version of protoc which is
++#error incompatible with your Protocol Buffer headers.  Please update
++#error your headers.
++#endif
++#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
++#error This file was generated by an older version of protoc which is
++#error incompatible with your Protocol Buffer headers.  Please
++#error regenerate this file with a newer version of protoc.
++#endif
++
++#include <google/protobuf/arena.h>
++#include <google/protobuf/arenastring.h>
++#include <google/protobuf/generated_message_util.h>
++#include <google/protobuf/metadata.h>
++#include <google/protobuf/message.h>
++#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
++#include <google/protobuf/extension_set.h>  // IWYU pragma: export
++#include <google/protobuf/unknown_field_set.h>
++// @@protoc_insertion_point(includes)
++namespace ShuffleInfo {
++class ReorderInfo;
++class ReorderInfoDefaultTypeInternal;
++extern ReorderInfoDefaultTypeInternal _ReorderInfo_default_instance_;
++class ReorderInfo_BinaryInfo;
++class ReorderInfo_BinaryInfoDefaultTypeInternal;
++extern ReorderInfo_BinaryInfoDefaultTypeInternal _ReorderInfo_BinaryInfo_default_instance_;
++class ReorderInfo_FixupInfo;
++class ReorderInfo_FixupInfoDefaultTypeInternal;
++extern ReorderInfo_FixupInfoDefaultTypeInternal _ReorderInfo_FixupInfo_default_instance_;
++class ReorderInfo_FixupInfo_FixupTuple;
++class ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal;
++extern ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal _ReorderInfo_FixupInfo_FixupTuple_default_instance_;
++class ReorderInfo_LayoutInfo;
++class ReorderInfo_LayoutInfoDefaultTypeInternal;
++extern ReorderInfo_LayoutInfoDefaultTypeInternal _ReorderInfo_LayoutInfo_default_instance_;
++class ReorderInfo_SourceInfo;
++class ReorderInfo_SourceInfoDefaultTypeInternal;
++extern ReorderInfo_SourceInfoDefaultTypeInternal _ReorderInfo_SourceInfo_default_instance_;
++}  // namespace ShuffleInfo
++
++namespace ShuffleInfo {
++
++// Internal implementation detail -- do not call these.
++void protobuf_AddDesc_shuffleInfo_2eproto();
++void protobuf_InitDefaults_shuffleInfo_2eproto();
++
++// ===================================================================
++
++class ReorderInfo_BinaryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.BinaryInfo) */ {
++ public:
++  ReorderInfo_BinaryInfo();
++  virtual ~ReorderInfo_BinaryInfo();
++
++  ReorderInfo_BinaryInfo(const ReorderInfo_BinaryInfo& from);
++
++  inline ReorderInfo_BinaryInfo& operator=(const ReorderInfo_BinaryInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_BinaryInfo& default_instance();
++
++  static inline const ReorderInfo_BinaryInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_BinaryInfo*>(
++               &_ReorderInfo_BinaryInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo_BinaryInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_BinaryInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_BinaryInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_BinaryInfo& from);
++  void MergeFrom(const ReorderInfo_BinaryInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_BinaryInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  // accessors -------------------------------------------------------
++
++  // optional uint32 rand_obj_offset = 1;
++  bool has_rand_obj_offset() const;
++  void clear_rand_obj_offset();
++  static const int kRandObjOffsetFieldNumber = 1;
++  ::google::protobuf::uint32 rand_obj_offset() const;
++  void set_rand_obj_offset(::google::protobuf::uint32 value);
++
++  // optional uint32 main_addr_offset = 2;
++  bool has_main_addr_offset() const;
++  void clear_main_addr_offset();
++  static const int kMainAddrOffsetFieldNumber = 2;
++  ::google::protobuf::uint32 main_addr_offset() const;
++  void set_main_addr_offset(::google::protobuf::uint32 value);
++
++  // optional uint32 obj_sz = 3;
++  bool has_obj_sz() const;
++  void clear_obj_sz();
++  static const int kObjSzFieldNumber = 3;
++  ::google::protobuf::uint32 obj_sz() const;
++  void set_obj_sz(::google::protobuf::uint32 value);
++
++  // optional uint32 src_type = 4;
++  bool has_src_type() const;
++  void clear_src_type();
++  static const int kSrcTypeFieldNumber = 4;
++  ::google::protobuf::uint32 src_type() const;
++  void set_src_type(::google::protobuf::uint32 value);
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.BinaryInfo)
++ private:
++  void set_has_rand_obj_offset();
++  void clear_has_rand_obj_offset();
++  void set_has_main_addr_offset();
++  void clear_has_main_addr_offset();
++  void set_has_obj_sz();
++  void clear_has_obj_sz();
++  void set_has_src_type();
++  void clear_has_src_type();
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::uint32 rand_obj_offset_;
++  ::google::protobuf::uint32 main_addr_offset_;
++  ::google::protobuf::uint32 obj_sz_;
++  ::google::protobuf::uint32 src_type_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo_LayoutInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.LayoutInfo) */ {
++ public:
++  ReorderInfo_LayoutInfo();
++  virtual ~ReorderInfo_LayoutInfo();
++
++  ReorderInfo_LayoutInfo(const ReorderInfo_LayoutInfo& from);
++
++  inline ReorderInfo_LayoutInfo& operator=(const ReorderInfo_LayoutInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_LayoutInfo& default_instance();
++
++  static inline const ReorderInfo_LayoutInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_LayoutInfo*>(
++               &_ReorderInfo_LayoutInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo_LayoutInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_LayoutInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_LayoutInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_LayoutInfo& from);
++  void MergeFrom(const ReorderInfo_LayoutInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_LayoutInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  // accessors -------------------------------------------------------
++
++  // optional uint32 bb_size = 1;
++  bool has_bb_size() const;
++  void clear_bb_size();
++  static const int kBbSizeFieldNumber = 1;
++  ::google::protobuf::uint32 bb_size() const;
++  void set_bb_size(::google::protobuf::uint32 value);
++
++  // optional uint32 type = 2;
++  bool has_type() const;
++  void clear_type();
++  static const int kTypeFieldNumber = 2;
++  ::google::protobuf::uint32 type() const;
++  void set_type(::google::protobuf::uint32 value);
++
++  // optional uint32 num_fixups = 3;
++  bool has_num_fixups() const;
++  void clear_num_fixups();
++  static const int kNumFixupsFieldNumber = 3;
++  ::google::protobuf::uint32 num_fixups() const;
++  void set_num_fixups(::google::protobuf::uint32 value);
++
++  // optional bool bb_fallthrough = 4;
++  bool has_bb_fallthrough() const;
++  void clear_bb_fallthrough();
++  static const int kBbFallthroughFieldNumber = 4;
++  bool bb_fallthrough() const;
++  void set_bb_fallthrough(bool value);
++
++  // optional string section_name = 5;
++  bool has_section_name() const;
++  void clear_section_name();
++  static const int kSectionNameFieldNumber = 5;
++  const ::std::string& section_name() const;
++  void set_section_name(const ::std::string& value);
++  #if LANG_CXX11
++  void set_section_name(::std::string&& value);
++  #endif
++  void set_section_name(const char* value);
++  void set_section_name(const char* value, size_t size);
++  ::std::string* mutable_section_name();
++  ::std::string* release_section_name();
++  void set_allocated_section_name(::std::string* section_name);
++
++  // optional uint32 offset = 6;
++  bool has_offset() const;
++  void clear_offset();
++  static const int kOffsetFieldNumber = 6;
++  ::google::protobuf::uint32 offset() const;
++  void set_offset(::google::protobuf::uint32 value);
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.LayoutInfo)
++ private:
++  void set_has_bb_size();
++  void clear_has_bb_size();
++  void set_has_type();
++  void clear_has_type();
++  void set_has_num_fixups();
++  void clear_has_num_fixups();
++  void set_has_bb_fallthrough();
++  void clear_has_bb_fallthrough();
++  void set_has_section_name();
++  void clear_has_section_name();
++  void set_has_offset();
++  void clear_has_offset();
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::internal::ArenaStringPtr section_name_;
++  ::google::protobuf::uint32 bb_size_;
++  ::google::protobuf::uint32 type_;
++  ::google::protobuf::uint32 num_fixups_;
++  bool bb_fallthrough_;
++  ::google::protobuf::uint32 offset_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo_FixupInfo_FixupTuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple) */ {
++ public:
++  ReorderInfo_FixupInfo_FixupTuple();
++  virtual ~ReorderInfo_FixupInfo_FixupTuple();
++
++  ReorderInfo_FixupInfo_FixupTuple(const ReorderInfo_FixupInfo_FixupTuple& from);
++
++  inline ReorderInfo_FixupInfo_FixupTuple& operator=(const ReorderInfo_FixupInfo_FixupTuple& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_FixupInfo_FixupTuple& default_instance();
++
++  static inline const ReorderInfo_FixupInfo_FixupTuple* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_FixupInfo_FixupTuple*>(
++               &_ReorderInfo_FixupInfo_FixupTuple_default_instance_);
++  }
++
++  void Swap(ReorderInfo_FixupInfo_FixupTuple* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_FixupInfo_FixupTuple* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_FixupInfo_FixupTuple* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_FixupInfo_FixupTuple& from);
++  void MergeFrom(const ReorderInfo_FixupInfo_FixupTuple& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_FixupInfo_FixupTuple* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  // accessors -------------------------------------------------------
++
++  // required uint32 offset = 1;
++  bool has_offset() const;
++  void clear_offset();
++  static const int kOffsetFieldNumber = 1;
++  ::google::protobuf::uint32 offset() const;
++  void set_offset(::google::protobuf::uint32 value);
++
++  // required uint32 deref_sz = 2;
++  bool has_deref_sz() const;
++  void clear_deref_sz();
++  static const int kDerefSzFieldNumber = 2;
++  ::google::protobuf::uint32 deref_sz() const;
++  void set_deref_sz(::google::protobuf::uint32 value);
++
++  // required bool is_rela = 3;
++  bool has_is_rela() const;
++  void clear_is_rela();
++  static const int kIsRelaFieldNumber = 3;
++  bool is_rela() const;
++  void set_is_rela(bool value);
++
++  // optional uint32 type = 4;
++  bool has_type() const;
++  void clear_type();
++  static const int kTypeFieldNumber = 4;
++  ::google::protobuf::uint32 type() const;
++  void set_type(::google::protobuf::uint32 value);
++
++  // optional string section_name = 5;
++  bool has_section_name() const;
++  void clear_section_name();
++  static const int kSectionNameFieldNumber = 5;
++  const ::std::string& section_name() const;
++  void set_section_name(const ::std::string& value);
++  #if LANG_CXX11
++  void set_section_name(::std::string&& value);
++  #endif
++  void set_section_name(const char* value);
++  void set_section_name(const char* value, size_t size);
++  ::std::string* mutable_section_name();
++  ::std::string* release_section_name();
++  void set_allocated_section_name(::std::string* section_name);
++
++  // optional uint32 num_jt_entries = 6;
++  bool has_num_jt_entries() const;
++  void clear_num_jt_entries();
++  static const int kNumJtEntriesFieldNumber = 6;
++  ::google::protobuf::uint32 num_jt_entries() const;
++  void set_num_jt_entries(::google::protobuf::uint32 value);
++
++  // optional uint32 jt_entry_sz = 7;
++  bool has_jt_entry_sz() const;
++  void clear_jt_entry_sz();
++  static const int kJtEntrySzFieldNumber = 7;
++  ::google::protobuf::uint32 jt_entry_sz() const;
++  void set_jt_entry_sz(::google::protobuf::uint32 value);
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
++ private:
++  void set_has_offset();
++  void clear_has_offset();
++  void set_has_deref_sz();
++  void clear_has_deref_sz();
++  void set_has_is_rela();
++  void clear_has_is_rela();
++  void set_has_type();
++  void clear_has_type();
++  void set_has_section_name();
++  void clear_has_section_name();
++  void set_has_num_jt_entries();
++  void clear_has_num_jt_entries();
++  void set_has_jt_entry_sz();
++  void clear_has_jt_entry_sz();
++
++  // helper for ByteSizeLong()
++  size_t RequiredFieldsByteSizeFallback() const;
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::internal::ArenaStringPtr section_name_;
++  ::google::protobuf::uint32 offset_;
++  ::google::protobuf::uint32 deref_sz_;
++  bool is_rela_;
++  ::google::protobuf::uint32 type_;
++  ::google::protobuf::uint32 num_jt_entries_;
++  ::google::protobuf::uint32 jt_entry_sz_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo_FixupInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.FixupInfo) */ {
++ public:
++  ReorderInfo_FixupInfo();
++  virtual ~ReorderInfo_FixupInfo();
++
++  ReorderInfo_FixupInfo(const ReorderInfo_FixupInfo& from);
++
++  inline ReorderInfo_FixupInfo& operator=(const ReorderInfo_FixupInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_FixupInfo& default_instance();
++
++  static inline const ReorderInfo_FixupInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_FixupInfo*>(
++               &_ReorderInfo_FixupInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo_FixupInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_FixupInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_FixupInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_FixupInfo& from);
++  void MergeFrom(const ReorderInfo_FixupInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_FixupInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  typedef ReorderInfo_FixupInfo_FixupTuple FixupTuple;
++
++  // accessors -------------------------------------------------------
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++  int text_size() const;
++  void clear_text();
++  static const int kTextFieldNumber = 1;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& text(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_text(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_text();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_text();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      text() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++  int rodata_size() const;
++  void clear_rodata();
++  static const int kRodataFieldNumber = 2;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& rodata(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_rodata(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_rodata();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_rodata();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      rodata() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++  int data_size() const;
++  void clear_data();
++  static const int kDataFieldNumber = 3;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& data(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_data(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_data();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_data();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      data() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++  int datarel_size() const;
++  void clear_datarel();
++  static const int kDatarelFieldNumber = 4;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& datarel(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_datarel(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_datarel();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_datarel();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      datarel() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++  int initarray_size() const;
++  void clear_initarray();
++  static const int kInitarrayFieldNumber = 5;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& initarray(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_initarray(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_initarray();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++      mutable_initarray();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++      initarray() const;
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.FixupInfo)
++ private:
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > text_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > rodata_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > data_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > datarel_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > initarray_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo_SourceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.SourceInfo) */ {
++ public:
++  ReorderInfo_SourceInfo();
++  virtual ~ReorderInfo_SourceInfo();
++
++  ReorderInfo_SourceInfo(const ReorderInfo_SourceInfo& from);
++
++  inline ReorderInfo_SourceInfo& operator=(const ReorderInfo_SourceInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo_SourceInfo& default_instance();
++
++  static inline const ReorderInfo_SourceInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo_SourceInfo*>(
++               &_ReorderInfo_SourceInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo_SourceInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo_SourceInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo_SourceInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo_SourceInfo& from);
++  void MergeFrom(const ReorderInfo_SourceInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo_SourceInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  // accessors -------------------------------------------------------
++
++  // repeated uint32 src_type = 1;
++  int src_type_size() const;
++  void clear_src_type();
++  static const int kSrcTypeFieldNumber = 1;
++  ::google::protobuf::uint32 src_type(int index) const;
++  void set_src_type(int index, ::google::protobuf::uint32 value);
++  void add_src_type(::google::protobuf::uint32 value);
++  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
++      src_type() const;
++  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
++      mutable_src_type();
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.SourceInfo)
++ private:
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > src_type_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// -------------------------------------------------------------------
++
++class ReorderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo) */ {
++ public:
++  ReorderInfo();
++  virtual ~ReorderInfo();
++
++  ReorderInfo(const ReorderInfo& from);
++
++  inline ReorderInfo& operator=(const ReorderInfo& from) {
++    CopyFrom(from);
++    return *this;
++  }
++
++  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
++    return _internal_metadata_.unknown_fields();
++  }
++
++  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
++    return _internal_metadata_.mutable_unknown_fields();
++  }
++
++  static const ::google::protobuf::Descriptor* descriptor();
++  static const ReorderInfo& default_instance();
++
++  static inline const ReorderInfo* internal_default_instance() {
++    return reinterpret_cast<const ReorderInfo*>(
++               &_ReorderInfo_default_instance_);
++  }
++
++  void Swap(ReorderInfo* other);
++
++  // implements Message ----------------------------------------------
++
++  inline ReorderInfo* New() const PROTOBUF_FINAL { return New(NULL); }
++
++  ReorderInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
++  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
++  void CopyFrom(const ReorderInfo& from);
++  void MergeFrom(const ReorderInfo& from);
++  void Clear() PROTOBUF_FINAL;
++  bool IsInitialized() const PROTOBUF_FINAL;
++
++  size_t ByteSizeLong() const PROTOBUF_FINAL;
++  bool MergePartialFromCodedStream(
++      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
++  void SerializeWithCachedSizes(
++      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
++      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
++  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
++      const PROTOBUF_FINAL {
++    return InternalSerializeWithCachedSizesToArray(false, output);
++  }
++  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
++  private:
++  void SharedCtor();
++  void SharedDtor();
++  void SetCachedSize(int size) const PROTOBUF_FINAL;
++  void InternalSwap(ReorderInfo* other);
++  private:
++  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
++    return NULL;
++  }
++  inline void* MaybeArenaPtr() const {
++    return NULL;
++  }
++  public:
++
++  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
++
++  // nested types ----------------------------------------------------
++
++  typedef ReorderInfo_BinaryInfo BinaryInfo;
++  typedef ReorderInfo_LayoutInfo LayoutInfo;
++  typedef ReorderInfo_FixupInfo FixupInfo;
++  typedef ReorderInfo_SourceInfo SourceInfo;
++
++  // accessors -------------------------------------------------------
++
++  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++  bool has_bin() const;
++  void clear_bin();
++  static const int kBinFieldNumber = 1;
++  const ::ShuffleInfo::ReorderInfo_BinaryInfo& bin() const;
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* mutable_bin();
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* release_bin();
++  void set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin);
++
++  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++  int layout_size() const;
++  void clear_layout();
++  static const int kLayoutFieldNumber = 2;
++  const ::ShuffleInfo::ReorderInfo_LayoutInfo& layout(int index) const;
++  ::ShuffleInfo::ReorderInfo_LayoutInfo* mutable_layout(int index);
++  ::ShuffleInfo::ReorderInfo_LayoutInfo* add_layout();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
++      mutable_layout();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
++      layout() const;
++
++  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++  int fixup_size() const;
++  void clear_fixup();
++  static const int kFixupFieldNumber = 3;
++  const ::ShuffleInfo::ReorderInfo_FixupInfo& fixup(int index) const;
++  ::ShuffleInfo::ReorderInfo_FixupInfo* mutable_fixup(int index);
++  ::ShuffleInfo::ReorderInfo_FixupInfo* add_fixup();
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
++      mutable_fixup();
++  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
++      fixup() const;
++
++  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++  bool has_source() const;
++  void clear_source();
++  static const int kSourceFieldNumber = 4;
++  const ::ShuffleInfo::ReorderInfo_SourceInfo& source() const;
++  ::ShuffleInfo::ReorderInfo_SourceInfo* mutable_source();
++  ::ShuffleInfo::ReorderInfo_SourceInfo* release_source();
++  void set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source);
++
++  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo)
++ private:
++  void set_has_bin();
++  void clear_has_bin();
++  void set_has_source();
++  void clear_has_source();
++
++  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
++  ::google::protobuf::internal::HasBits<1> _has_bits_;
++  mutable int _cached_size_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo > layout_;
++  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo > fixup_;
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* bin_;
++  ::ShuffleInfo::ReorderInfo_SourceInfo* source_;
++  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
++  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
++  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
++  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
++
++};
++// ===================================================================
++
++
++// ===================================================================
++
++#if !PROTOBUF_INLINE_NOT_IN_HEADERS
++// ReorderInfo_BinaryInfo
++
++// optional uint32 rand_obj_offset = 1;
++inline bool ReorderInfo_BinaryInfo::has_rand_obj_offset() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++inline void ReorderInfo_BinaryInfo::set_has_rand_obj_offset() {
++  _has_bits_[0] |= 0x00000001u;
++}
++inline void ReorderInfo_BinaryInfo::clear_has_rand_obj_offset() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++inline void ReorderInfo_BinaryInfo::clear_rand_obj_offset() {
++  rand_obj_offset_ = 0u;
++  clear_has_rand_obj_offset();
++}
++inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::rand_obj_offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
++  return rand_obj_offset_;
++}
++inline void ReorderInfo_BinaryInfo::set_rand_obj_offset(::google::protobuf::uint32 value) {
++  set_has_rand_obj_offset();
++  rand_obj_offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
++}
++
++// optional uint32 main_addr_offset = 2;
++inline bool ReorderInfo_BinaryInfo::has_main_addr_offset() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++inline void ReorderInfo_BinaryInfo::set_has_main_addr_offset() {
++  _has_bits_[0] |= 0x00000002u;
++}
++inline void ReorderInfo_BinaryInfo::clear_has_main_addr_offset() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++inline void ReorderInfo_BinaryInfo::clear_main_addr_offset() {
++  main_addr_offset_ = 0u;
++  clear_has_main_addr_offset();
++}
++inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::main_addr_offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
++  return main_addr_offset_;
++}
++inline void ReorderInfo_BinaryInfo::set_main_addr_offset(::google::protobuf::uint32 value) {
++  set_has_main_addr_offset();
++  main_addr_offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
++}
++
++// optional uint32 obj_sz = 3;
++inline bool ReorderInfo_BinaryInfo::has_obj_sz() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++inline void ReorderInfo_BinaryInfo::set_has_obj_sz() {
++  _has_bits_[0] |= 0x00000004u;
++}
++inline void ReorderInfo_BinaryInfo::clear_has_obj_sz() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++inline void ReorderInfo_BinaryInfo::clear_obj_sz() {
++  obj_sz_ = 0u;
++  clear_has_obj_sz();
++}
++inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::obj_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
++  return obj_sz_;
++}
++inline void ReorderInfo_BinaryInfo::set_obj_sz(::google::protobuf::uint32 value) {
++  set_has_obj_sz();
++  obj_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
++}
++
++// optional uint32 src_type = 4;
++inline bool ReorderInfo_BinaryInfo::has_src_type() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++inline void ReorderInfo_BinaryInfo::set_has_src_type() {
++  _has_bits_[0] |= 0x00000008u;
++}
++inline void ReorderInfo_BinaryInfo::clear_has_src_type() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++inline void ReorderInfo_BinaryInfo::clear_src_type() {
++  src_type_ = 0u;
++  clear_has_src_type();
++}
++inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::src_type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
++  return src_type_;
++}
++inline void ReorderInfo_BinaryInfo::set_src_type(::google::protobuf::uint32 value) {
++  set_has_src_type();
++  src_type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo_LayoutInfo
++
++// optional uint32 bb_size = 1;
++inline bool ReorderInfo_LayoutInfo::has_bb_size() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_bb_size() {
++  _has_bits_[0] |= 0x00000002u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_bb_size() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++inline void ReorderInfo_LayoutInfo::clear_bb_size() {
++  bb_size_ = 0u;
++  clear_has_bb_size();
++}
++inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::bb_size() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
++  return bb_size_;
++}
++inline void ReorderInfo_LayoutInfo::set_bb_size(::google::protobuf::uint32 value) {
++  set_has_bb_size();
++  bb_size_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
++}
++
++// optional uint32 type = 2;
++inline bool ReorderInfo_LayoutInfo::has_type() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_type() {
++  _has_bits_[0] |= 0x00000004u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_type() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++inline void ReorderInfo_LayoutInfo::clear_type() {
++  type_ = 0u;
++  clear_has_type();
++}
++inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.type)
++  return type_;
++}
++inline void ReorderInfo_LayoutInfo::set_type(::google::protobuf::uint32 value) {
++  set_has_type();
++  type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.type)
++}
++
++// optional uint32 num_fixups = 3;
++inline bool ReorderInfo_LayoutInfo::has_num_fixups() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_num_fixups() {
++  _has_bits_[0] |= 0x00000008u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_num_fixups() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++inline void ReorderInfo_LayoutInfo::clear_num_fixups() {
++  num_fixups_ = 0u;
++  clear_has_num_fixups();
++}
++inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::num_fixups() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
++  return num_fixups_;
++}
++inline void ReorderInfo_LayoutInfo::set_num_fixups(::google::protobuf::uint32 value) {
++  set_has_num_fixups();
++  num_fixups_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
++}
++
++// optional bool bb_fallthrough = 4;
++inline bool ReorderInfo_LayoutInfo::has_bb_fallthrough() const {
++  return (_has_bits_[0] & 0x00000010u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_bb_fallthrough() {
++  _has_bits_[0] |= 0x00000010u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_bb_fallthrough() {
++  _has_bits_[0] &= ~0x00000010u;
++}
++inline void ReorderInfo_LayoutInfo::clear_bb_fallthrough() {
++  bb_fallthrough_ = false;
++  clear_has_bb_fallthrough();
++}
++inline bool ReorderInfo_LayoutInfo::bb_fallthrough() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
++  return bb_fallthrough_;
++}
++inline void ReorderInfo_LayoutInfo::set_bb_fallthrough(bool value) {
++  set_has_bb_fallthrough();
++  bb_fallthrough_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
++}
++
++// optional string section_name = 5;
++inline bool ReorderInfo_LayoutInfo::has_section_name() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_section_name() {
++  _has_bits_[0] |= 0x00000001u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_section_name() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++inline void ReorderInfo_LayoutInfo::clear_section_name() {
++  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  clear_has_section_name();
++}
++inline const ::std::string& ReorderInfo_LayoutInfo::section_name() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  return section_name_.GetNoArena();
++}
++inline void ReorderInfo_LayoutInfo::set_section_name(const ::std::string& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++#if LANG_CXX11
++inline void ReorderInfo_LayoutInfo::set_section_name(::std::string&& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(
++    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
++  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++#endif
++inline void ReorderInfo_LayoutInfo::set_section_name(const char* value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
++  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++inline void ReorderInfo_LayoutInfo::set_section_name(const char* value, size_t size) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
++      ::std::string(reinterpret_cast<const char*>(value), size));
++  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++inline ::std::string* ReorderInfo_LayoutInfo::mutable_section_name() {
++  set_has_section_name();
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++inline ::std::string* ReorderInfo_LayoutInfo::release_section_name() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++  clear_has_section_name();
++  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++inline void ReorderInfo_LayoutInfo::set_allocated_section_name(::std::string* section_name) {
++  if (section_name != NULL) {
++    set_has_section_name();
++  } else {
++    clear_has_section_name();
++  }
++  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
++}
++
++// optional uint32 offset = 6;
++inline bool ReorderInfo_LayoutInfo::has_offset() const {
++  return (_has_bits_[0] & 0x00000020u) != 0;
++}
++inline void ReorderInfo_LayoutInfo::set_has_offset() {
++  _has_bits_[0] |= 0x00000020u;
++}
++inline void ReorderInfo_LayoutInfo::clear_has_offset() {
++  _has_bits_[0] &= ~0x00000020u;
++}
++inline void ReorderInfo_LayoutInfo::clear_offset() {
++  offset_ = 0u;
++  clear_has_offset();
++}
++inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
++  return offset_;
++}
++inline void ReorderInfo_LayoutInfo::set_offset(::google::protobuf::uint32 value) {
++  set_has_offset();
++  offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo_FixupInfo_FixupTuple
++
++// required uint32 offset = 1;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_offset() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_offset() {
++  _has_bits_[0] |= 0x00000002u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_offset() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_offset() {
++  offset_ = 0u;
++  clear_has_offset();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::offset() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
++  return offset_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_offset(::google::protobuf::uint32 value) {
++  set_has_offset();
++  offset_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
++}
++
++// required uint32 deref_sz = 2;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_deref_sz() const {
++  return (_has_bits_[0] & 0x00000004u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_deref_sz() {
++  _has_bits_[0] |= 0x00000004u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_deref_sz() {
++  _has_bits_[0] &= ~0x00000004u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_deref_sz() {
++  deref_sz_ = 0u;
++  clear_has_deref_sz();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::deref_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
++  return deref_sz_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_deref_sz(::google::protobuf::uint32 value) {
++  set_has_deref_sz();
++  deref_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
++}
++
++// required bool is_rela = 3;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_is_rela() const {
++  return (_has_bits_[0] & 0x00000008u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_is_rela() {
++  _has_bits_[0] |= 0x00000008u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_is_rela() {
++  _has_bits_[0] &= ~0x00000008u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_is_rela() {
++  is_rela_ = false;
++  clear_has_is_rela();
++}
++inline bool ReorderInfo_FixupInfo_FixupTuple::is_rela() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
++  return is_rela_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_is_rela(bool value) {
++  set_has_is_rela();
++  is_rela_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
++}
++
++// optional uint32 type = 4;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_type() const {
++  return (_has_bits_[0] & 0x00000010u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_type() {
++  _has_bits_[0] |= 0x00000010u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_type() {
++  _has_bits_[0] &= ~0x00000010u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_type() {
++  type_ = 0u;
++  clear_has_type();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::type() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
++  return type_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_type(::google::protobuf::uint32 value) {
++  set_has_type();
++  type_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
++}
++
++// optional string section_name = 5;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_section_name() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_section_name() {
++  _has_bits_[0] |= 0x00000001u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_section_name() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_section_name() {
++  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++  clear_has_section_name();
++}
++inline const ::std::string& ReorderInfo_FixupInfo_FixupTuple::section_name() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  return section_name_.GetNoArena();
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const ::std::string& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++#if LANG_CXX11
++inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(::std::string&& value) {
++  set_has_section_name();
++  section_name_.SetNoArena(
++    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
++  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++#endif
++inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
++  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value, size_t size) {
++  set_has_section_name();
++  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
++      ::std::string(reinterpret_cast<const char*>(value), size));
++  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++inline ::std::string* ReorderInfo_FixupInfo_FixupTuple::mutable_section_name() {
++  set_has_section_name();
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++inline ::std::string* ReorderInfo_FixupInfo_FixupTuple::release_section_name() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++  clear_has_section_name();
++  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_allocated_section_name(::std::string* section_name) {
++  if (section_name != NULL) {
++    set_has_section_name();
++  } else {
++    clear_has_section_name();
++  }
++  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
++}
++
++// optional uint32 num_jt_entries = 6;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_num_jt_entries() const {
++  return (_has_bits_[0] & 0x00000020u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_num_jt_entries() {
++  _has_bits_[0] |= 0x00000020u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_num_jt_entries() {
++  _has_bits_[0] &= ~0x00000020u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_num_jt_entries() {
++  num_jt_entries_ = 0u;
++  clear_has_num_jt_entries();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::num_jt_entries() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
++  return num_jt_entries_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_num_jt_entries(::google::protobuf::uint32 value) {
++  set_has_num_jt_entries();
++  num_jt_entries_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
++}
++
++// optional uint32 jt_entry_sz = 7;
++inline bool ReorderInfo_FixupInfo_FixupTuple::has_jt_entry_sz() const {
++  return (_has_bits_[0] & 0x00000040u) != 0;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_has_jt_entry_sz() {
++  _has_bits_[0] |= 0x00000040u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_jt_entry_sz() {
++  _has_bits_[0] &= ~0x00000040u;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::clear_jt_entry_sz() {
++  jt_entry_sz_ = 0u;
++  clear_has_jt_entry_sz();
++}
++inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::jt_entry_sz() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
++  return jt_entry_sz_;
++}
++inline void ReorderInfo_FixupInfo_FixupTuple::set_jt_entry_sz(::google::protobuf::uint32 value) {
++  set_has_jt_entry_sz();
++  jt_entry_sz_ = value;
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo_FixupInfo
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
++inline int ReorderInfo_FixupInfo::text_size() const {
++  return text_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_text() {
++  text_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::text(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_text(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_text() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_text() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return &text_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::text() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
++  return text_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
++inline int ReorderInfo_FixupInfo::rodata_size() const {
++  return rodata_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_rodata() {
++  rodata_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::rodata(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_rodata(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_rodata() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_rodata() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return &rodata_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::rodata() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
++  return rodata_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
++inline int ReorderInfo_FixupInfo::data_size() const {
++  return data_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_data() {
++  data_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::data(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_data(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_data() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_data() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return &data_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::data() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
++  return data_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
++inline int ReorderInfo_FixupInfo::datarel_size() const {
++  return datarel_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_datarel() {
++  datarel_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::datarel(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_datarel(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_datarel() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_datarel() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return &datarel_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::datarel() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
++  return datarel_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
++inline int ReorderInfo_FixupInfo::initarray_size() const {
++  return initarray_.size();
++}
++inline void ReorderInfo_FixupInfo::clear_initarray() {
++  initarray_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::initarray(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_initarray(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_initarray() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
++ReorderInfo_FixupInfo::mutable_initarray() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return &initarray_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
++ReorderInfo_FixupInfo::initarray() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
++  return initarray_;
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo_SourceInfo
++
++// repeated uint32 src_type = 1;
++inline int ReorderInfo_SourceInfo::src_type_size() const {
++  return src_type_.size();
++}
++inline void ReorderInfo_SourceInfo::clear_src_type() {
++  src_type_.Clear();
++}
++inline ::google::protobuf::uint32 ReorderInfo_SourceInfo::src_type(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return src_type_.Get(index);
++}
++inline void ReorderInfo_SourceInfo::set_src_type(int index, ::google::protobuf::uint32 value) {
++  src_type_.Set(index, value);
++  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++}
++inline void ReorderInfo_SourceInfo::add_src_type(::google::protobuf::uint32 value) {
++  src_type_.Add(value);
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++}
++inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
++ReorderInfo_SourceInfo::src_type() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return src_type_;
++}
++inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
++ReorderInfo_SourceInfo::mutable_src_type() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
++  return &src_type_;
++}
++
++// -------------------------------------------------------------------
++
++// ReorderInfo
++
++// optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
++inline bool ReorderInfo::has_bin() const {
++  return (_has_bits_[0] & 0x00000001u) != 0;
++}
++inline void ReorderInfo::set_has_bin() {
++  _has_bits_[0] |= 0x00000001u;
++}
++inline void ReorderInfo::clear_has_bin() {
++  _has_bits_[0] &= ~0x00000001u;
++}
++inline void ReorderInfo::clear_bin() {
++  if (bin_ != NULL) bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
++  clear_has_bin();
++}
++inline const ::ShuffleInfo::ReorderInfo_BinaryInfo& ReorderInfo::bin() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.bin)
++  return bin_ != NULL ? *bin_
++                         : *::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance();
++}
++inline ::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::mutable_bin() {
++  set_has_bin();
++  if (bin_ == NULL) {
++    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo;
++  }
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.bin)
++  return bin_;
++}
++inline ::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::release_bin() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.bin)
++  clear_has_bin();
++  ::ShuffleInfo::ReorderInfo_BinaryInfo* temp = bin_;
++  bin_ = NULL;
++  return temp;
++}
++inline void ReorderInfo::set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin) {
++  delete bin_;
++  bin_ = bin;
++  if (bin) {
++    set_has_bin();
++  } else {
++    clear_has_bin();
++  }
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.bin)
++}
++
++// repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
++inline int ReorderInfo::layout_size() const {
++  return layout_.size();
++}
++inline void ReorderInfo::clear_layout() {
++  layout_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_LayoutInfo& ReorderInfo::layout(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::mutable_layout(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::add_layout() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.layout)
++  return layout_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
++ReorderInfo::mutable_layout() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.layout)
++  return &layout_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
++ReorderInfo::layout() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.layout)
++  return layout_;
++}
++
++// repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
++inline int ReorderInfo::fixup_size() const {
++  return fixup_.size();
++}
++inline void ReorderInfo::clear_fixup() {
++  fixup_.Clear();
++}
++inline const ::ShuffleInfo::ReorderInfo_FixupInfo& ReorderInfo::fixup(int index) const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Get(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::mutable_fixup(int index) {
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Mutable(index);
++}
++inline ::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::add_fixup() {
++  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_.Add();
++}
++inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
++ReorderInfo::mutable_fixup() {
++  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.fixup)
++  return &fixup_;
++}
++inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
++ReorderInfo::fixup() const {
++  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.fixup)
++  return fixup_;
++}
++
++// optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
++inline bool ReorderInfo::has_source() const {
++  return (_has_bits_[0] & 0x00000002u) != 0;
++}
++inline void ReorderInfo::set_has_source() {
++  _has_bits_[0] |= 0x00000002u;
++}
++inline void ReorderInfo::clear_has_source() {
++  _has_bits_[0] &= ~0x00000002u;
++}
++inline void ReorderInfo::clear_source() {
++  if (source_ != NULL) source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
++  clear_has_source();
++}
++inline const ::ShuffleInfo::ReorderInfo_SourceInfo& ReorderInfo::source() const {
++  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.source)
++  return source_ != NULL ? *source_
++                         : *::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance();
++}
++inline ::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::mutable_source() {
++  set_has_source();
++  if (source_ == NULL) {
++    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo;
++  }
++  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.source)
++  return source_;
++}
++inline ::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::release_source() {
++  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.source)
++  clear_has_source();
++  ::ShuffleInfo::ReorderInfo_SourceInfo* temp = source_;
++  source_ = NULL;
++  return temp;
++}
++inline void ReorderInfo::set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source) {
++  delete source_;
++  source_ = source;
++  if (source) {
++    set_has_source();
++  } else {
++    clear_has_source();
++  }
++  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.source)
++}
++
++#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
++// -------------------------------------------------------------------
++
++// -------------------------------------------------------------------
++
++// -------------------------------------------------------------------
++
++// -------------------------------------------------------------------
++
++// -------------------------------------------------------------------
++
++
++// @@protoc_insertion_point(namespace_scope)
++
++
++}  // namespace ShuffleInfo
++
++// @@protoc_insertion_point(global_scope)
++
++#endif  // PROTOBUF_shuffleInfo_2eproto__INCLUDED
+diff --git a/shuffleInfo.proto b/shuffleInfo.proto
+new file mode 100644
+index 0000000..802826d
+--- /dev/null
++++ b/shuffleInfo.proto
+@@ -0,0 +1,63 @@
++// This file defines the buffer protocol of the shuffleInfo for reordering.
++// The following command automatically generates both the declaration 
++// and the implementation of shuffleInfo class.
++//    $ protoc --cpp_out=$DST_DIR shuffleInfo.proto       # C++
++//    $ protoc --python_out=$DST_DIR shuffleInfo.proto    # Python
++// The following command generates the shared object.
++//    $ c++ -fPIC -shared shuffleInfo.pb.cc -o shuffleInfo.so `pkg-config --cflags --libs protobuf`
++// Revised: 4/22/18
++
++syntax = "proto2";
++package ShuffleInfo;
++
++message ReorderInfo {
++  // Binary info from ld or ld.gold; reordering range and main offset
++  message BinaryInfo {
++    optional uint32 rand_obj_offset = 1;  // PLACEHOLDER FOR LINKER
++    optional uint32 main_addr_offset = 2; // PLACEHOLDER FOR LINKER
++    optional uint32 obj_sz = 3;           // Verification purpose
++    optional uint32 src_type = 4;         // See the SourceInfo message
++  }
++
++  // Code layout Info (.text) from LLVM
++  // Embeded info ([#func|#fixup]/obj, [#bbk|#fixup]/func, objSz/ea, funcSz/ea)
++  message LayoutInfo {
++    optional uint32 bb_size = 1;          // UPDATE AT LINKTIME WITH OBJ ALIGNMENTs
++                                          // All alignments between fn/bbl are included here
++    optional uint32 type = 2;             // Represents the end of [OBJ|FUN|BBL]
++    optional uint32 num_fixups = 3;
++    optional bool bb_fallthrough = 4;
++    optional string section_name = 5;     // section identifier for c++ mutiple sections
++    optional uint32 offset = 6; // update at linking when combining sections
++    optional uint32 padding_size = 7;
++  }
++
++  // Fixup info in ELF from LLVM
++  message FixupInfo {
++    message FixupTuple {
++      required uint32 offset = 1;         // UPDATE AT LINKTIME WHEN COMBINING SECTIONS
++      required uint32 deref_sz = 2;
++      required bool   is_rela = 3;
++      optional uint32 type = 4;           // c2c, c2d, d2c, d2d = (0-3)
++      optional string section_name = 5;   // section identifier for c++ mutiple sections
++                                          // fixup has a jump table (.rodata) for pic/pie use
++      optional uint32 num_jt_entries = 6; // number of the jump table entries
++      optional uint32 jt_entry_sz = 7;    // size of each jump table entry in byte
++    }
++    repeated FixupTuple text = 1;
++    repeated FixupTuple rodata = 2;
++    repeated FixupTuple data = 3;
++    repeated FixupTuple datarel = 4;
++    repeated FixupTuple initarray = 5;
++  }
++  
++  // Source info [generalSource(=0) | hasInlineAssembly(=1) | standaloneAssembly(=2)]
++  message SourceInfo {
++    repeated uint32 src_type = 1;         // the src_type placeholder for linker
++  }
++
++  optional BinaryInfo bin = 1;
++  repeated LayoutInfo layout = 2;
++  repeated FixupInfo fixup = 3;
++  optional SourceInfo source = 4;
++}
+diff --git a/struc-symbol.h b/struc-symbol.h
+index c016848..44957f2 100644
+--- a/struc-symbol.h
++++ b/struc-symbol.h
+@@ -104,6 +104,16 @@ struct symbol
+ #ifdef TARGET_SYMBOL_FIELDS
+   TARGET_SYMBOL_FIELDS
+ #endif
++
++// binpang add
++// jump table related information, we only add the related information in i386/x86_64 architecture
++#if defined(__i386__) || defined(__x86_64__)
++   struct jump_table{
++      unsigned int table_size; // the jump table size(number of jump table entry)
++      unsigned int entry_size; // the jump table entry size
++   } jmp_table;
++#endif
++
+ };
+ 
+ /* A pointer in the symbol may point to either a complete symbol
+@@ -144,6 +154,12 @@ struct local_symbol
+ #ifdef TC_LOCAL_SYMFIELD_TYPE
+   TC_LOCAL_SYMFIELD_TYPE lsy_tc;
+ #endif
++
++// binpang add
++// jump table related information, we only add the related information in i386/x86_64 architecture
++#if defined(__i386__) || defined(__x86_64__)
++struct jump_table jmp_table;
++#endif
+ };
+ 
+ #define local_symbol_converted_p(l) ((l)->lsy_section == reg_section)
+diff --git a/symbols.c b/symbols.c
+index d16e804..863d60a 100644
+--- a/symbols.c
++++ b/symbols.c
+@@ -2213,6 +2213,38 @@ S_GET_NAME (symbolS *s)
+   return s->bsym->name;
+ }
+ 
++/*
++ * binpang, add
++ * get and set jump table related element
++ */
++unsigned S_GET_JMPTBL_SIZE(symbolS *s)
++{
++  if (LOCAL_SYMBOL_CHECK (s))
++    return ((struct local_symbol *) s)->jmp_table.table_size;
++  return s->jmp_table.table_size;
++}
++
++unsigned S_GET_JMPTBL_ENTRY_SZ(symbolS *s)
++{
++  if (LOCAL_SYMBOL_CHECK (s))
++    return ((struct local_symbol *) s)->jmp_table.entry_size;
++  return s->jmp_table.entry_size;
++}
++
++void S_SET_JMPTBL_SIZE(symbolS *s, unsigned size){
++  if (LOCAL_SYMBOL_CHECK (s))
++    ((struct local_symbol *) s)->jmp_table.table_size = size;
++  else
++    s->jmp_table.table_size = size;
++}
++
++void S_SET_JMPTBL_ENTRY_SZ(symbolS *s, unsigned size){
++  if (LOCAL_SYMBOL_CHECK (s))
++    ((struct local_symbol *) s)->jmp_table.entry_size = size;
++  else
++    s->jmp_table.entry_size = size;
++}
++
+ segT
+ S_GET_SEGMENT (symbolS *s)
+ {
+diff --git a/symbols.h b/symbols.h
+index cb316b5..5b125e2 100644
+--- a/symbols.h
++++ b/symbols.h
+@@ -84,6 +84,15 @@ char *fb_label_name (long n, long augend);
+ 
+ extern void copy_symbol_attributes (symbolS *, symbolS *);
+ 
++/*
++ * binpang, add
++ * get and set jump table struct
++ */
++extern unsigned S_GET_JMPTBL_SIZE(symbolS*);
++extern unsigned S_GET_JMPTBL_ENTRY_SZ(symbolS*);
++extern void S_SET_JMPTBL_SIZE(symbolS*, unsigned);
++extern void S_SET_JMPTBL_ENTRY_SZ(symbolS*, unsigned);
++
+ /* Get and set the values of symbols.  These used to be macros.  */
+ extern valueT S_GET_VALUE (symbolS *);
+ extern void S_SET_VALUE (symbolS *, valueT);
+diff --git a/write.c b/write.c
+index 2869660..9ccd622 100644
+--- a/write.c
++++ b/write.c
+@@ -27,6 +27,10 @@
+ #include "dwarf2dbg.h"
+ #include "compress-debug.h"
+ 
++#if defined(__i386__) || defined(__x86_64__)
++#include "bbInfoHandle.h"
++#endif
++
+ #ifndef TC_FORCE_RELOCATION
+ #define TC_FORCE_RELOCATION(FIX)		\
+   (generic_force_reloc (FIX))
+@@ -549,6 +553,84 @@ relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx)
+     info->changed = 1;
+ }
+ 
++/*
++ *  binpang, add.
++ *  update basic block size.
++ */
++#if defined(__i386__) || defined(__x86_64__)
++static void update_basic_block_size(bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx ATTRIBUTE_UNUSED)
++{
++  const char* sec_name = sec->name;
++  // we only handle the basic block in .text.xxx section
++  char* tmp_pointer = NULL;
++  tmp_pointer = strstr(sec_name, ".text");
++  if (!(tmp_pointer && tmp_pointer == sec_name))
++    return;
++  segment_info_type *seginfo = seg_info (sec);
++  struct frag *seg_frag_root = seginfo->frchainP->frch_root;
++  struct frag *fragP;
++  bbinfo_mbb *mbbP;
++  
++  for (fragP = seg_frag_root; fragP;
++    fragP = fragP->fr_next){
++    fragP->parent = sec;
++    // update the basic block size
++    mbbP = fragP->last_bb;
++    
++    if (mbbP && fragP->last_bb_added_size){
++      mbbP->size += fragP->last_bb_added_size;
++    }
++    
++   }
++}
++
++static void update_basic_block_size_from_frag(bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx ATTRIBUTE_UNUSED)
++{
++  const char* sec_name = sec->name;
++  // we only handle the basic block in .text.xxx section
++  char* tmp_pointer = NULL;
++  tmp_pointer = strstr(sec_name, ".text");
++  if (!(tmp_pointer && tmp_pointer == sec_name))
++    return;
++
++  segment_info_type *seginfo = seg_info (sec);
++  struct frag *seg_frag_root = seginfo->frchainP->frch_root;
++  struct frag *fragP;
++  bbinfo_mbb *mbbP;
++  struct frag *last_frag = NULL;
++  
++  for (fragP = seg_frag_root; fragP;
++    fragP = fragP->fr_next){
++    
++    mbbP = fragP->last_bb;
++    if (last_frag && last_frag->last_bb){
++      int frag_offset = fragP->fr_address - last_frag->last_bb->offset;
++   // update the basic block size according to the fragment offset
++      if (frag_offset > last_frag->last_bb->size){
++	last_frag->last_bb->size = frag_offset;}
++    }
++
++    if (mbbP)
++      last_frag = fragP;
++   }
++}
++// update basic block offset
++static void update_basic_block_offset(void){
++  for (bbinfo_mbb *cur_mbb = mbbs_list_head; cur_mbb;
++      		cur_mbb = cur_mbb->next)
++  {
++    if (!cur_mbb->parent_frag)
++    {
++      //as_warn(_("[bbInfo warning]: Basic block %d don't have parent fragment, its size %d"), cur_mbb->ID, cur_mbb->size);
++      continue;
++    }
++    cur_mbb->offset += cur_mbb->parent_frag->fr_address;
++    cur_mbb->sec = cur_mbb->parent_frag->parent;
++  }
++}
++#endif
++
++
+ static void
+ size_seg (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
+ {
+@@ -1149,6 +1231,52 @@ fix_segment (bfd *abfd ATTRIBUTE_UNUSED,
+   fixup_segment (seginfo->fix_root, sec);
+ }
+ 
++/*
++ * binpang, add. 
++ * collect fixup information before fixup resolved.
++ */
++static void 
++bbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,
++    	     asection *sec,
++	     void *xxx ATTRIBUTE_UNUSED)
++{
++
++  fixS *fixp;
++  segment_info_type *seginfo = seg_info (sec);
++
++  if (!seginfo->fix_root)
++    return;
++
++  char is_new_sec = bbinfo_is_collect_sec(sec);
++  
++  // we only collect .text, .rodata, .init_array, .data, .data.rel.ro sections
++  if (!is_new_sec)
++    return;
++  
++ /*
++  * TODO(binpang), add relocation information that .realoc directive defined
++  * which is stored in reloc_list.
++  *  may refer to what write_relocs fucntion does
++  */
++  for(fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
++  {
++    int offset = fixp->fx_frag->fr_address + fixp->fx_where; 
++   // bbinfo_fixup* tmp_fixp = bbinfo_init_fixup(fixups_list_head, fixups_list_tail);
++    bbinfo_fixup* tmp_fixp = bbinfo_init_insert_fixup(sec, offset);
++    tmp_fixp->sec = sec;
++    tmp_fixp->offset = offset;
++    tmp_fixp->is_rela = (unsigned char)fixp->fx_pcrel;
++    tmp_fixp->size = fixp->fx_size;
++    // FIXME. Here I only consider fixp->fx_addsy
++    symbolS* tmp_sym = fixp->fx_addsy;
++    if(tmp_sym){
++      tmp_fixp->table_size = S_GET_JMPTBL_SIZE(tmp_sym);
++      tmp_fixp->entry_size = S_GET_JMPTBL_ENTRY_SZ(tmp_sym);
++    }
++    tmp_fixp->is_new_section = 0;
++  }
++
++}
+ static void
+ install_reloc (asection *sec, arelent *reloc, fragS *fragp,
+ 	       const char *file, unsigned int line)
+@@ -1578,6 +1706,20 @@ write_contents (bfd *abfd ATTRIBUTE_UNUSED,
+   segment_info_type *seginfo = seg_info (sec);
+   addressT offset = 0;
+   fragS *f;
++  
++  /*
++   * binpang, add
++   * output the section .rand
++   */ 
++  if (!strcmp(sec->name, ".rand")){
++    unsigned result = bfd_set_section_contents(stdoutput, sec, bbinfo_shuffle_info_buf, 
++			(file_ptr) 0, (bfd_size_type) bbinfo_shuffle_info_buf_len);
++    
++  if(!result)
++    as_warn(_("can't write data into .rand"));
++
++  return;
++  }
+ 
+   /* Write out the frags.  */
+   if (seginfo == NULL
+@@ -1916,6 +2058,14 @@ write_object_file (void)
+ 	break;
+     }
+ 
++// binpang, add 
++// update basic block size and offset
++#if defined(__i386__) || defined(__x86_64__)
++  bfd_map_over_sections (stdoutput, update_basic_block_size, (void*)0);
++  update_basic_block_offset();
++  //bfd_map_over_sections (stdoutput, update_basic_block_size_from_frag, (void*)0);
++#endif
++
+   /* Note - Most ports will use the default value of
+      TC_FINALIZE_SYMS_BEFORE_SIZE_SEG, which 1.  This will force
+      local symbols to be resolved, removing their frag information.
+@@ -2040,6 +2190,12 @@ write_object_file (void)
+   }
+ #endif /* not WORKING_DOT_WORD  */
+ 
++  /*
++   * binpang, add
++   * collect all fixup
++   */
++  bfd_map_over_sections (stdoutput, bbinfo_update_fixp, (char *) 0);
++
+   /* Resolve symbol values.  This needs to be done before processing
+      the relocations.  */
+   if (symbol_rootP)
+@@ -2255,7 +2411,32 @@ write_object_file (void)
+       bfd_map_over_sections (stdoutput, compress_debug, (char *) 0);
+     }
+ 
++  /*
++   * binpang, add
++   * create .rand section
++   */
++  asection* rand_sec = bfd_make_section (stdoutput, ".rand");
++  bfd_set_section_flags(stdoutput, rand_sec, SEC_HAS_CONTENTS);
++  bbinfo_update_shuffle_info();
++  // BUG? why should at here specify size. But in write_contents fuction, it can't work.
++  rand_sec->size = bbinfo_shuffle_info_buf_len;
++
+   bfd_map_over_sections (stdoutput, write_contents, (char *) 0);
++
++// binpang, add. debug.
++//#if defined(__i386__) || defined(__x86_64__)
++//  int tmp_index = 0;
++//  printf("after relaxing....\n");
++//  for(bbinfo_mbb* cur_bb = mbbs_list_head; cur_bb; cur_bb = cur_bb->next)
++//    printf("basic block#%d: basic block offset %x, size %d, fall_through %d, its section name is %s\n", 
++//	tmp_index++, cur_bb->offset, cur_bb->size, cur_bb->fall_through, cur_bb->sec->name);
++//
++//  printf("fixup information\n");
++//  tmp_index = 0;
++//  for(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp; cur_fixp = cur_fixp->next)
++//    printf("fixup#%d: fixup offset %x, size %d, section %s, is rela %d, table size %d, entry size %d\n ", 
++//	tmp_index++, cur_fixp->offset, cur_fixp->size, cur_fixp->sec->name, cur_fixp->is_rela, cur_fixp->table_size, cur_fixp->entry_size);
++//#endif
+ }
+ 
+ #ifdef TC_GENERIC_RELAX_TABLE
+@@ -2407,6 +2588,14 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+   int region;
+   int ret;
+ 
++// binpang add
++// use last_frag to record the last fragS
++// handle the situation that before alignment fragS
++#if defined(__i386__) || defined(__x86_64__)
++struct frag *last_frag = NULL;
++bbinfo_mbb *frag_last_bb = NULL;
++#endif
++
+   /* In case md_estimate_size_before_relax() wants to make fixSs.  */
+   subseg_change (segment, 0);
+ 
+@@ -2423,10 +2612,28 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+       fragP->fr_address = address;
+       address += fragP->fr_fix;
+ 
++// binpang, add.
++#if defined(__i386__) || defined(__x86_64__)
++      frag_last_bb = NULL;
++      // may do many times relax pass. every time reset last_bb_added_size.
++      fragP->last_bb_added_size = fragP->last_bb_added_fix_size;
++      if (fragP->last_bb && fragP->last_bb->alignment)
++	fragP->last_bb->alignment = 0;
++#endif
++
+       switch (fragP->fr_type)
+ 	{
+ 	case rs_fill:
+-	  address += fragP->fr_offset * fragP->fr_var;
++	  {int addedBytes = fragP->fr_offset * fragP->fr_var;
++
++#if defined(__i386__) || defined(__x86_64__) 
++	  frag_last_bb = fragP->last_bb;
++	  if (frag_last_bb){
++	    fragP->last_bb_added_size += addedBytes;
++	  }
++#endif
++	  address += addedBytes;
++	}
+ 	  break;
+ 
+ 	case rs_align:
+@@ -2449,8 +2656,30 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 			      (unsigned long) offset, (long) fragP->fr_var);
+ 		offset -= (offset % fragP->fr_var);
+ 	      }
+-
+ 	    address += offset;
++	 
++// add the alignment bytes to the last basic block
++// TODO(binpang). Seperate the alignment fragment into a seperate basic block.
++#if defined(__i386__) || defined(__x86_64__)
++	    struct frag* tmp_frag = NULL;
++	      /*
++	       * FIXME. If the current frag has fix bytes, then append the alignment to the current frag.
++	       * Otherwise, append the alignment to the last frag.
++	       */
++	      if(fragP && fragP->fr_fix)
++	       	tmp_frag = fragP;
++	      else 
++		tmp_frag = last_frag;
++
++	      // make sure the tmp_frag contains basic block
++	      if (tmp_frag && tmp_frag->last_bb)
++	      {
++		tmp_frag->last_bb_added_size += offset;
++		tmp_frag->last_bb->alignment += offset;
++	        //printf("[bbInfo]: alignment add size %d, frag address %x\n", offset, fragP->fr_address);
++	      }
++	      
++#endif
+ 	    region += 1;
+ 	  }
+ 	  break;
+@@ -2470,7 +2699,18 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 	  if (fragP->fr_symbol)
+ 	    resolve_symbol_value (fragP->fr_symbol);
+ 
+-	  address += md_estimate_size_before_relax (fragP, segment);
++	  int added_bytes = md_estimate_size_before_relax (fragP, segment);
++	  address += added_bytes;
++
++	  //binpang, add. update the last basic block's size
++#if defined(__i386__) || defined(__x86_64__)
++	  frag_last_bb = fragP->last_bb;
++	  if (frag_last_bb && added_bytes)
++	  {
++	    fragP->last_bb_added_size += added_bytes;
++	  }
++#endif
++	  
+ 	  break;
+ 
+ #ifndef WORKING_DOT_WORD
+@@ -2497,6 +2737,11 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 	  BAD_CASE (fragP->fr_type);
+ 	  break;
+ 	}
++
++#if defined(__i386__) || defined(__x86_64__)
++        if (fragP->last_bb)
++	  last_frag = fragP;
++#endif
+     }
+ 
+   /* Do relax().  */
+@@ -2549,12 +2794,18 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+     if (max_iterations < frag_count)
+       max_iterations = frag_count;
+ 
++
+     ret = 0;
+     do
+       {
+ 	stretch = 0;
+ 	stretched = 0;
+ 
++// binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++   last_frag = NULL; 
++#endif
++
+ 	for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
+ 	  {
+ 	    offsetT growth = 0;
+@@ -2663,6 +2914,29 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 
+ 		  growth = newoff - oldoff;
+ 
++/* 
++ * binpang, add.
++ * update the fragment's last basic block size. Similar to up.
++ * TODO(binpang). maybe seperate the alignment fragment in code segment into a basic block.
++*/
++#if defined(__i386__) || defined(__x86_64__)
++		  struct frag* tmp_frag = NULL;
++		  if (fragP && fragP->fr_fix)
++		    tmp_frag = fragP;
++		  else
++		  {
++		    tmp_frag = last_frag;
++		  }
++		    // tmp_frag has basic block. exclude data fragment.
++		  if (tmp_frag && tmp_frag->last_bb)
++		    {
++		      tmp_frag->last_bb_added_size += growth;
++		      tmp_frag->last_bb->alignment += growth;
++		   // debug
++		   // printf("[bbInfo]: alignment add size %d, frag address is %x\n", growth, fragP->fr_address);
++		    }
++#endif
++
+ 		  /* If this align happens to follow a leb128 and
+ 		     we have determined that the leb128 is bouncing
+ 		     in size, then break the cycle by inserting an
+@@ -2801,6 +3075,7 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 		break;
+ 
+ 	      case rs_machine_dependent:
++		{
+ #ifdef md_relax_frag
+ 		growth = md_relax_frag (segment, fragP, stretch);
+ #else
+@@ -2809,6 +3084,19 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 		   TC_GENERIC_RELAX_TABLE.  */
+ 		growth = relax_frag (segment, fragP, stretch);
+ #endif /* TC_GENERIC_RELAX_TABLE  */
++#endif
++		
++		// binpang, add
++		// update the relaxed basic block size
++#if defined(__i386__) || defined(__x86_64__)
++		frag_last_bb = fragP->last_bb;
++		if (frag_last_bb && growth)
++		{
++		  fragP->last_bb_added_size += growth;
++		  // debug
++		  //printf("[bbInfo]: machine dependent add size %d, frag address is %x. Hello?\n", growth, fragP->fr_address);
++		}
++             }
+ #endif
+ 		break;
+ 
+@@ -2849,6 +3137,13 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
+ 		else
+ 		  rs_leb128_fudge = 0;
+ 	      }
++
++// binpang, add
++#if defined(__i386__) || defined(__x86_64__)
++	    if (fragP->last_bb)
++	      last_frag = fragP;
++#endif
++
+ 	  }
+ 
+ 	if (stretch == 0
diff --git a/read.c b/read.c
index cf1bdec..dfebe86 100644
--- a/read.c
+++ b/read.c
@@ -40,6 +40,10 @@
 #include "dw2gencfi.h"
 #include "wchar.h"
 
+#if defined(__i386__) || defined(__x86_64__)
+#include "bbInfoHandle.h" // binpang, add
+#endif
+
 #ifndef TC_START_LABEL
 #define TC_START_LABEL(STR, NUL_CHAR, NEXT_CHAR) (NEXT_CHAR == ':')
 #endif
@@ -534,6 +538,11 @@ pop_insert (const pseudo_typeS *table)
 #define cfi_pop_insert()	pop_insert(cfi_pseudo_table)
 #endif
 
+// binpang, add. Handle basic block related information
+#if !defined(bbInfo_pop_insert) && (defined(__i386__) || defined (__x86_64__))
+#define bbInfo_pop_insert()    pop_insert(bbInfo_pseudo_table)
+#endif
+
 static void
 pobegin (void)
 {
@@ -556,8 +565,16 @@ pobegin (void)
   pop_table_name = "cfi";
   pop_override_ok = 1;
   cfi_pop_insert ();
+
+// binpang, add.
+#if defined(__i386__) || defined(__x86_64__)
+  /* Now bbInfo ones. */
+  pop_table_name = "bbInfo";
+  bbInfo_pop_insert();
+#endif
+
 }
-
+
 #define HANDLE_CONDITIONAL_ASSEMBLY(num_read)				\
   if (ignore_input ())							\
     {									\
@@ -818,6 +835,13 @@ read_a_source_file (const char *name)
   int temp;
   pseudo_typeS *pop;
 
+// binpang, add. debug
+#ifdef BBINFO_DEBUG_MSG
+  bbinfo_file_name = name;
+// emmm, printf the information will get the gold linker LTO crashes...
+  as_warn(_("file name is %s\n"), bbinfo_file_name);
+#endif
+
 #ifdef WARN_COMMENTS
   found_comment = 0;
 #endif
@@ -845,8 +869,6 @@ read_a_source_file (const char *name)
       while (input_line_pointer < buffer_limit)
 	{
 	  
-          //binpang: debug
-	  printf("New line %s", input_line_pointer);
 	  bfd_boolean was_new_line;
 	  /* We have more of this buffer to parse.  */
 
@@ -1018,6 +1040,10 @@ read_a_source_file (const char *name)
 		    }
 
 		  line_label = colon (s);	/* User-defined label.  */
+		  //binpang add, record the last user defined label
+#if defined(__i386__) || defined(__x86_64__)
+		  update_last_symbol(line_label);
+#endif
 		  restore_line_pointer (nul_char);
 		  ++ input_line_pointer;
 #ifdef tc_check_label
@@ -1391,6 +1417,7 @@ read_a_source_file (const char *name)
 		     "first comment found here");
   }
 #endif
+
 }
 
 /* Convert O_constant expression EXP into the equivalent O_big representation.
@@ -3979,6 +4006,14 @@ cons_worker (int nbytes,	/* 1=.byte, 2=.word, 4=.long.  */
   char *stop = NULL;
   char stopc = 0;
 
+  // binpang, add. If the fragment code follows .byte etc statements
+  // reset the fragment last basic block pointer.
+  fragS *frag_tmp = frag_now;
+  if (frag_tmp->last_bb){
+    frag_tmp->last_bb = NULL;
+    // printf("DEBUG: Set the last basic block to zero!");
+  }
+
 #ifdef md_flush_pending_output
   md_flush_pending_output ();
 #endif
diff --git "a/set\033:q" "b/set\033:q"
new file mode 100644
index 0000000..0941808
--- /dev/null
+++ "b/set\033:q"
@@ -0,0 +1,484 @@
+[1mdiff --git a/Makefile.am b/Makefile.am[m
+[1mindex e183855..e882179 100644[m
+[1m--- a/Makefile.am[m
+[1m+++ b/Makefile.am[m
+[36m@@ -71,6 +71,7 @@[m [mGAS_CFILES = \[m
+ 	dwarf2dbg.c \[m
+ 	dw2gencfi.c \[m
+ 	bbInfoHandle.c \[m
+[32m+[m	[32mshuffleInfo.pb-c.c \[m
+ 	ecoff.c \[m
+ 	ehopt.c \[m
+ 	expr.c \[m
+[36m@@ -106,6 +107,7 @@[m [mHFILES = \[m
+ 	dwarf2dbg.h \[m
+ 	dw2gencfi.h \[m
+ 	bbInfoHandle.h \[m
+[32m+[m	[32mshuffleInfo.pb-c.h \[m
+ 	ecoff.h \[m
+ 	emul-target.h \[m
+ 	emul.h \[m
+[1mdiff --git a/Makefile.in b/Makefile.in[m
+[1mindex 161d5ca..57629ff 100644[m
+[1m--- a/Makefile.in[m
+[1m+++ b/Makefile.in[m
+[36m@@ -117,7 +117,9 @@[m [mam__objects_1 = app.$(OBJEXT) as.$(OBJEXT) atof-generic.$(OBJEXT) \[m
+ 	listing.$(OBJEXT) literal.$(OBJEXT) macro.$(OBJEXT) \[m
+ 	messages.$(OBJEXT) output-file.$(OBJEXT) read.$(OBJEXT) \[m
+ 	remap.$(OBJEXT) sb.$(OBJEXT) stabs.$(OBJEXT) subsegs.$(OBJEXT) \[m
+[31m-	symbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) [m
+[32m+[m	[32msymbols.$(OBJEXT) write.$(OBJEXT) bbInfoHandle.$(OBJEXT) \[m
+[32m+[m	[32mshuffleInfo.pb-c.$(OBJEXT)[m
+[32m+[m[41m	[m
+ am_as_new_OBJECTS = $(am__objects_1)[m
+ as_new_OBJECTS = $(am_as_new_OBJECTS)[m
+ am__DEPENDENCIES_1 =[m
+[36m@@ -368,6 +370,7 @@[m [mGAS_CFILES = \[m
+ 	dwarf2dbg.c \[m
+ 	dw2gencfi.c \[m
+ 	bbInfoHandle.c \[m
+[32m+[m	[32mshuffleInfo.pb-c.c \[m
+ 	ecoff.c \[m
+ 	ehopt.c \[m
+ 	expr.c \[m
+[36m@@ -402,6 +405,7 @@[m [mHFILES = \[m
+ 	dwarf2dbg.h \[m
+ 	dw2gencfi.h \[m
+ 	bbInfoHandle.h \[m
+[32m+[m	[32mshuffleInfo.pb-c.h \[m
+ 	ecoff.h \[m
+ 	emul-target.h \[m
+ 	emul.h \[m
+[1mdiff --git a/bbInfoHandle.c b/bbInfoHandle.c[m
+[1mindex bed65bf..9bd08bb 100644[m
+[1m--- a/bbInfoHandle.c[m
+[1m+++ b/bbInfoHandle.c[m
+[36m@@ -10,6 +10,7 @@[m [mstatic void funcb_bbInfo_handler (int);[m
+ static void funce_bbInfo_handler (int);[m
+ static void bb_bbInfo_handler (int);[m
+ static void be_bbInfo_handler (int);[m
+[32m+[m[32mvoid bbinfo_update_shuffle_info(void);[m
+ bbinfo_mbb* init_basic_block(void);[m
+ bbinfo_fixup* bbinfo_init_fixup(void);[m
+ [m
+[36m@@ -39,6 +40,17 @@[m [msymbolS *last_symbol; // last user defined symbol[m
+ uint32_t cur_block_id; // global current basic block id [m
+ unsigned char function_head; // represent that the current basic block is current function's first entry[m
+ [m
+[32m+[m[32munsigned text_sec_cnt;[m
+[32m+[m[32munsigned rodata_sec_cnt;[m
+[32m+[m[32munsigned data_sec_cnt;[m
+[32m+[m[32munsigned datarel_sec_cnt;[m
+[32m+[m[32munsigned init_sec_cnt;[m
+[32m+[m
+[32m+[m[32m// store the shuffle information[m
+[32m+[m[32mchar* bbinfo_shuffle_info_buf = NULL;[m
+[32m+[m[32munsigned bbinfo_shuffle_info_buf_len = 0;[m
+[32m+[m
+[32m+[m
+ // init the global variables[m
+ void bbinfo_init(){[m
+   fixups_list_head = NULL;[m
+[36m@@ -51,6 +63,11 @@[m [mvoid bbinfo_init(){[m
+   last_symbol = NULL;[m
+   cur_block_id = 0;[m
+   function_head = 0;[m
+[32m+[m[32m  text_sec_cnt = 0;[m
+[32m+[m[32m  data_sec_cnt = 0;[m
+[32m+[m[32m  datarel_sec_cnt = 0;[m
+[32m+[m[32m  rodata_sec_cnt = 0;[m
+[32m+[m[32m  init_sec_cnt = 0;[m
+ }[m
+ [m
+ // update the last_symbol global variable[m
+[36m@@ -72,6 +89,211 @@[m [mint update_last_symbol(symbolS *sym){[m
+   return 0;[m
+ }[m
+ [m
+[32m+[m[32m// generate shuffleInfo into protobuf[m
+[32m+[m[32mvoid bbinfo_update_shuffle_info(void){[m
+[32m+[m[32mShuffleInfo__ReorderInfo reorder_info = SHUFFLE_INFO__REORDER_INFO__INIT;[m
+[32m+[m[32mShuffleInfo__ReorderInfo__BinaryInfo binary_info =[m[41m [m
+[32m+[m[32m  SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;[m
+[32m+[m
+[32m+[m[32mbinary_info.has_rand_obj_offset = 1;[m
+[32m+[m[32mbinary_info.rand_obj_offset = 0; // should be update at linking time[m
+[32m+[m[32mbinary_info.has_main_addr_offset = 1;[m
+[32m+[m[32mbinary_info.main_addr_offset = 0; // should be update at linking time[m
+[32m+[m
+[32m+[m[32m// 0 is ordinary c/c++ file.[m[41m [m
+[32m+[m[32m// 1 is a source file contains inline assembly[m
+[32m+[m[32m// 2 is standalone assembly file[m
+[32m+[m[32m// TODO(binpang). Identify assemble file and inline[m[41m [m
+[32m+[m[32mbinary_info.has_src_type = 1;[m
+[32m+[m[32mbinary_info.src_type = 0;[m
+[32m+[m
+[32m+[m[32mreorder_info.bin = &binary_info;[m
+[32m+[m
+[32m+[m[32munsigned bb_cnt = 0;[m
+[32m+[m[32munsigned text_fixp_cnt = 0;[m
+[32m+[m[32munsigned rodata_fixp_cnt = 0;[m
+[32m+[m[32munsigned data_fixp_cnt = 0;[m
+[32m+[m[32munsigned datarel_fixp_cnt = 0;[m
+[32m+[m[32munsigned init_fixp_cnt = 0;[m
+[32m+[m
+[32m+[m[32m// count the basic block number[m
+[32m+[m[32mfor(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;[m
+[32m+[m[32m    cur_mbb = cur_mbb->next){[m
+[32m+[m[32m  bb_cnt++;[m
+[32m+[m[32m}[m
+[32m+[m
+[32m+[m[32m// count the fixp number[m
+[32m+[m[32mfor(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;[m
+[32m+[m[32m    cur_fixp = cur_fixp->next){[m
+[32m+[m[32m  const char* sec_name =cur_fixp->sec->name;[m
+[32m+[m[32m  if (strstr(sec_name, ".text"))[m
+[32m+[m[32m    text_fixp_cnt++;[m
+[32m+[m[32m  else if(strstr(sec_name, ".rodata"))[m
+[32m+[m[32m    rodata_fixp_cnt++;[m
+[32m+[m[32m  else if(strstr(sec_name, ".init_array"))[m
+[32m+[m[32m    init_fixp_cnt++;[m
+[32m+[m[32m  else if(strstr(sec_name, ".data.rel.ro"))[m
+[32m+[m[32m    datarel_fixp_cnt++;[m
+[32m+[m[32m  else if(strstr(sec_name, ".data"))[m
+[32m+[m[32m    data_fixp_cnt++;[m
+[32m+[m[32m}[m
+[32m+[m
+[32m+[m[32mShuffleInfo__ReorderInfo__LayoutInfo **layout;[m
+[32m+[m[32mlayout = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo *) * bb_cnt);[m
+[32m+[m[32munsigned index = 0;[m
+[32m+[m[32munsigned obj_size = 0;[m
+[32m+[m[32mfor(bbinfo_mbb* cur_mbb = mbbs_list_head; cur_mbb;[m
+[32m+[m[32m    cur_mbb = cur_mbb->next){[m
+[32m+[m[32m  layout[index] = malloc(sizeof(ShuffleInfo__ReorderInfo__LayoutInfo));[m
+[32m+[m
+[32m+[m[32m  shuffle_info__reorder_info__layout_info__init(layout[index]);[m
+[32m+[m[32m  layout[index]->has_type = 1;[m
+[32m+[m[32m  layout[index]->type = cur_mbb->type;[m
+[32m+[m[32m  layout[index]->has_bb_size = 1;[m
+[32m+[m[32m  layout[index]->bb_size = cur_mbb->size;[m
+[32m+[m[32m  layout[index]->has_bb_fallthrough = 1;[m
+[32m+[m[32m  layout[index]->bb_fallthrough = cur_mbb->fall_through;[m
+[32m+[m[32m  //TODO, add basic block offset in shuffle.proto[m
+[32m+[m[32m  //TODO, collect num_fixups in gcc toolchain[m
+[32m+[m[32m  layout[index]->section_name = (char*)cur_mbb->sec->name;[m
+[32m+[m[32m  index++;[m
+[32m+[m[41m  [m
+[32m+[m[32m  obj_size += cur_mbb->size;[m
+[32m+[m[32m}[m
+[32m+[m
+[32m+[m[32mbinary_info.has_obj_sz;[m
+[32m+[m[32mbinary_info.obj_sz = obj_size;[m
+[32m+[m
+[32m+[m[32m// update layout_info[m
+[32m+[m[32mreorder_info.n_layout = index;[m
+[32m+[m[32mreorder_info.layout = layout;[m
+[32m+[m
+[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo **fixup;[m
+[32m+[m[32mfixup = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo *) * 1);[m
+[32m+[m[32mfixup[0] = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo));[m
+[32m+[m[32mshuffle_info__reorder_info__fixup_info__init(fixup[0]);[m
+[32m+[m
+[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text_fixp = NULL;[m
+[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata_fixp = NULL;[m
+[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data_fixp = NULL;[m
+[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel_fixp = NULL;[m
+[32m+[m[32mShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **init_fixp = NULL;[m
+[32m+[m
+[32m+[m[32mif (text_fixp_cnt)[m
+[32m+[m[32m  text_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m[41m [m
+[32m+[m[41m    [m								[32mtext_fixp_cnt);[m
+[32m+[m[32mif (rodata_fixp_cnt)[m
+[32m+[m[32m  rodata_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
+[32m+[m[41m    [m								[32mrodata_fixp_cnt);[m
+[32m+[m[32mif (data_fixp_cnt)[m
+[32m+[m[32m  data_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
+[32m+[m[41m      [m								[32mdata_fixp_cnt);[m
+[32m+[m[32mif (init_fixp_cnt)[m
+[32m+[m[32m  init_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
+[32m+[m[41m      [m								[32minit_fixp_cnt);[m
+[32m+[m[32mif (datarel_fixp_cnt)[m
+[32m+[m[32m  datarel_fixp = malloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *) *[m
+[32m+[m[41m      [m								[32mdatarel_fixp_cnt);[m
+[32m+[m[32munsigned cur_text_index = 0;[m
+[32m+[m[32munsigned cur_rodata_index = 0;[m
+[32m+[m[32munsigned cur_data_index = 0;[m
+[32m+[m[32munsigned cur_datarel_index = 0;[m
+[32m+[m[32munsigned cur_init_index = 0;[m
+[32m+[m
+[32m+[m[32mfor (bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp;[m
+[32m+[m[41m    [m					[32mcur_fixp = cur_fixp->next){[m
+[32m+[m[32m  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *cur_fixp_tuple =[m
+[32m+[m[41m    [m		[32mmalloc(sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple));[m
+[32m+[m[32m  shuffle_info__reorder_info__fixup_info__fixup_tuple__init(cur_fixp_tuple);[m[41m [m
+[32m+[m[32m  cur_fixp_tuple->offset = cur_fixp->offset;[m
+[32m+[m[32m  cur_fixp_tuple->deref_sz = cur_fixp->size;[m
+[32m+[m[32m  cur_fixp_tuple->is_rela = cur_fixp->is_rela;[m
+[32m+[m[32m  cur_fixp_tuple->section_name = (char*) cur_fixp->sec->name;[m
+[32m+[m[32m  // jump table information[m
+[32m+[m[32m  if (cur_fixp->table_size){[m
+[32m+[m[32m    cur_fixp_tuple->has_num_jt_entries = 1;[m
+[32m+[m[32m    cur_fixp_tuple->num_jt_entries = cur_fixp->table_size;[m
+[32m+[m[32m    cur_fixp_tuple->has_jt_entry_sz = 1;[m
+[32m+[m[32m    cur_fixp_tuple->jt_entry_sz = cur_fixp->entry_size;[m
+[32m+[m[32m  }[m
+[32m+[m
+[32m+[m[32m  cur_fixp_tuple->has_type = 1;[m
+[32m+[m[32m  if (cur_fixp->is_new_section){[m
+[32m+[m[32m    cur_fixp_tuple->type = 4; // let linker know if there are multiple .text sections[m
+[32m+[m[32m  }else{[m
+[32m+[m[32m    cur_fixp_tuple->type = 0; // c2c, c2d, d2c, d2d default=0; should be updated by linker[m
+[32m+[m[32m  }[m
+[32m+[m
+[32m+[m[32m  const char* sec_name =cur_fixp->sec->name;[m
+[32m+[m[32m  if (strstr(sec_name, ".text"))[m
+[32m+[m[32m    text_fixp[cur_text_index++] = cur_fixp_tuple;[m[41m  [m
+[32m+[m[32m  else if(strstr(sec_name, ".rodata"))[m
+[32m+[m[32m    rodata_fixp[cur_rodata_index++] = cur_fixp_tuple;[m
+[32m+[m[32m  else if(strstr(sec_name, ".init_array"))[m
+[32m+[m[32m    init_fixp[cur_init_index++] = cur_fixp_tuple;[m
+[32m+[m[32m  else if(strstr(sec_name, ".data.rel.ro"))[m
+[32m+[m[32m    datarel_fixp[cur_datarel_index++] = cur_fixp_tuple;[m
+[32m+[m[32m  else if(strstr(sec_name, ".data"))[m
+[32m+[m[32m    data_fixp[cur_data_index++] = cur_fixp_tuple;[m
+[32m+[m[32m}[m
+[32m+[m
+[32m+[m[32m// store the fixup information into protobuf[m
+[32m+[m[32mfixup[0]->n_text = text_fixp_cnt;[m
+[32m+[m[32mfixup[0]->text = text_fixp;[m
+[32m+[m[32mfixup[0]->n_rodata = rodata_fixp_cnt;[m
+[32m+[m[32mfixup[0]->rodata = rodata_fixp;[m
+[32m+[m[32mfixup[0]->n_data = data_fixp_cnt;[m
+[32m+[m[32mfixup[0]->data = data_fixp;[m
+[32m+[m[32mfixup[0]->n_datarel = datarel_fixp_cnt;[m
+[32m+[m[32mfixup[0]->datarel = datarel_fixp;[m
+[32m+[m[32mfixup[0]->n_initarray = init_fixp_cnt;[m
+[32m+[m[32mfixup[0]->initarray = init_fixp;[m
+[32m+[m
+[32m+[m[32mreorder_info.n_fixup = 1;[m
+[32m+[m[32mreorder_info.fixup = fixup;[m
+[32m+[m
+[32m+[m[32mbbinfo_shuffle_info_buf_len = protobuf_c_message_get_packed_size(&reorder_info); // get protobuf bytes length[m
+[32m+[m
+[32m+[m[32mbbinfo_shuffle_info_buf = malloc(bbinfo_shuffle_info_buf_len);[m
+[32m+[m[32mprotobuf_c_message_pack(&reorder_info, bbinfo_shuffle_info_buf); // Pack reorder_info into buf[m
+[32m+[m
+[32m+[m[32m// free the malloced space[m
+[32m+[m
+[32m+[m[32m// free layouts[m
+[32m+[m[32mfor(index = 0; index < bb_cnt; index++){[m
+[32m+[m[32m  free(layout[index]);[m
+[32m+[m[32m}[m
+[32m+[m[32mfree(layout);[m
+[32m+[m
+[32m+[m[32m// free fixups[m
+[32m+[m[32mfor (index = 0; index < text_fixp_cnt; index++){[m
+[32m+[m[32m  free (text_fixp[index]);[m
+[32m+[m[32m}[m
+[32m+[m[32mfor (index = 0; index < data_fixp_cnt; index++){[m
+[32m+[m[32m  free (data_fixp[index]);[m
+[32m+[m[32m}[m
+[32m+[m[32mfor (index = 0; index < rodata_fixp_cnt; index++){[m
+[32m+[m[32m  free (rodata_fixp[index]);[m
+[32m+[m[32m}[m
+[32m+[m[32mfor (index = 0; index < init_fixp_cnt; index++){[m
+[32m+[m[32m  free (init_fixp[index]);[m
+[32m+[m[32m}[m
+[32m+[m[32mfor (index = 0; index < datarel_fixp_cnt; index++){[m
+[32m+[m[32m  free (datarel_fixp[index]);[m
+[32m+[m[32m}[m
+[32m+[m[32mif (text_fixp_cnt)[m
+[32m+[m[32m free (text_fixp);[m[41m [m
+[32m+[m[32mif (rodata_fixp_cnt)[m
+[32m+[m[32m free (rodata_fixp);[m
+[32m+[m[32mif (data_fixp_cnt)[m
+[32m+[m[32m free (data_fixp);[m
+[32m+[m[32mif (init_fixp_cnt)[m
+[32m+[m[32m free (init_fixp);[m
+[32m+[m[32mif (datarel_fixp_cnt)[m
+[32m+[m[32m free (datarel_fixp);[m[41m [m
+[32m+[m[32m}[m
+[32m+[m
+[32m+[m
+ // init the fixup struct[m
+ bbinfo_fixup* bbinfo_init_fixup(void){[m
+   bbinfo_fixup* result_fixup = malloc(sizeof(bbinfo_fixup));[m
+[36m@@ -88,6 +310,58 @@[m [mbbinfo_fixup* bbinfo_init_fixup(void){[m
+   return result_fixup;[m
+ }[m
+ [m
+[32m+[m[32m// if this is the new section[m
+[32m+[m[32mchar bbinfo_is_new_sec(asection *sec){[m
+[32m+[m[32m  const char* sec_name = sec->name;[m
+[32m+[m[32m  char* tmp_pointer = NULL;[m
+[32m+[m
+[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".text")) &&[m
+[32m+[m[32m      tmp_pointer == sec_name){[m
+[32m+[m[32m    text_sec_cnt++;[m
+[32m+[m[32m    if (text_sec_cnt == 1)[m
+[32m+[m[32m      return 0;[m
+[32m+[m[32m    else[m
+[32m+[m[32m      return 1;[m
+[32m+[m[32m  }[m
+[32m+[m
+[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".rodata")) &&[m[41m [m
+[32m+[m	[32mtmp_pointer == sec_name){[m
+[32m+[m[32m      rodata_sec_cnt++;[m
+[32m+[m[32m      if (rodata_sec_cnt == 1)[m
+[32m+[m	[32mreturn 0;[m
+[32m+[m[32m      else[m
+[32m+[m	[32mreturn 1;[m
+[32m+[m[32m      }[m
+[32m+[m
+[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".init_array")) &&[m
+[32m+[m[32m      tmp_pointer == sec_name){[m
+[32m+[m[32m    init_sec_cnt++;[m
+[32m+[m[32m    if (init_sec_cnt == 1)[m
+[32m+[m[32m      return 0;[m
+[32m+[m[32m    else[m
+[32m+[m[32m      return 1;[m
+[32m+[m[32m  }[m
+[32m+[m
+[32m+[m[32m  if ((tmp_pointer = strstr(sec_name, ".data")) &&[m
+[32m+[m[32m      tmp_pointer == sec_name){[m
+[32m+[m
+[32m+[m[32m    if ((tmp_pointer = strstr(sec_name, ".data.rel.ro")) &&[m
+[32m+[m	[32mtmp_pointer == sec_name){[m
+[32m+[m[32m      datarel_sec_cnt++;[m
+[32m+[m[32m      if (datarel_sec_cnt == 1)[m
+[32m+[m	[32mreturn 0;[m
+[32m+[m[32m      else[m
+[32m+[m	[32mreturn 1;[m
+[32m+[m[32m    }[m
+[32m+[m
+[32m+[m[32m    data_sec_cnt++;[m
+[32m+[m[32m    if (data_sec_cnt == 1)[m
+[32m+[m[32m      return 0;[m
+[32m+[m[32m    else[m
+[32m+[m[32m      return 1;[m
+[32m+[m[32m  }[m
+[32m+[m[32m  return -1;[m
+[32m+[m[32m}[m
+ // init the bbinfo struct[m
+ bbinfo_mbb* init_basic_block(){[m
+   // malloc space[m
+[1mdiff --git a/bbInfoHandle.h b/bbInfoHandle.h[m
+[1mindex ac3b8c4..edc727b 100644[m
+[1m--- a/bbInfoHandle.h[m
+[1m+++ b/bbInfoHandle.h[m
+[36m@@ -7,12 +7,14 @@[m
+ #define BBINFOHANDLE_H[m
+ [m
+ #include "as.h"[m
+[32m+[m[32m#include "shuffleInfo.pb-c.h"[m
+ #include <stdint.h>[m
+ [m
+ extern const pseudo_typeS bbInfo_pseudo_table[];[m
+ extern int update_last_symbol(symbolS*);[m
+ extern void init_bbinfo_global(void);[m
+ extern void bbinfo_init(void);[m
+[32m+[m[32mextern char bbinfo_is_new_sec(asection*);[m
+ [m
+ [m
+ [m
+[36m@@ -41,6 +43,7 @@[m [mtypedef struct basic_block bbinfo_mbb;[m
+ typedef struct fixup{[m
+   uint32_t offset; // offset from section[m
+   asection *sec; // which section the basic block belongs to[m
+[32m+[m[32m  unsigned char is_new_section; // if its parent section is the new section that has the same name[m
+   unsigned char is_rela; // if this fixup is relative[m
+   uint32_t size; // the reference's size[m
+   uint32_t table_size; // for jump table reference only[m
+[36m@@ -57,6 +60,17 @@[m [mextern uint32_t prev_function_id; // prev function id[m
+ extern uint32_t cur_function_end_id; // current function end id[m
+ extern symbolS *last_symbol; // last user defined symbol[m
+ extern uint32_t cur_block_id; // global current basic block id[m
+[32m+[m[32m// according to CCR, in c++. there may exist multiple .text sections, so recording the .text number[m
+[32m+[m[32mextern unsigned text_sec_cnt;[m
+[32m+[m[32mextern unsigned rodata_sec_cnt;[m
+[32m+[m[32mextern unsigned data_sec_cnt;[m
+[32m+[m[32mextern unsigned datarel_sec_cnt;[m
+[32m+[m[32mextern unsigned init_sec_cnt;[m
+[32m+[m
+[32m+[m[32m// shuffleInfo that CCR defines[m
+[32m+[m[32mextern char* bbinfo_shuffle_info_buf;[m[41m [m
+[32m+[m[32mextern unsigned bbinfo_shuffle_info_buf_len;[m
+ [m
+ extern bbinfo_fixup* bbinfo_init_fixup(void);[m
+[32m+[m[32mextern void bbinfo_update_shuffle_info(void);[m
+ #endif[m
+[1mdiff --git a/write.c b/write.c[m
+[1mindex 46a22e5..ab5ad70 100644[m
+[1m--- a/write.c[m
+[1m+++ b/write.c[m
+[36m@@ -1198,7 +1198,6 @@[m [mfix_segment (bfd *abfd ATTRIBUTE_UNUSED,[m
+  * binpang, add. [m
+  * collect fixup information before fixup resolved.[m
+  */[m
+[31m-[m
+ static void [m
+ bbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
+     	     asection *sec,[m
+[36m@@ -1206,6 +1205,12 @@[m [mbbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
+ {[m
+   fixS *fixp;[m
+   segment_info_type *seginfo = seg_info (sec);[m
+[32m+[m[32m  char is_new_sec = is_new_sec = bbinfo_is_new_sec(sec);[m
+[32m+[m[41m  [m
+[32m+[m[32m  // we only collect .text, .rodata, .init_array, .data, .data.rel.ro sections[m
+[32m+[m[32m  // FIXME[m
+[32m+[m[32m  if (is_new_sec == -1)[m
+[32m+[m[32m    return;[m
+   [m
+  /*[m
+   * TODO(binpang), add relocation information that .realoc directive defined[m
+[36m@@ -1225,9 +1230,11 @@[m [mbbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,[m
+       tmp_fixp->table_size = S_GET_JMPTBL_SIZE(tmp_sym);[m
+       tmp_fixp->entry_size = S_GET_JMPTBL_ENTRY_SZ(tmp_sym);[m
+     }[m
+[32m+[m[32m    if (is_new_sec){[m
+[32m+[m[32m      tmp_fixp->is_new_section = 1;[m
+[32m+[m[32m    }[m
+   }[m
+ [m
+[31m-[m
+ }[m
+ static void[m
+ install_reloc (asection *sec, arelent *reloc, fragS *fragp,[m
+[36m@@ -1658,6 +1665,19 @@[m [mwrite_contents (bfd *abfd ATTRIBUTE_UNUSED,[m
+   segment_info_type *seginfo = seg_info (sec);[m
+   addressT offset = 0;[m
+   fragS *f;[m
+[32m+[m[41m  [m
+[32m+[m[32m  /*[m
+[32m+[m[32m   * binpang, add[m
+[32m+[m[32m   * output the section .rand[m
+[32m+[m[32m   */[m[41m [m
+[32m+[m[32m  if (!strcmp(sec->name, ".rand")){[m
+[32m+[m[32m    unsigned result = bfd_set_section_contents(stdoutput, sec, bbinfo_shuffle_info_buf,[m[41m [m
+[32m+[m			[32m(file_ptr) 0, (bfd_size_type) bbinfo_shuffle_info_buf_len);[m
+[32m+[m[41m    [m
+[32m+[m[32m    if(!result)[m
+[32m+[m[32m      as_warn(_("can't write data into .rand"));[m
+[32m+[m[32m    return;[m
+[32m+[m[32m  }[m
+ [m
+   /* Write out the frags.  */[m
+   if (seginfo == NULL[m
+[36m@@ -2348,6 +2368,16 @@[m [mwrite_object_file (void)[m
+       bfd_map_over_sections (stdoutput, compress_debug, (char *) 0);[m
+     }[m
+ [m
+[32m+[m[32m  /*[m
+[32m+[m[32m   * binpang, add[m
+[32m+[m[32m   * create .rand section[m
+[32m+[m[32m   */[m
+[32m+[m[32m  asection* rand_sec = bfd_make_section (stdoutput, ".rand");[m
+[32m+[m[32m  bfd_set_section_flags(stdoutput, rand_sec, SEC_HAS_CONTENTS);[m
+[32m+[m[32m  bbinfo_update_shuffle_info();[m
+[32m+[m[32m  // BUG? why should at here specify size. But in write_contents fuction, it can't work.[m
+[32m+[m[32m  rand_sec->size = bbinfo_shuffle_info_buf_len;[m
+[32m+[m
+   bfd_map_over_sections (stdoutput, write_contents, (char *) 0);[m
+ [m
+ // binpang, add. debug.[m
diff --git a/shuffleInfo.pb-c.c b/shuffleInfo.pb-c.c
new file mode 100644
index 0000000..fee9db1
--- /dev/null
+++ b/shuffleInfo.pb-c.c
@@ -0,0 +1,612 @@
+/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
+/* Generated from: shuffleInfo.proto */
+
+/* Do not generate deprecated warnings for self */
+#ifndef PROTOBUF_C__NO_DEPRECATED
+#define PROTOBUF_C__NO_DEPRECATED
+#endif
+
+#include "shuffleInfo.pb-c.h"
+void   shuffle_info__reorder_info__binary_info__init
+                     (ShuffleInfo__ReorderInfo__BinaryInfo         *message)
+{
+  static const ShuffleInfo__ReorderInfo__BinaryInfo init_value = SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT;
+  *message = init_value;
+}
+void   shuffle_info__reorder_info__layout_info__init
+                     (ShuffleInfo__ReorderInfo__LayoutInfo         *message)
+{
+  static const ShuffleInfo__ReorderInfo__LayoutInfo init_value = SHUFFLE_INFO__REORDER_INFO__LAYOUT_INFO__INIT;
+  *message = init_value;
+}
+void   shuffle_info__reorder_info__fixup_info__fixup_tuple__init
+                     (ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple         *message)
+{
+  static const ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple init_value = SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__FIXUP_TUPLE__INIT;
+  *message = init_value;
+}
+void   shuffle_info__reorder_info__fixup_info__init
+                     (ShuffleInfo__ReorderInfo__FixupInfo         *message)
+{
+  static const ShuffleInfo__ReorderInfo__FixupInfo init_value = SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__INIT;
+  *message = init_value;
+}
+void   shuffle_info__reorder_info__source_info__init
+                     (ShuffleInfo__ReorderInfo__SourceInfo         *message)
+{
+  static const ShuffleInfo__ReorderInfo__SourceInfo init_value = SHUFFLE_INFO__REORDER_INFO__SOURCE_INFO__INIT;
+  *message = init_value;
+}
+void   shuffle_info__reorder_info__init
+                     (ShuffleInfo__ReorderInfo         *message)
+{
+  static const ShuffleInfo__ReorderInfo init_value = SHUFFLE_INFO__REORDER_INFO__INIT;
+  *message = init_value;
+}
+size_t shuffle_info__reorder_info__get_packed_size
+                     (const ShuffleInfo__ReorderInfo *message)
+{
+  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t shuffle_info__reorder_info__pack
+                     (const ShuffleInfo__ReorderInfo *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t shuffle_info__reorder_info__pack_to_buffer
+                     (const ShuffleInfo__ReorderInfo *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+ShuffleInfo__ReorderInfo *
+       shuffle_info__reorder_info__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (ShuffleInfo__ReorderInfo *)
+     protobuf_c_message_unpack (&shuffle_info__reorder_info__descriptor,
+                                allocator, len, data);
+}
+void   shuffle_info__reorder_info__free_unpacked
+                     (ShuffleInfo__ReorderInfo *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &shuffle_info__reorder_info__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+static const ProtobufCFieldDescriptor shuffle_info__reorder_info__binary_info__field_descriptors[4] =
+{
+  {
+    "rand_obj_offset",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_rand_obj_offset),
+    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, rand_obj_offset),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "main_addr_offset",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_main_addr_offset),
+    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, main_addr_offset),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "obj_sz",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_obj_sz),
+    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, obj_sz),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "src_type",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, has_src_type),
+    offsetof(ShuffleInfo__ReorderInfo__BinaryInfo, src_type),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned shuffle_info__reorder_info__binary_info__field_indices_by_name[] = {
+  1,   /* field[1] = main_addr_offset */
+  2,   /* field[2] = obj_sz */
+  0,   /* field[0] = rand_obj_offset */
+  3,   /* field[3] = src_type */
+};
+static const ProtobufCIntRange shuffle_info__reorder_info__binary_info__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 4 }
+};
+const ProtobufCMessageDescriptor shuffle_info__reorder_info__binary_info__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "ShuffleInfo.ReorderInfo.BinaryInfo",
+  "BinaryInfo",
+  "ShuffleInfo__ReorderInfo__BinaryInfo",
+  "ShuffleInfo",
+  sizeof(ShuffleInfo__ReorderInfo__BinaryInfo),
+  4,
+  shuffle_info__reorder_info__binary_info__field_descriptors,
+  shuffle_info__reorder_info__binary_info__field_indices_by_name,
+  1,  shuffle_info__reorder_info__binary_info__number_ranges,
+  (ProtobufCMessageInit) shuffle_info__reorder_info__binary_info__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const uint32_t shuffle_info__reorder_info__layout_info__assemble_type__default_value = 0u;
+static const ProtobufCFieldDescriptor shuffle_info__reorder_info__layout_info__field_descriptors[8] =
+{
+  {
+    "bb_size",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_bb_size),
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, bb_size),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "type",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_type),
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, type),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "num_fixups",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_num_fixups),
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, num_fixups),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "bb_fallthrough",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_bb_fallthrough),
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, bb_fallthrough),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "section_name",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, section_name),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "offset",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_offset),
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, offset),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "padding_size",
+    7,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_padding_size),
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, padding_size),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "assemble_type",
+    8,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, has_assemble_type),
+    offsetof(ShuffleInfo__ReorderInfo__LayoutInfo, assemble_type),
+    NULL,
+    &shuffle_info__reorder_info__layout_info__assemble_type__default_value,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned shuffle_info__reorder_info__layout_info__field_indices_by_name[] = {
+  7,   /* field[7] = assemble_type */
+  3,   /* field[3] = bb_fallthrough */
+  0,   /* field[0] = bb_size */
+  2,   /* field[2] = num_fixups */
+  5,   /* field[5] = offset */
+  6,   /* field[6] = padding_size */
+  4,   /* field[4] = section_name */
+  1,   /* field[1] = type */
+};
+static const ProtobufCIntRange shuffle_info__reorder_info__layout_info__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 8 }
+};
+const ProtobufCMessageDescriptor shuffle_info__reorder_info__layout_info__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "ShuffleInfo.ReorderInfo.LayoutInfo",
+  "LayoutInfo",
+  "ShuffleInfo__ReorderInfo__LayoutInfo",
+  "ShuffleInfo",
+  sizeof(ShuffleInfo__ReorderInfo__LayoutInfo),
+  8,
+  shuffle_info__reorder_info__layout_info__field_descriptors,
+  shuffle_info__reorder_info__layout_info__field_indices_by_name,
+  1,  shuffle_info__reorder_info__layout_info__number_ranges,
+  (ProtobufCMessageInit) shuffle_info__reorder_info__layout_info__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__field_descriptors[7] =
+{
+  {
+    "offset",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_UINT32,
+    0,   /* quantifier_offset */
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, offset),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "deref_sz",
+    2,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_UINT32,
+    0,   /* quantifier_offset */
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, deref_sz),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "is_rela",
+    3,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_BOOL,
+    0,   /* quantifier_offset */
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, is_rela),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "type",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_type),
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, type),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "section_name",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, section_name),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "num_jt_entries",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_num_jt_entries),
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, num_jt_entries),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "jt_entry_sz",
+    7,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, has_jt_entry_sz),
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple, jt_entry_sz),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned shuffle_info__reorder_info__fixup_info__fixup_tuple__field_indices_by_name[] = {
+  1,   /* field[1] = deref_sz */
+  2,   /* field[2] = is_rela */
+  6,   /* field[6] = jt_entry_sz */
+  5,   /* field[5] = num_jt_entries */
+  0,   /* field[0] = offset */
+  4,   /* field[4] = section_name */
+  3,   /* field[3] = type */
+};
+static const ProtobufCIntRange shuffle_info__reorder_info__fixup_info__fixup_tuple__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 7 }
+};
+const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple",
+  "FixupTuple",
+  "ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple",
+  "ShuffleInfo",
+  sizeof(ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple),
+  7,
+  shuffle_info__reorder_info__fixup_info__fixup_tuple__field_descriptors,
+  shuffle_info__reorder_info__fixup_info__fixup_tuple__field_indices_by_name,
+  1,  shuffle_info__reorder_info__fixup_info__fixup_tuple__number_ranges,
+  (ProtobufCMessageInit) shuffle_info__reorder_info__fixup_info__fixup_tuple__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor shuffle_info__reorder_info__fixup_info__field_descriptors[5] =
+{
+  {
+    "text",
+    1,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_text),
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, text),
+    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "rodata",
+    2,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_rodata),
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, rodata),
+    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "data",
+    3,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_data),
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, data),
+    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "datarel",
+    4,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_datarel),
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, datarel),
+    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "initarray",
+    5,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, n_initarray),
+    offsetof(ShuffleInfo__ReorderInfo__FixupInfo, initarray),
+    &shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned shuffle_info__reorder_info__fixup_info__field_indices_by_name[] = {
+  2,   /* field[2] = data */
+  3,   /* field[3] = datarel */
+  4,   /* field[4] = initarray */
+  1,   /* field[1] = rodata */
+  0,   /* field[0] = text */
+};
+static const ProtobufCIntRange shuffle_info__reorder_info__fixup_info__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 5 }
+};
+const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "ShuffleInfo.ReorderInfo.FixupInfo",
+  "FixupInfo",
+  "ShuffleInfo__ReorderInfo__FixupInfo",
+  "ShuffleInfo",
+  sizeof(ShuffleInfo__ReorderInfo__FixupInfo),
+  5,
+  shuffle_info__reorder_info__fixup_info__field_descriptors,
+  shuffle_info__reorder_info__fixup_info__field_indices_by_name,
+  1,  shuffle_info__reorder_info__fixup_info__number_ranges,
+  (ProtobufCMessageInit) shuffle_info__reorder_info__fixup_info__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor shuffle_info__reorder_info__source_info__field_descriptors[1] =
+{
+  {
+    "src_type",
+    1,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(ShuffleInfo__ReorderInfo__SourceInfo, n_src_type),
+    offsetof(ShuffleInfo__ReorderInfo__SourceInfo, src_type),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned shuffle_info__reorder_info__source_info__field_indices_by_name[] = {
+  0,   /* field[0] = src_type */
+};
+static const ProtobufCIntRange shuffle_info__reorder_info__source_info__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 1 }
+};
+const ProtobufCMessageDescriptor shuffle_info__reorder_info__source_info__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "ShuffleInfo.ReorderInfo.SourceInfo",
+  "SourceInfo",
+  "ShuffleInfo__ReorderInfo__SourceInfo",
+  "ShuffleInfo",
+  sizeof(ShuffleInfo__ReorderInfo__SourceInfo),
+  1,
+  shuffle_info__reorder_info__source_info__field_descriptors,
+  shuffle_info__reorder_info__source_info__field_indices_by_name,
+  1,  shuffle_info__reorder_info__source_info__number_ranges,
+  (ProtobufCMessageInit) shuffle_info__reorder_info__source_info__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor shuffle_info__reorder_info__field_descriptors[4] =
+{
+  {
+    "bin",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(ShuffleInfo__ReorderInfo, bin),
+    &shuffle_info__reorder_info__binary_info__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "layout",
+    2,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(ShuffleInfo__ReorderInfo, n_layout),
+    offsetof(ShuffleInfo__ReorderInfo, layout),
+    &shuffle_info__reorder_info__layout_info__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "fixup",
+    3,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(ShuffleInfo__ReorderInfo, n_fixup),
+    offsetof(ShuffleInfo__ReorderInfo, fixup),
+    &shuffle_info__reorder_info__fixup_info__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "source",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(ShuffleInfo__ReorderInfo, source),
+    &shuffle_info__reorder_info__source_info__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned shuffle_info__reorder_info__field_indices_by_name[] = {
+  0,   /* field[0] = bin */
+  2,   /* field[2] = fixup */
+  1,   /* field[1] = layout */
+  3,   /* field[3] = source */
+};
+static const ProtobufCIntRange shuffle_info__reorder_info__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 4 }
+};
+const ProtobufCMessageDescriptor shuffle_info__reorder_info__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "ShuffleInfo.ReorderInfo",
+  "ReorderInfo",
+  "ShuffleInfo__ReorderInfo",
+  "ShuffleInfo",
+  sizeof(ShuffleInfo__ReorderInfo),
+  4,
+  shuffle_info__reorder_info__field_descriptors,
+  shuffle_info__reorder_info__field_indices_by_name,
+  1,  shuffle_info__reorder_info__number_ranges,
+  (ProtobufCMessageInit) shuffle_info__reorder_info__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
diff --git a/shuffleInfo.pb-c.h b/shuffleInfo.pb-c.h
new file mode 100644
index 0000000..ec0f7b3
--- /dev/null
+++ b/shuffleInfo.pb-c.h
@@ -0,0 +1,270 @@
+/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
+/* Generated from: shuffleInfo.proto */
+
+#ifndef PROTOBUF_C_shuffleInfo_2eproto__INCLUDED
+#define PROTOBUF_C_shuffleInfo_2eproto__INCLUDED
+
+#include <protobuf-c/protobuf-c.h>
+
+PROTOBUF_C__BEGIN_DECLS
+
+#if PROTOBUF_C_VERSION_NUMBER < 1000000
+# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
+#elif 1003001 < PROTOBUF_C_MIN_COMPILER_VERSION
+# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
+#endif
+
+
+typedef struct _ShuffleInfo__ReorderInfo ShuffleInfo__ReorderInfo;
+typedef struct _ShuffleInfo__ReorderInfo__BinaryInfo ShuffleInfo__ReorderInfo__BinaryInfo;
+typedef struct _ShuffleInfo__ReorderInfo__LayoutInfo ShuffleInfo__ReorderInfo__LayoutInfo;
+typedef struct _ShuffleInfo__ReorderInfo__FixupInfo ShuffleInfo__ReorderInfo__FixupInfo;
+typedef struct _ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple;
+typedef struct _ShuffleInfo__ReorderInfo__SourceInfo ShuffleInfo__ReorderInfo__SourceInfo;
+
+
+/* --- enums --- */
+
+
+/* --- messages --- */
+
+/*
+ * Binary info from ld or ld.gold; reordering range and main offset
+ */
+struct  _ShuffleInfo__ReorderInfo__BinaryInfo
+{
+  ProtobufCMessage base;
+  /*
+   * PLACEHOLDER FOR LINKER
+   */
+  protobuf_c_boolean has_rand_obj_offset;
+  uint32_t rand_obj_offset;
+  /*
+   * PLACEHOLDER FOR LINKER
+   */
+  protobuf_c_boolean has_main_addr_offset;
+  uint32_t main_addr_offset;
+  /*
+   * Verification purpose
+   */
+  protobuf_c_boolean has_obj_sz;
+  uint32_t obj_sz;
+  /*
+   * See the SourceInfo message
+   */
+  protobuf_c_boolean has_src_type;
+  uint32_t src_type;
+};
+#define SHUFFLE_INFO__REORDER_INFO__BINARY_INFO__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__binary_info__descriptor) \
+    , 0, 0, 0, 0, 0, 0, 0, 0 }
+
+
+/*
+ * Code layout Info (.text) from LLVM
+ * Embeded info ([#func|#fixup]/obj, [#bbk|#fixup]/func, objSz/ea, funcSz/ea)
+ */
+struct  _ShuffleInfo__ReorderInfo__LayoutInfo
+{
+  ProtobufCMessage base;
+  /*
+   * UPDATE AT LINKTIME WITH OBJ ALIGNMENTs
+   */
+  protobuf_c_boolean has_bb_size;
+  uint32_t bb_size;
+  /*
+   * All alignments between fn/bbl are included here
+   */
+  /*
+   * Represents the end of [OBJ|FUN|BBL]
+   */
+  protobuf_c_boolean has_type;
+  uint32_t type;
+  protobuf_c_boolean has_num_fixups;
+  uint32_t num_fixups;
+  protobuf_c_boolean has_bb_fallthrough;
+  protobuf_c_boolean bb_fallthrough;
+  /*
+   * section identifier for c++ mutiple sections
+   */
+  char *section_name;
+  /*
+   * update at linking when combining sections
+   */
+  protobuf_c_boolean has_offset;
+  uint32_t offset;
+  protobuf_c_boolean has_padding_size;
+  uint32_t padding_size;
+  /*
+   * assemble type: 0(normal basic block type), 1(contains inline assemble code)
+   */
+  protobuf_c_boolean has_assemble_type;
+  uint32_t assemble_type;
+};
+#define SHUFFLE_INFO__REORDER_INFO__LAYOUT_INFO__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__layout_info__descriptor) \
+    , 0, 0, 0, 0, 0, 0, 0, 0, NULL, 0, 0, 0, 0, 0, 0u }
+
+
+struct  _ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple
+{
+  ProtobufCMessage base;
+  /*
+   * UPDATE AT LINKTIME WHEN COMBINING SECTIONS
+   */
+  uint32_t offset;
+  uint32_t deref_sz;
+  protobuf_c_boolean is_rela;
+  /*
+   * c2c, c2d, d2c, d2d = (0-3)
+   */
+  protobuf_c_boolean has_type;
+  uint32_t type;
+  /*
+   * section identifier for c++ mutiple sections
+   */
+  char *section_name;
+  /*
+   * fixup has a jump table (.rodata) for pic/pie use
+   */
+  /*
+   * number of the jump table entries
+   */
+  protobuf_c_boolean has_num_jt_entries;
+  uint32_t num_jt_entries;
+  /*
+   * size of each jump table entry in byte
+   */
+  protobuf_c_boolean has_jt_entry_sz;
+  uint32_t jt_entry_sz;
+};
+#define SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__FIXUP_TUPLE__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor) \
+    , 0, 0, 0, 0, 0, NULL, 0, 0, 0, 0 }
+
+
+/*
+ * Fixup info in ELF from LLVM
+ */
+struct  _ShuffleInfo__ReorderInfo__FixupInfo
+{
+  ProtobufCMessage base;
+  size_t n_text;
+  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **text;
+  size_t n_rodata;
+  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **rodata;
+  size_t n_data;
+  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **data;
+  size_t n_datarel;
+  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **datarel;
+  size_t n_initarray;
+  ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple **initarray;
+};
+#define SHUFFLE_INFO__REORDER_INFO__FIXUP_INFO__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__fixup_info__descriptor) \
+    , 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL }
+
+
+/*
+ * Source info [generalSource(=0) | hasInlineAssembly(=1) | standaloneAssembly(=2)]
+ */
+struct  _ShuffleInfo__ReorderInfo__SourceInfo
+{
+  ProtobufCMessage base;
+  /*
+   * the src_type placeholder for linker
+   */
+  size_t n_src_type;
+  uint32_t *src_type;
+};
+#define SHUFFLE_INFO__REORDER_INFO__SOURCE_INFO__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__source_info__descriptor) \
+    , 0,NULL }
+
+
+struct  _ShuffleInfo__ReorderInfo
+{
+  ProtobufCMessage base;
+  ShuffleInfo__ReorderInfo__BinaryInfo *bin;
+  size_t n_layout;
+  ShuffleInfo__ReorderInfo__LayoutInfo **layout;
+  size_t n_fixup;
+  ShuffleInfo__ReorderInfo__FixupInfo **fixup;
+  ShuffleInfo__ReorderInfo__SourceInfo *source;
+};
+#define SHUFFLE_INFO__REORDER_INFO__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&shuffle_info__reorder_info__descriptor) \
+    , NULL, 0,NULL, 0,NULL, NULL }
+
+
+/* ShuffleInfo__ReorderInfo__BinaryInfo methods */
+void   shuffle_info__reorder_info__binary_info__init
+                     (ShuffleInfo__ReorderInfo__BinaryInfo         *message);
+/* ShuffleInfo__ReorderInfo__LayoutInfo methods */
+void   shuffle_info__reorder_info__layout_info__init
+                     (ShuffleInfo__ReorderInfo__LayoutInfo         *message);
+/* ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple methods */
+void   shuffle_info__reorder_info__fixup_info__fixup_tuple__init
+                     (ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple         *message);
+/* ShuffleInfo__ReorderInfo__FixupInfo methods */
+void   shuffle_info__reorder_info__fixup_info__init
+                     (ShuffleInfo__ReorderInfo__FixupInfo         *message);
+/* ShuffleInfo__ReorderInfo__SourceInfo methods */
+void   shuffle_info__reorder_info__source_info__init
+                     (ShuffleInfo__ReorderInfo__SourceInfo         *message);
+/* ShuffleInfo__ReorderInfo methods */
+void   shuffle_info__reorder_info__init
+                     (ShuffleInfo__ReorderInfo         *message);
+size_t shuffle_info__reorder_info__get_packed_size
+                     (const ShuffleInfo__ReorderInfo   *message);
+size_t shuffle_info__reorder_info__pack
+                     (const ShuffleInfo__ReorderInfo   *message,
+                      uint8_t             *out);
+size_t shuffle_info__reorder_info__pack_to_buffer
+                     (const ShuffleInfo__ReorderInfo   *message,
+                      ProtobufCBuffer     *buffer);
+ShuffleInfo__ReorderInfo *
+       shuffle_info__reorder_info__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   shuffle_info__reorder_info__free_unpacked
+                     (ShuffleInfo__ReorderInfo *message,
+                      ProtobufCAllocator *allocator);
+/* --- per-message closures --- */
+
+typedef void (*ShuffleInfo__ReorderInfo__BinaryInfo_Closure)
+                 (const ShuffleInfo__ReorderInfo__BinaryInfo *message,
+                  void *closure_data);
+typedef void (*ShuffleInfo__ReorderInfo__LayoutInfo_Closure)
+                 (const ShuffleInfo__ReorderInfo__LayoutInfo *message,
+                  void *closure_data);
+typedef void (*ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple_Closure)
+                 (const ShuffleInfo__ReorderInfo__FixupInfo__FixupTuple *message,
+                  void *closure_data);
+typedef void (*ShuffleInfo__ReorderInfo__FixupInfo_Closure)
+                 (const ShuffleInfo__ReorderInfo__FixupInfo *message,
+                  void *closure_data);
+typedef void (*ShuffleInfo__ReorderInfo__SourceInfo_Closure)
+                 (const ShuffleInfo__ReorderInfo__SourceInfo *message,
+                  void *closure_data);
+typedef void (*ShuffleInfo__ReorderInfo_Closure)
+                 (const ShuffleInfo__ReorderInfo *message,
+                  void *closure_data);
+
+/* --- services --- */
+
+
+/* --- descriptors --- */
+
+extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__descriptor;
+extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__binary_info__descriptor;
+extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__layout_info__descriptor;
+extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__descriptor;
+extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__fixup_info__fixup_tuple__descriptor;
+extern const ProtobufCMessageDescriptor shuffle_info__reorder_info__source_info__descriptor;
+
+PROTOBUF_C__END_DECLS
+
+
+#endif  /* PROTOBUF_C_shuffleInfo_2eproto__INCLUDED */
diff --git a/shuffleInfo.pb.cc b/shuffleInfo.pb.cc
new file mode 100644
index 0000000..dc74474
--- /dev/null
+++ b/shuffleInfo.pb.cc
@@ -0,0 +1,3372 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: shuffleInfo.proto
+
+#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
+#include "shuffleInfo.pb.h"
+
+#include <algorithm>
+
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/stubs/port.h>
+#include <google/protobuf/stubs/once.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/wire_format_lite_inl.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/generated_message_reflection.h>
+#include <google/protobuf/reflection_ops.h>
+#include <google/protobuf/wire_format.h>
+// @@protoc_insertion_point(includes)
+
+namespace ShuffleInfo {
+class ReorderInfo_BinaryInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_BinaryInfo> {};
+ReorderInfo_BinaryInfoDefaultTypeInternal _ReorderInfo_BinaryInfo_default_instance_;
+class ReorderInfo_LayoutInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_LayoutInfo> {};
+ReorderInfo_LayoutInfoDefaultTypeInternal _ReorderInfo_LayoutInfo_default_instance_;
+class ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_FixupInfo_FixupTuple> {};
+ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal _ReorderInfo_FixupInfo_FixupTuple_default_instance_;
+class ReorderInfo_FixupInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_FixupInfo> {};
+ReorderInfo_FixupInfoDefaultTypeInternal _ReorderInfo_FixupInfo_default_instance_;
+class ReorderInfo_SourceInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo_SourceInfo> {};
+ReorderInfo_SourceInfoDefaultTypeInternal _ReorderInfo_SourceInfo_default_instance_;
+class ReorderInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReorderInfo> {};
+ReorderInfoDefaultTypeInternal _ReorderInfo_default_instance_;
+
+namespace {
+
+::google::protobuf::Metadata file_level_metadata[6];
+
+}  // namespace
+
+
+const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto() GOOGLE_ATTRIBUTE_COLD;
+const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto() {
+  static const ::google::protobuf::uint32 offsets[] = {
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, _has_bits_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, _internal_metadata_),
+    ~0u,  // no _extensions_
+    ~0u,  // no _oneof_case_
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, rand_obj_offset_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, main_addr_offset_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, obj_sz_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_BinaryInfo, src_type_),
+    0,
+    1,
+    2,
+    3,
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, _has_bits_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, _internal_metadata_),
+    ~0u,  // no _extensions_
+    ~0u,  // no _oneof_case_
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, bb_size_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, type_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, num_fixups_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, bb_fallthrough_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, section_name_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_LayoutInfo, offset_),
+    1,
+    2,
+    3,
+    4,
+    0,
+    5,
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, _has_bits_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, _internal_metadata_),
+    ~0u,  // no _extensions_
+    ~0u,  // no _oneof_case_
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, offset_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, deref_sz_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, is_rela_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, type_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, section_name_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, num_jt_entries_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo_FixupTuple, jt_entry_sz_),
+    1,
+    2,
+    3,
+    4,
+    0,
+    5,
+    6,
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, _has_bits_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, _internal_metadata_),
+    ~0u,  // no _extensions_
+    ~0u,  // no _oneof_case_
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, text_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, rodata_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, data_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, datarel_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_FixupInfo, initarray_),
+    0,
+    1,
+    2,
+    3,
+    4,
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, _has_bits_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, _internal_metadata_),
+    ~0u,  // no _extensions_
+    ~0u,  // no _oneof_case_
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo_SourceInfo, src_type_),
+    0,
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, _has_bits_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, _internal_metadata_),
+    ~0u,  // no _extensions_
+    ~0u,  // no _oneof_case_
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, bin_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, layout_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, fixup_),
+    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReorderInfo, source_),
+    0,
+    2,
+    3,
+    1,
+  };
+  return offsets;
+}
+
+static const ::google::protobuf::internal::MigrationSchema schemas[] = {
+  { 0, 8, sizeof(ReorderInfo_BinaryInfo)},
+  { 12, 22, sizeof(ReorderInfo_LayoutInfo)},
+  { 28, 39, sizeof(ReorderInfo_FixupInfo_FixupTuple)},
+  { 46, 55, sizeof(ReorderInfo_FixupInfo)},
+  { 60, 65, sizeof(ReorderInfo_SourceInfo)},
+  { 66, 74, sizeof(ReorderInfo)},
+};
+
+static const ::google::protobuf::internal::DefaultInstanceData file_default_instances[] = {
+  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_BinaryInfo_default_instance_), NULL},
+  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_LayoutInfo_default_instance_), NULL},
+  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_FixupInfo_FixupTuple_default_instance_), NULL},
+  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_FixupInfo_default_instance_), NULL},
+  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_SourceInfo_default_instance_), NULL},
+  {reinterpret_cast<const ::google::protobuf::Message*>(&_ReorderInfo_default_instance_), NULL},
+};
+
+namespace {
+
+void protobuf_AssignDescriptors() {
+  protobuf_AddDesc_shuffleInfo_2eproto();
+  ::google::protobuf::MessageFactory* factory = NULL;
+  AssignDescriptors(
+      "shuffleInfo.proto", schemas, file_default_instances, protobuf_Offsets_shuffleInfo_2eproto(), factory,
+      file_level_metadata, NULL, NULL);
+}
+
+void protobuf_AssignDescriptorsOnce() {
+  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
+  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
+}
+
+void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
+void protobuf_RegisterTypes(const ::std::string&) {
+  protobuf_AssignDescriptorsOnce();
+  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 6);
+}
+
+}  // namespace
+
+void protobuf_ShutdownFile_shuffleInfo_2eproto() {
+  _ReorderInfo_BinaryInfo_default_instance_.Shutdown();
+  delete file_level_metadata[0].reflection;
+  _ReorderInfo_LayoutInfo_default_instance_.Shutdown();
+  delete file_level_metadata[1].reflection;
+  _ReorderInfo_FixupInfo_FixupTuple_default_instance_.Shutdown();
+  delete file_level_metadata[2].reflection;
+  _ReorderInfo_FixupInfo_default_instance_.Shutdown();
+  delete file_level_metadata[3].reflection;
+  _ReorderInfo_SourceInfo_default_instance_.Shutdown();
+  delete file_level_metadata[4].reflection;
+  _ReorderInfo_default_instance_.Shutdown();
+  delete file_level_metadata[5].reflection;
+}
+
+void protobuf_InitDefaults_shuffleInfo_2eproto_impl() {
+  GOOGLE_PROTOBUF_VERIFY_VERSION;
+
+  ::google::protobuf::internal::InitProtobufDefaults();
+  _ReorderInfo_BinaryInfo_default_instance_.DefaultConstruct();
+  _ReorderInfo_LayoutInfo_default_instance_.DefaultConstruct();
+  _ReorderInfo_FixupInfo_FixupTuple_default_instance_.DefaultConstruct();
+  _ReorderInfo_FixupInfo_default_instance_.DefaultConstruct();
+  _ReorderInfo_SourceInfo_default_instance_.DefaultConstruct();
+  _ReorderInfo_default_instance_.DefaultConstruct();
+  _ReorderInfo_default_instance_.get_mutable()->bin_ = const_cast< ::ShuffleInfo::ReorderInfo_BinaryInfo*>(
+      ::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance());
+  _ReorderInfo_default_instance_.get_mutable()->source_ = const_cast< ::ShuffleInfo::ReorderInfo_SourceInfo*>(
+      ::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance());
+}
+
+void protobuf_InitDefaults_shuffleInfo_2eproto() {
+  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
+  ::google::protobuf::GoogleOnceInit(&once, &protobuf_InitDefaults_shuffleInfo_2eproto_impl);
+}
+void protobuf_AddDesc_shuffleInfo_2eproto_impl() {
+  protobuf_InitDefaults_shuffleInfo_2eproto();
+  static const char descriptor[] = {
+      "\n\021shuffleInfo.proto\022\013ShuffleInfo\"\272\007\n\013Reo"
+      "rderInfo\0220\n\003bin\030\001 \001(\0132#.ShuffleInfo.Reor"
+      "derInfo.BinaryInfo\0223\n\006layout\030\002 \003(\0132#.Shu"
+      "ffleInfo.ReorderInfo.LayoutInfo\0221\n\005fixup"
+      "\030\003 \003(\0132\".ShuffleInfo.ReorderInfo.FixupIn"
+      "fo\0223\n\006source\030\004 \001(\0132#.ShuffleInfo.Reorder"
+      "Info.SourceInfo\032a\n\nBinaryInfo\022\027\n\017rand_ob"
+      "j_offset\030\001 \001(\r\022\030\n\020main_addr_offset\030\002 \001(\r"
+      "\022\016\n\006obj_sz\030\003 \001(\r\022\020\n\010src_type\030\004 \001(\r\032}\n\nLa"
+      "youtInfo\022\017\n\007bb_size\030\001 \001(\r\022\014\n\004type\030\002 \001(\r\022"
+      "\022\n\nnum_fixups\030\003 \001(\r\022\026\n\016bb_fallthrough\030\004 "
+      "\001(\010\022\024\n\014section_name\030\005 \001(\t\022\016\n\006offset\030\006 \001("
+      "\r\032\331\003\n\tFixupInfo\022;\n\004text\030\001 \003(\0132-.ShuffleI"
+      "nfo.ReorderInfo.FixupInfo.FixupTuple\022=\n\006"
+      "rodata\030\002 \003(\0132-.ShuffleInfo.ReorderInfo.F"
+      "ixupInfo.FixupTuple\022;\n\004data\030\003 \003(\0132-.Shuf"
+      "fleInfo.ReorderInfo.FixupInfo.FixupTuple"
+      "\022>\n\007datarel\030\004 \003(\0132-.ShuffleInfo.ReorderI"
+      "nfo.FixupInfo.FixupTuple\022@\n\tinitarray\030\005 "
+      "\003(\0132-.ShuffleInfo.ReorderInfo.FixupInfo."
+      "FixupTuple\032\220\001\n\nFixupTuple\022\016\n\006offset\030\001 \002("
+      "\r\022\020\n\010deref_sz\030\002 \002(\r\022\017\n\007is_rela\030\003 \002(\010\022\014\n\004"
+      "type\030\004 \001(\r\022\024\n\014section_name\030\005 \001(\t\022\026\n\016num_"
+      "jt_entries\030\006 \001(\r\022\023\n\013jt_entry_sz\030\007 \001(\r\032\036\n"
+      "\nSourceInfo\022\020\n\010src_type\030\001 \003(\r"
+  };
+  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
+      descriptor, 989);
+  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
+    "shuffleInfo.proto", &protobuf_RegisterTypes);
+  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_shuffleInfo_2eproto);
+}
+
+GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_shuffleInfo_2eproto_once_);
+void protobuf_AddDesc_shuffleInfo_2eproto() {
+  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_shuffleInfo_2eproto_once_,
+                 &protobuf_AddDesc_shuffleInfo_2eproto_impl);
+}
+// Force AddDescriptors() to be called at static initialization time.
+struct StaticDescriptorInitializer_shuffleInfo_2eproto {
+  StaticDescriptorInitializer_shuffleInfo_2eproto() {
+    protobuf_AddDesc_shuffleInfo_2eproto();
+  }
+} static_descriptor_initializer_shuffleInfo_2eproto_;
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int ReorderInfo_BinaryInfo::kRandObjOffsetFieldNumber;
+const int ReorderInfo_BinaryInfo::kMainAddrOffsetFieldNumber;
+const int ReorderInfo_BinaryInfo::kObjSzFieldNumber;
+const int ReorderInfo_BinaryInfo::kSrcTypeFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+ReorderInfo_BinaryInfo::ReorderInfo_BinaryInfo()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_InitDefaults_shuffleInfo_2eproto();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.BinaryInfo)
+}
+ReorderInfo_BinaryInfo::ReorderInfo_BinaryInfo(const ReorderInfo_BinaryInfo& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::memcpy(&rand_obj_offset_, &from.rand_obj_offset_,
+    reinterpret_cast<char*>(&src_type_) -
+    reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
+  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.BinaryInfo)
+}
+
+void ReorderInfo_BinaryInfo::SharedCtor() {
+  _cached_size_ = 0;
+  ::memset(&rand_obj_offset_, 0, reinterpret_cast<char*>(&src_type_) -
+    reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
+}
+
+ReorderInfo_BinaryInfo::~ReorderInfo_BinaryInfo() {
+  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.BinaryInfo)
+  SharedDtor();
+}
+
+void ReorderInfo_BinaryInfo::SharedDtor() {
+}
+
+void ReorderInfo_BinaryInfo::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* ReorderInfo_BinaryInfo::descriptor() {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[0].descriptor;
+}
+
+const ReorderInfo_BinaryInfo& ReorderInfo_BinaryInfo::default_instance() {
+  protobuf_InitDefaults_shuffleInfo_2eproto();
+  return *internal_default_instance();
+}
+
+ReorderInfo_BinaryInfo* ReorderInfo_BinaryInfo::New(::google::protobuf::Arena* arena) const {
+  ReorderInfo_BinaryInfo* n = new ReorderInfo_BinaryInfo;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void ReorderInfo_BinaryInfo::Clear() {
+// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  if (_has_bits_[0 / 32] & 15u) {
+    ::memset(&rand_obj_offset_, 0, reinterpret_cast<char*>(&src_type_) -
+      reinterpret_cast<char*>(&rand_obj_offset_) + sizeof(src_type_));
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool ReorderInfo_BinaryInfo::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional uint32 rand_obj_offset = 1;
+      case 1: {
+        if (tag == 8u) {
+          set_has_rand_obj_offset();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &rand_obj_offset_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 main_addr_offset = 2;
+      case 2: {
+        if (tag == 16u) {
+          set_has_main_addr_offset();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &main_addr_offset_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 obj_sz = 3;
+      case 3: {
+        if (tag == 24u) {
+          set_has_obj_sz();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &obj_sz_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 src_type = 4;
+      case 4: {
+        if (tag == 32u) {
+          set_has_src_type();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &src_type_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.BinaryInfo)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.BinaryInfo)
+  return false;
+#undef DO_
+}
+
+void ReorderInfo_BinaryInfo::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  // optional uint32 rand_obj_offset = 1;
+  if (has_rand_obj_offset()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rand_obj_offset(), output);
+  }
+
+  // optional uint32 main_addr_offset = 2;
+  if (has_main_addr_offset()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->main_addr_offset(), output);
+  }
+
+  // optional uint32 obj_sz = 3;
+  if (has_obj_sz()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->obj_sz(), output);
+  }
+
+  // optional uint32 src_type = 4;
+  if (has_src_type()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->src_type(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.BinaryInfo)
+}
+
+::google::protobuf::uint8* ReorderInfo_BinaryInfo::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  (void)deterministic; // Unused
+  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  // optional uint32 rand_obj_offset = 1;
+  if (has_rand_obj_offset()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->rand_obj_offset(), target);
+  }
+
+  // optional uint32 main_addr_offset = 2;
+  if (has_main_addr_offset()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->main_addr_offset(), target);
+  }
+
+  // optional uint32 obj_sz = 3;
+  if (has_obj_sz()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->obj_sz(), target);
+  }
+
+  // optional uint32 src_type = 4;
+  if (has_src_type()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->src_type(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.BinaryInfo)
+  return target;
+}
+
+size_t ReorderInfo_BinaryInfo::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 15u) {
+    // optional uint32 rand_obj_offset = 1;
+    if (has_rand_obj_offset()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->rand_obj_offset());
+    }
+
+    // optional uint32 main_addr_offset = 2;
+    if (has_main_addr_offset()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->main_addr_offset());
+    }
+
+    // optional uint32 obj_sz = 3;
+    if (has_obj_sz()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->obj_sz());
+    }
+
+    // optional uint32 src_type = 4;
+    if (has_src_type()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->src_type());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void ReorderInfo_BinaryInfo::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  const ReorderInfo_BinaryInfo* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_BinaryInfo>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.BinaryInfo)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.BinaryInfo)
+    MergeFrom(*source);
+  }
+}
+
+void ReorderInfo_BinaryInfo::MergeFrom(const ReorderInfo_BinaryInfo& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  if (from._has_bits_[0 / 32] & 15u) {
+    if (from.has_rand_obj_offset()) {
+      set_rand_obj_offset(from.rand_obj_offset());
+    }
+    if (from.has_main_addr_offset()) {
+      set_main_addr_offset(from.main_addr_offset());
+    }
+    if (from.has_obj_sz()) {
+      set_obj_sz(from.obj_sz());
+    }
+    if (from.has_src_type()) {
+      set_src_type(from.src_type());
+    }
+  }
+}
+
+void ReorderInfo_BinaryInfo::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void ReorderInfo_BinaryInfo::CopyFrom(const ReorderInfo_BinaryInfo& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.BinaryInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ReorderInfo_BinaryInfo::IsInitialized() const {
+  return true;
+}
+
+void ReorderInfo_BinaryInfo::Swap(ReorderInfo_BinaryInfo* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void ReorderInfo_BinaryInfo::InternalSwap(ReorderInfo_BinaryInfo* other) {
+  std::swap(rand_obj_offset_, other->rand_obj_offset_);
+  std::swap(main_addr_offset_, other->main_addr_offset_);
+  std::swap(obj_sz_, other->obj_sz_);
+  std::swap(src_type_, other->src_type_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata ReorderInfo_BinaryInfo::GetMetadata() const {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[0];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// ReorderInfo_BinaryInfo
+
+// optional uint32 rand_obj_offset = 1;
+bool ReorderInfo_BinaryInfo::has_rand_obj_offset() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void ReorderInfo_BinaryInfo::set_has_rand_obj_offset() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void ReorderInfo_BinaryInfo::clear_has_rand_obj_offset() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void ReorderInfo_BinaryInfo::clear_rand_obj_offset() {
+  rand_obj_offset_ = 0u;
+  clear_has_rand_obj_offset();
+}
+::google::protobuf::uint32 ReorderInfo_BinaryInfo::rand_obj_offset() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
+  return rand_obj_offset_;
+}
+void ReorderInfo_BinaryInfo::set_rand_obj_offset(::google::protobuf::uint32 value) {
+  set_has_rand_obj_offset();
+  rand_obj_offset_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
+}
+
+// optional uint32 main_addr_offset = 2;
+bool ReorderInfo_BinaryInfo::has_main_addr_offset() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void ReorderInfo_BinaryInfo::set_has_main_addr_offset() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void ReorderInfo_BinaryInfo::clear_has_main_addr_offset() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void ReorderInfo_BinaryInfo::clear_main_addr_offset() {
+  main_addr_offset_ = 0u;
+  clear_has_main_addr_offset();
+}
+::google::protobuf::uint32 ReorderInfo_BinaryInfo::main_addr_offset() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
+  return main_addr_offset_;
+}
+void ReorderInfo_BinaryInfo::set_main_addr_offset(::google::protobuf::uint32 value) {
+  set_has_main_addr_offset();
+  main_addr_offset_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
+}
+
+// optional uint32 obj_sz = 3;
+bool ReorderInfo_BinaryInfo::has_obj_sz() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void ReorderInfo_BinaryInfo::set_has_obj_sz() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void ReorderInfo_BinaryInfo::clear_has_obj_sz() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void ReorderInfo_BinaryInfo::clear_obj_sz() {
+  obj_sz_ = 0u;
+  clear_has_obj_sz();
+}
+::google::protobuf::uint32 ReorderInfo_BinaryInfo::obj_sz() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
+  return obj_sz_;
+}
+void ReorderInfo_BinaryInfo::set_obj_sz(::google::protobuf::uint32 value) {
+  set_has_obj_sz();
+  obj_sz_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
+}
+
+// optional uint32 src_type = 4;
+bool ReorderInfo_BinaryInfo::has_src_type() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void ReorderInfo_BinaryInfo::set_has_src_type() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void ReorderInfo_BinaryInfo::clear_has_src_type() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void ReorderInfo_BinaryInfo::clear_src_type() {
+  src_type_ = 0u;
+  clear_has_src_type();
+}
+::google::protobuf::uint32 ReorderInfo_BinaryInfo::src_type() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
+  return src_type_;
+}
+void ReorderInfo_BinaryInfo::set_src_type(::google::protobuf::uint32 value) {
+  set_has_src_type();
+  src_type_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int ReorderInfo_LayoutInfo::kBbSizeFieldNumber;
+const int ReorderInfo_LayoutInfo::kTypeFieldNumber;
+const int ReorderInfo_LayoutInfo::kNumFixupsFieldNumber;
+const int ReorderInfo_LayoutInfo::kBbFallthroughFieldNumber;
+const int ReorderInfo_LayoutInfo::kSectionNameFieldNumber;
+const int ReorderInfo_LayoutInfo::kOffsetFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+ReorderInfo_LayoutInfo::ReorderInfo_LayoutInfo()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_InitDefaults_shuffleInfo_2eproto();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.LayoutInfo)
+}
+ReorderInfo_LayoutInfo::ReorderInfo_LayoutInfo(const ReorderInfo_LayoutInfo& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_section_name()) {
+    section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
+  }
+  ::memcpy(&bb_size_, &from.bb_size_,
+    reinterpret_cast<char*>(&offset_) -
+    reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
+  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.LayoutInfo)
+}
+
+void ReorderInfo_LayoutInfo::SharedCtor() {
+  _cached_size_ = 0;
+  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ::memset(&bb_size_, 0, reinterpret_cast<char*>(&offset_) -
+    reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
+}
+
+ReorderInfo_LayoutInfo::~ReorderInfo_LayoutInfo() {
+  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.LayoutInfo)
+  SharedDtor();
+}
+
+void ReorderInfo_LayoutInfo::SharedDtor() {
+  section_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+
+void ReorderInfo_LayoutInfo::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* ReorderInfo_LayoutInfo::descriptor() {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[1].descriptor;
+}
+
+const ReorderInfo_LayoutInfo& ReorderInfo_LayoutInfo::default_instance() {
+  protobuf_InitDefaults_shuffleInfo_2eproto();
+  return *internal_default_instance();
+}
+
+ReorderInfo_LayoutInfo* ReorderInfo_LayoutInfo::New(::google::protobuf::Arena* arena) const {
+  ReorderInfo_LayoutInfo* n = new ReorderInfo_LayoutInfo;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void ReorderInfo_LayoutInfo::Clear() {
+// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  if (has_section_name()) {
+    GOOGLE_DCHECK(!section_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+    (*section_name_.UnsafeRawStringPointer())->clear();
+  }
+  if (_has_bits_[0 / 32] & 62u) {
+    ::memset(&bb_size_, 0, reinterpret_cast<char*>(&offset_) -
+      reinterpret_cast<char*>(&bb_size_) + sizeof(offset_));
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool ReorderInfo_LayoutInfo::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional uint32 bb_size = 1;
+      case 1: {
+        if (tag == 8u) {
+          set_has_bb_size();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &bb_size_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 type = 2;
+      case 2: {
+        if (tag == 16u) {
+          set_has_type();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &type_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 num_fixups = 3;
+      case 3: {
+        if (tag == 24u) {
+          set_has_num_fixups();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &num_fixups_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bool bb_fallthrough = 4;
+      case 4: {
+        if (tag == 32u) {
+          set_has_bb_fallthrough();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
+                 input, &bb_fallthrough_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional string section_name = 5;
+      case 5: {
+        if (tag == 42u) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
+                input, this->mutable_section_name()));
+          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
+            this->section_name().data(), this->section_name().length(),
+            ::google::protobuf::internal::WireFormat::PARSE,
+            "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 offset = 6;
+      case 6: {
+        if (tag == 48u) {
+          set_has_offset();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &offset_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.LayoutInfo)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.LayoutInfo)
+  return false;
+#undef DO_
+}
+
+void ReorderInfo_LayoutInfo::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  // optional uint32 bb_size = 1;
+  if (has_bb_size()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->bb_size(), output);
+  }
+
+  // optional uint32 type = 2;
+  if (has_type()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
+  }
+
+  // optional uint32 num_fixups = 3;
+  if (has_num_fixups()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->num_fixups(), output);
+  }
+
+  // optional bool bb_fallthrough = 4;
+  if (has_bb_fallthrough()) {
+    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->bb_fallthrough(), output);
+  }
+
+  // optional string section_name = 5;
+  if (has_section_name()) {
+    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
+      this->section_name().data(), this->section_name().length(),
+      ::google::protobuf::internal::WireFormat::SERIALIZE,
+      "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
+    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
+      5, this->section_name(), output);
+  }
+
+  // optional uint32 offset = 6;
+  if (has_offset()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->offset(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.LayoutInfo)
+}
+
+::google::protobuf::uint8* ReorderInfo_LayoutInfo::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  (void)deterministic; // Unused
+  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  // optional uint32 bb_size = 1;
+  if (has_bb_size()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->bb_size(), target);
+  }
+
+  // optional uint32 type = 2;
+  if (has_type()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->type(), target);
+  }
+
+  // optional uint32 num_fixups = 3;
+  if (has_num_fixups()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->num_fixups(), target);
+  }
+
+  // optional bool bb_fallthrough = 4;
+  if (has_bb_fallthrough()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->bb_fallthrough(), target);
+  }
+
+  // optional string section_name = 5;
+  if (has_section_name()) {
+    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
+      this->section_name().data(), this->section_name().length(),
+      ::google::protobuf::internal::WireFormat::SERIALIZE,
+      "ShuffleInfo.ReorderInfo.LayoutInfo.section_name");
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
+        5, this->section_name(), target);
+  }
+
+  // optional uint32 offset = 6;
+  if (has_offset()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->offset(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.LayoutInfo)
+  return target;
+}
+
+size_t ReorderInfo_LayoutInfo::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 63u) {
+    // optional string section_name = 5;
+    if (has_section_name()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::StringSize(
+          this->section_name());
+    }
+
+    // optional uint32 bb_size = 1;
+    if (has_bb_size()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->bb_size());
+    }
+
+    // optional uint32 type = 2;
+    if (has_type()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->type());
+    }
+
+    // optional uint32 num_fixups = 3;
+    if (has_num_fixups()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->num_fixups());
+    }
+
+    // optional bool bb_fallthrough = 4;
+    if (has_bb_fallthrough()) {
+      total_size += 1 + 1;
+    }
+
+    // optional uint32 offset = 6;
+    if (has_offset()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->offset());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void ReorderInfo_LayoutInfo::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  const ReorderInfo_LayoutInfo* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_LayoutInfo>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.LayoutInfo)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.LayoutInfo)
+    MergeFrom(*source);
+  }
+}
+
+void ReorderInfo_LayoutInfo::MergeFrom(const ReorderInfo_LayoutInfo& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  if (from._has_bits_[0 / 32] & 63u) {
+    if (from.has_section_name()) {
+      set_has_section_name();
+      section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
+    }
+    if (from.has_bb_size()) {
+      set_bb_size(from.bb_size());
+    }
+    if (from.has_type()) {
+      set_type(from.type());
+    }
+    if (from.has_num_fixups()) {
+      set_num_fixups(from.num_fixups());
+    }
+    if (from.has_bb_fallthrough()) {
+      set_bb_fallthrough(from.bb_fallthrough());
+    }
+    if (from.has_offset()) {
+      set_offset(from.offset());
+    }
+  }
+}
+
+void ReorderInfo_LayoutInfo::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void ReorderInfo_LayoutInfo::CopyFrom(const ReorderInfo_LayoutInfo& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.LayoutInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ReorderInfo_LayoutInfo::IsInitialized() const {
+  return true;
+}
+
+void ReorderInfo_LayoutInfo::Swap(ReorderInfo_LayoutInfo* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void ReorderInfo_LayoutInfo::InternalSwap(ReorderInfo_LayoutInfo* other) {
+  section_name_.Swap(&other->section_name_);
+  std::swap(bb_size_, other->bb_size_);
+  std::swap(type_, other->type_);
+  std::swap(num_fixups_, other->num_fixups_);
+  std::swap(bb_fallthrough_, other->bb_fallthrough_);
+  std::swap(offset_, other->offset_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata ReorderInfo_LayoutInfo::GetMetadata() const {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[1];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// ReorderInfo_LayoutInfo
+
+// optional uint32 bb_size = 1;
+bool ReorderInfo_LayoutInfo::has_bb_size() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void ReorderInfo_LayoutInfo::set_has_bb_size() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void ReorderInfo_LayoutInfo::clear_has_bb_size() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void ReorderInfo_LayoutInfo::clear_bb_size() {
+  bb_size_ = 0u;
+  clear_has_bb_size();
+}
+::google::protobuf::uint32 ReorderInfo_LayoutInfo::bb_size() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
+  return bb_size_;
+}
+void ReorderInfo_LayoutInfo::set_bb_size(::google::protobuf::uint32 value) {
+  set_has_bb_size();
+  bb_size_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
+}
+
+// optional uint32 type = 2;
+bool ReorderInfo_LayoutInfo::has_type() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void ReorderInfo_LayoutInfo::set_has_type() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void ReorderInfo_LayoutInfo::clear_has_type() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void ReorderInfo_LayoutInfo::clear_type() {
+  type_ = 0u;
+  clear_has_type();
+}
+::google::protobuf::uint32 ReorderInfo_LayoutInfo::type() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.type)
+  return type_;
+}
+void ReorderInfo_LayoutInfo::set_type(::google::protobuf::uint32 value) {
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.type)
+}
+
+// optional uint32 num_fixups = 3;
+bool ReorderInfo_LayoutInfo::has_num_fixups() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void ReorderInfo_LayoutInfo::set_has_num_fixups() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void ReorderInfo_LayoutInfo::clear_has_num_fixups() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void ReorderInfo_LayoutInfo::clear_num_fixups() {
+  num_fixups_ = 0u;
+  clear_has_num_fixups();
+}
+::google::protobuf::uint32 ReorderInfo_LayoutInfo::num_fixups() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
+  return num_fixups_;
+}
+void ReorderInfo_LayoutInfo::set_num_fixups(::google::protobuf::uint32 value) {
+  set_has_num_fixups();
+  num_fixups_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
+}
+
+// optional bool bb_fallthrough = 4;
+bool ReorderInfo_LayoutInfo::has_bb_fallthrough() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+void ReorderInfo_LayoutInfo::set_has_bb_fallthrough() {
+  _has_bits_[0] |= 0x00000010u;
+}
+void ReorderInfo_LayoutInfo::clear_has_bb_fallthrough() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+void ReorderInfo_LayoutInfo::clear_bb_fallthrough() {
+  bb_fallthrough_ = false;
+  clear_has_bb_fallthrough();
+}
+bool ReorderInfo_LayoutInfo::bb_fallthrough() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
+  return bb_fallthrough_;
+}
+void ReorderInfo_LayoutInfo::set_bb_fallthrough(bool value) {
+  set_has_bb_fallthrough();
+  bb_fallthrough_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
+}
+
+// optional string section_name = 5;
+bool ReorderInfo_LayoutInfo::has_section_name() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void ReorderInfo_LayoutInfo::set_has_section_name() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void ReorderInfo_LayoutInfo::clear_has_section_name() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void ReorderInfo_LayoutInfo::clear_section_name() {
+  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_section_name();
+}
+const ::std::string& ReorderInfo_LayoutInfo::section_name() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+  return section_name_.GetNoArena();
+}
+void ReorderInfo_LayoutInfo::set_section_name(const ::std::string& value) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+#if LANG_CXX11
+void ReorderInfo_LayoutInfo::set_section_name(::std::string&& value) {
+  set_has_section_name();
+  section_name_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+#endif
+void ReorderInfo_LayoutInfo::set_section_name(const char* value) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+void ReorderInfo_LayoutInfo::set_section_name(const char* value, size_t size) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+::std::string* ReorderInfo_LayoutInfo::mutable_section_name() {
+  set_has_section_name();
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* ReorderInfo_LayoutInfo::release_section_name() {
+  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+  clear_has_section_name();
+  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void ReorderInfo_LayoutInfo::set_allocated_section_name(::std::string* section_name) {
+  if (section_name != NULL) {
+    set_has_section_name();
+  } else {
+    clear_has_section_name();
+  }
+  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
+  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+
+// optional uint32 offset = 6;
+bool ReorderInfo_LayoutInfo::has_offset() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+void ReorderInfo_LayoutInfo::set_has_offset() {
+  _has_bits_[0] |= 0x00000020u;
+}
+void ReorderInfo_LayoutInfo::clear_has_offset() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+void ReorderInfo_LayoutInfo::clear_offset() {
+  offset_ = 0u;
+  clear_has_offset();
+}
+::google::protobuf::uint32 ReorderInfo_LayoutInfo::offset() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
+  return offset_;
+}
+void ReorderInfo_LayoutInfo::set_offset(::google::protobuf::uint32 value) {
+  set_has_offset();
+  offset_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int ReorderInfo_FixupInfo_FixupTuple::kOffsetFieldNumber;
+const int ReorderInfo_FixupInfo_FixupTuple::kDerefSzFieldNumber;
+const int ReorderInfo_FixupInfo_FixupTuple::kIsRelaFieldNumber;
+const int ReorderInfo_FixupInfo_FixupTuple::kTypeFieldNumber;
+const int ReorderInfo_FixupInfo_FixupTuple::kSectionNameFieldNumber;
+const int ReorderInfo_FixupInfo_FixupTuple::kNumJtEntriesFieldNumber;
+const int ReorderInfo_FixupInfo_FixupTuple::kJtEntrySzFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+ReorderInfo_FixupInfo_FixupTuple::ReorderInfo_FixupInfo_FixupTuple()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_InitDefaults_shuffleInfo_2eproto();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+}
+ReorderInfo_FixupInfo_FixupTuple::ReorderInfo_FixupInfo_FixupTuple(const ReorderInfo_FixupInfo_FixupTuple& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_section_name()) {
+    section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
+  }
+  ::memcpy(&offset_, &from.offset_,
+    reinterpret_cast<char*>(&jt_entry_sz_) -
+    reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
+  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::SharedCtor() {
+  _cached_size_ = 0;
+  section_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ::memset(&offset_, 0, reinterpret_cast<char*>(&jt_entry_sz_) -
+    reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
+}
+
+ReorderInfo_FixupInfo_FixupTuple::~ReorderInfo_FixupInfo_FixupTuple() {
+  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  SharedDtor();
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::SharedDtor() {
+  section_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* ReorderInfo_FixupInfo_FixupTuple::descriptor() {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[2].descriptor;
+}
+
+const ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo_FixupTuple::default_instance() {
+  protobuf_InitDefaults_shuffleInfo_2eproto();
+  return *internal_default_instance();
+}
+
+ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo_FixupTuple::New(::google::protobuf::Arena* arena) const {
+  ReorderInfo_FixupInfo_FixupTuple* n = new ReorderInfo_FixupInfo_FixupTuple;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::Clear() {
+// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  if (has_section_name()) {
+    GOOGLE_DCHECK(!section_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+    (*section_name_.UnsafeRawStringPointer())->clear();
+  }
+  if (_has_bits_[0 / 32] & 126u) {
+    ::memset(&offset_, 0, reinterpret_cast<char*>(&jt_entry_sz_) -
+      reinterpret_cast<char*>(&offset_) + sizeof(jt_entry_sz_));
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool ReorderInfo_FixupInfo_FixupTuple::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // required uint32 offset = 1;
+      case 1: {
+        if (tag == 8u) {
+          set_has_offset();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &offset_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // required uint32 deref_sz = 2;
+      case 2: {
+        if (tag == 16u) {
+          set_has_deref_sz();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &deref_sz_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // required bool is_rela = 3;
+      case 3: {
+        if (tag == 24u) {
+          set_has_is_rela();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
+                 input, &is_rela_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 type = 4;
+      case 4: {
+        if (tag == 32u) {
+          set_has_type();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &type_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional string section_name = 5;
+      case 5: {
+        if (tag == 42u) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
+                input, this->mutable_section_name()));
+          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
+            this->section_name().data(), this->section_name().length(),
+            ::google::protobuf::internal::WireFormat::PARSE,
+            "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 num_jt_entries = 6;
+      case 6: {
+        if (tag == 48u) {
+          set_has_num_jt_entries();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &num_jt_entries_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 jt_entry_sz = 7;
+      case 7: {
+        if (tag == 56u) {
+          set_has_jt_entry_sz();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &jt_entry_sz_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  return false;
+#undef DO_
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  // required uint32 offset = 1;
+  if (has_offset()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->offset(), output);
+  }
+
+  // required uint32 deref_sz = 2;
+  if (has_deref_sz()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->deref_sz(), output);
+  }
+
+  // required bool is_rela = 3;
+  if (has_is_rela()) {
+    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_rela(), output);
+  }
+
+  // optional uint32 type = 4;
+  if (has_type()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->type(), output);
+  }
+
+  // optional string section_name = 5;
+  if (has_section_name()) {
+    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
+      this->section_name().data(), this->section_name().length(),
+      ::google::protobuf::internal::WireFormat::SERIALIZE,
+      "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
+    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
+      5, this->section_name(), output);
+  }
+
+  // optional uint32 num_jt_entries = 6;
+  if (has_num_jt_entries()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->num_jt_entries(), output);
+  }
+
+  // optional uint32 jt_entry_sz = 7;
+  if (has_jt_entry_sz()) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->jt_entry_sz(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+}
+
+::google::protobuf::uint8* ReorderInfo_FixupInfo_FixupTuple::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  (void)deterministic; // Unused
+  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  // required uint32 offset = 1;
+  if (has_offset()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->offset(), target);
+  }
+
+  // required uint32 deref_sz = 2;
+  if (has_deref_sz()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->deref_sz(), target);
+  }
+
+  // required bool is_rela = 3;
+  if (has_is_rela()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->is_rela(), target);
+  }
+
+  // optional uint32 type = 4;
+  if (has_type()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->type(), target);
+  }
+
+  // optional string section_name = 5;
+  if (has_section_name()) {
+    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
+      this->section_name().data(), this->section_name().length(),
+      ::google::protobuf::internal::WireFormat::SERIALIZE,
+      "ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name");
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
+        5, this->section_name(), target);
+  }
+
+  // optional uint32 num_jt_entries = 6;
+  if (has_num_jt_entries()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->num_jt_entries(), target);
+  }
+
+  // optional uint32 jt_entry_sz = 7;
+  if (has_jt_entry_sz()) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->jt_entry_sz(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  return target;
+}
+
+size_t ReorderInfo_FixupInfo_FixupTuple::RequiredFieldsByteSizeFallback() const {
+// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  size_t total_size = 0;
+
+  if (has_offset()) {
+    // required uint32 offset = 1;
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::UInt32Size(
+        this->offset());
+  }
+
+  if (has_deref_sz()) {
+    // required uint32 deref_sz = 2;
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::UInt32Size(
+        this->deref_sz());
+  }
+
+  if (has_is_rela()) {
+    // required bool is_rela = 3;
+    total_size += 1 + 1;
+  }
+
+  return total_size;
+}
+size_t ReorderInfo_FixupInfo_FixupTuple::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
+    // required uint32 offset = 1;
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::UInt32Size(
+        this->offset());
+
+    // required uint32 deref_sz = 2;
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::UInt32Size(
+        this->deref_sz());
+
+    // required bool is_rela = 3;
+    total_size += 1 + 1;
+
+  } else {
+    total_size += RequiredFieldsByteSizeFallback();
+  }
+  // optional string section_name = 5;
+  if (has_section_name()) {
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::StringSize(
+        this->section_name());
+  }
+
+  if (_has_bits_[0 / 32] & 112u) {
+    // optional uint32 type = 4;
+    if (has_type()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->type());
+    }
+
+    // optional uint32 num_jt_entries = 6;
+    if (has_num_jt_entries()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->num_jt_entries());
+    }
+
+    // optional uint32 jt_entry_sz = 7;
+    if (has_jt_entry_sz()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->jt_entry_sz());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  GOOGLE_DCHECK_NE(&from, this);
+  const ReorderInfo_FixupInfo_FixupTuple* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_FixupInfo_FixupTuple>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+    MergeFrom(*source);
+  }
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::MergeFrom(const ReorderInfo_FixupInfo_FixupTuple& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  if (from._has_bits_[0 / 32] & 127u) {
+    if (from.has_section_name()) {
+      set_has_section_name();
+      section_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.section_name_);
+    }
+    if (from.has_offset()) {
+      set_offset(from.offset());
+    }
+    if (from.has_deref_sz()) {
+      set_deref_sz(from.deref_sz());
+    }
+    if (from.has_is_rela()) {
+      set_is_rela(from.is_rela());
+    }
+    if (from.has_type()) {
+      set_type(from.type());
+    }
+    if (from.has_num_jt_entries()) {
+      set_num_jt_entries(from.num_jt_entries());
+    }
+    if (from.has_jt_entry_sz()) {
+      set_jt_entry_sz(from.jt_entry_sz());
+    }
+  }
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::CopyFrom(const ReorderInfo_FixupInfo_FixupTuple& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ReorderInfo_FixupInfo_FixupTuple::IsInitialized() const {
+  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;
+  return true;
+}
+
+void ReorderInfo_FixupInfo_FixupTuple::Swap(ReorderInfo_FixupInfo_FixupTuple* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void ReorderInfo_FixupInfo_FixupTuple::InternalSwap(ReorderInfo_FixupInfo_FixupTuple* other) {
+  section_name_.Swap(&other->section_name_);
+  std::swap(offset_, other->offset_);
+  std::swap(deref_sz_, other->deref_sz_);
+  std::swap(is_rela_, other->is_rela_);
+  std::swap(type_, other->type_);
+  std::swap(num_jt_entries_, other->num_jt_entries_);
+  std::swap(jt_entry_sz_, other->jt_entry_sz_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata ReorderInfo_FixupInfo_FixupTuple::GetMetadata() const {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[2];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// ReorderInfo_FixupInfo_FixupTuple
+
+// required uint32 offset = 1;
+bool ReorderInfo_FixupInfo_FixupTuple::has_offset() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_has_offset() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_has_offset() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_offset() {
+  offset_ = 0u;
+  clear_has_offset();
+}
+::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::offset() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
+  return offset_;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_offset(::google::protobuf::uint32 value) {
+  set_has_offset();
+  offset_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
+}
+
+// required uint32 deref_sz = 2;
+bool ReorderInfo_FixupInfo_FixupTuple::has_deref_sz() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_has_deref_sz() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_has_deref_sz() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_deref_sz() {
+  deref_sz_ = 0u;
+  clear_has_deref_sz();
+}
+::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::deref_sz() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
+  return deref_sz_;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_deref_sz(::google::protobuf::uint32 value) {
+  set_has_deref_sz();
+  deref_sz_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
+}
+
+// required bool is_rela = 3;
+bool ReorderInfo_FixupInfo_FixupTuple::has_is_rela() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_has_is_rela() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_has_is_rela() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_is_rela() {
+  is_rela_ = false;
+  clear_has_is_rela();
+}
+bool ReorderInfo_FixupInfo_FixupTuple::is_rela() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
+  return is_rela_;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_is_rela(bool value) {
+  set_has_is_rela();
+  is_rela_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
+}
+
+// optional uint32 type = 4;
+bool ReorderInfo_FixupInfo_FixupTuple::has_type() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_has_type() {
+  _has_bits_[0] |= 0x00000010u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_has_type() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_type() {
+  type_ = 0u;
+  clear_has_type();
+}
+::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::type() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
+  return type_;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_type(::google::protobuf::uint32 value) {
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
+}
+
+// optional string section_name = 5;
+bool ReorderInfo_FixupInfo_FixupTuple::has_section_name() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_has_section_name() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_has_section_name() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_section_name() {
+  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_section_name();
+}
+const ::std::string& ReorderInfo_FixupInfo_FixupTuple::section_name() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+  return section_name_.GetNoArena();
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const ::std::string& value) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+#if LANG_CXX11
+void ReorderInfo_FixupInfo_FixupTuple::set_section_name(::std::string&& value) {
+  set_has_section_name();
+  section_name_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+#endif
+void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value, size_t size) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+::std::string* ReorderInfo_FixupInfo_FixupTuple::mutable_section_name() {
+  set_has_section_name();
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* ReorderInfo_FixupInfo_FixupTuple::release_section_name() {
+  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+  clear_has_section_name();
+  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_allocated_section_name(::std::string* section_name) {
+  if (section_name != NULL) {
+    set_has_section_name();
+  } else {
+    clear_has_section_name();
+  }
+  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
+  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+
+// optional uint32 num_jt_entries = 6;
+bool ReorderInfo_FixupInfo_FixupTuple::has_num_jt_entries() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_has_num_jt_entries() {
+  _has_bits_[0] |= 0x00000020u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_has_num_jt_entries() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_num_jt_entries() {
+  num_jt_entries_ = 0u;
+  clear_has_num_jt_entries();
+}
+::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::num_jt_entries() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
+  return num_jt_entries_;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_num_jt_entries(::google::protobuf::uint32 value) {
+  set_has_num_jt_entries();
+  num_jt_entries_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
+}
+
+// optional uint32 jt_entry_sz = 7;
+bool ReorderInfo_FixupInfo_FixupTuple::has_jt_entry_sz() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_has_jt_entry_sz() {
+  _has_bits_[0] |= 0x00000040u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_has_jt_entry_sz() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+void ReorderInfo_FixupInfo_FixupTuple::clear_jt_entry_sz() {
+  jt_entry_sz_ = 0u;
+  clear_has_jt_entry_sz();
+}
+::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::jt_entry_sz() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
+  return jt_entry_sz_;
+}
+void ReorderInfo_FixupInfo_FixupTuple::set_jt_entry_sz(::google::protobuf::uint32 value) {
+  set_has_jt_entry_sz();
+  jt_entry_sz_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int ReorderInfo_FixupInfo::kTextFieldNumber;
+const int ReorderInfo_FixupInfo::kRodataFieldNumber;
+const int ReorderInfo_FixupInfo::kDataFieldNumber;
+const int ReorderInfo_FixupInfo::kDatarelFieldNumber;
+const int ReorderInfo_FixupInfo::kInitarrayFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+ReorderInfo_FixupInfo::ReorderInfo_FixupInfo()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_InitDefaults_shuffleInfo_2eproto();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.FixupInfo)
+}
+ReorderInfo_FixupInfo::ReorderInfo_FixupInfo(const ReorderInfo_FixupInfo& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0),
+      text_(from.text_),
+      rodata_(from.rodata_),
+      data_(from.data_),
+      datarel_(from.datarel_),
+      initarray_(from.initarray_) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.FixupInfo)
+}
+
+void ReorderInfo_FixupInfo::SharedCtor() {
+  _cached_size_ = 0;
+}
+
+ReorderInfo_FixupInfo::~ReorderInfo_FixupInfo() {
+  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.FixupInfo)
+  SharedDtor();
+}
+
+void ReorderInfo_FixupInfo::SharedDtor() {
+}
+
+void ReorderInfo_FixupInfo::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* ReorderInfo_FixupInfo::descriptor() {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[3].descriptor;
+}
+
+const ReorderInfo_FixupInfo& ReorderInfo_FixupInfo::default_instance() {
+  protobuf_InitDefaults_shuffleInfo_2eproto();
+  return *internal_default_instance();
+}
+
+ReorderInfo_FixupInfo* ReorderInfo_FixupInfo::New(::google::protobuf::Arena* arena) const {
+  ReorderInfo_FixupInfo* n = new ReorderInfo_FixupInfo;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void ReorderInfo_FixupInfo::Clear() {
+// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  text_.Clear();
+  rodata_.Clear();
+  data_.Clear();
+  datarel_.Clear();
+  initarray_.Clear();
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool ReorderInfo_FixupInfo::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
+      case 1: {
+        if (tag == 10u) {
+          DO_(input->IncrementRecursionDepth());
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
+                input, add_text()));
+        } else {
+          goto handle_unusual;
+        }
+        input->UnsafeDecrementRecursionDepth();
+        break;
+      }
+
+      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
+      case 2: {
+        if (tag == 18u) {
+          DO_(input->IncrementRecursionDepth());
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
+                input, add_rodata()));
+        } else {
+          goto handle_unusual;
+        }
+        input->UnsafeDecrementRecursionDepth();
+        break;
+      }
+
+      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
+      case 3: {
+        if (tag == 26u) {
+          DO_(input->IncrementRecursionDepth());
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
+                input, add_data()));
+        } else {
+          goto handle_unusual;
+        }
+        input->UnsafeDecrementRecursionDepth();
+        break;
+      }
+
+      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
+      case 4: {
+        if (tag == 34u) {
+          DO_(input->IncrementRecursionDepth());
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
+                input, add_datarel()));
+        } else {
+          goto handle_unusual;
+        }
+        input->UnsafeDecrementRecursionDepth();
+        break;
+      }
+
+      // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
+      case 5: {
+        if (tag == 42u) {
+          DO_(input->IncrementRecursionDepth());
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
+                input, add_initarray()));
+        } else {
+          goto handle_unusual;
+        }
+        input->UnsafeDecrementRecursionDepth();
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.FixupInfo)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.FixupInfo)
+  return false;
+#undef DO_
+}
+
+void ReorderInfo_FixupInfo::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
+  for (unsigned int i = 0, n = this->text_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      1, this->text(i), output);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
+  for (unsigned int i = 0, n = this->rodata_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      2, this->rodata(i), output);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
+  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      3, this->data(i), output);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
+  for (unsigned int i = 0, n = this->datarel_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      4, this->datarel(i), output);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
+  for (unsigned int i = 0, n = this->initarray_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      5, this->initarray(i), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.FixupInfo)
+}
+
+::google::protobuf::uint8* ReorderInfo_FixupInfo::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  (void)deterministic; // Unused
+  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
+  for (unsigned int i = 0, n = this->text_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        1, this->text(i), false, target);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
+  for (unsigned int i = 0, n = this->rodata_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        2, this->rodata(i), false, target);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
+  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        3, this->data(i), false, target);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
+  for (unsigned int i = 0, n = this->datarel_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        4, this->datarel(i), false, target);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
+  for (unsigned int i = 0, n = this->initarray_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        5, this->initarray(i), false, target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.FixupInfo)
+  return target;
+}
+
+size_t ReorderInfo_FixupInfo::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
+  {
+    unsigned int count = this->text_size();
+    total_size += 1UL * count;
+    for (unsigned int i = 0; i < count; i++) {
+      total_size +=
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->text(i));
+    }
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
+  {
+    unsigned int count = this->rodata_size();
+    total_size += 1UL * count;
+    for (unsigned int i = 0; i < count; i++) {
+      total_size +=
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->rodata(i));
+    }
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
+  {
+    unsigned int count = this->data_size();
+    total_size += 1UL * count;
+    for (unsigned int i = 0; i < count; i++) {
+      total_size +=
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->data(i));
+    }
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
+  {
+    unsigned int count = this->datarel_size();
+    total_size += 1UL * count;
+    for (unsigned int i = 0; i < count; i++) {
+      total_size +=
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->datarel(i));
+    }
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
+  {
+    unsigned int count = this->initarray_size();
+    total_size += 1UL * count;
+    for (unsigned int i = 0; i < count; i++) {
+      total_size +=
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->initarray(i));
+    }
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void ReorderInfo_FixupInfo::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  const ReorderInfo_FixupInfo* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_FixupInfo>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.FixupInfo)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.FixupInfo)
+    MergeFrom(*source);
+  }
+}
+
+void ReorderInfo_FixupInfo::MergeFrom(const ReorderInfo_FixupInfo& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  text_.MergeFrom(from.text_);
+  rodata_.MergeFrom(from.rodata_);
+  data_.MergeFrom(from.data_);
+  datarel_.MergeFrom(from.datarel_);
+  initarray_.MergeFrom(from.initarray_);
+}
+
+void ReorderInfo_FixupInfo::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void ReorderInfo_FixupInfo::CopyFrom(const ReorderInfo_FixupInfo& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.FixupInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ReorderInfo_FixupInfo::IsInitialized() const {
+  if (!::google::protobuf::internal::AllAreInitialized(this->text())) return false;
+  if (!::google::protobuf::internal::AllAreInitialized(this->rodata())) return false;
+  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
+  if (!::google::protobuf::internal::AllAreInitialized(this->datarel())) return false;
+  if (!::google::protobuf::internal::AllAreInitialized(this->initarray())) return false;
+  return true;
+}
+
+void ReorderInfo_FixupInfo::Swap(ReorderInfo_FixupInfo* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void ReorderInfo_FixupInfo::InternalSwap(ReorderInfo_FixupInfo* other) {
+  text_.UnsafeArenaSwap(&other->text_);
+  rodata_.UnsafeArenaSwap(&other->rodata_);
+  data_.UnsafeArenaSwap(&other->data_);
+  datarel_.UnsafeArenaSwap(&other->datarel_);
+  initarray_.UnsafeArenaSwap(&other->initarray_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata ReorderInfo_FixupInfo::GetMetadata() const {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[3];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// ReorderInfo_FixupInfo
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
+int ReorderInfo_FixupInfo::text_size() const {
+  return text_.size();
+}
+void ReorderInfo_FixupInfo::clear_text() {
+  text_.Clear();
+}
+const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::text(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return text_.Get(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_text(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return text_.Mutable(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_text() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return text_.Add();
+}
+::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_text() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return &text_;
+}
+const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::text() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return text_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
+int ReorderInfo_FixupInfo::rodata_size() const {
+  return rodata_.size();
+}
+void ReorderInfo_FixupInfo::clear_rodata() {
+  rodata_.Clear();
+}
+const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::rodata(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return rodata_.Get(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_rodata(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return rodata_.Mutable(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_rodata() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return rodata_.Add();
+}
+::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_rodata() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return &rodata_;
+}
+const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::rodata() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return rodata_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
+int ReorderInfo_FixupInfo::data_size() const {
+  return data_.size();
+}
+void ReorderInfo_FixupInfo::clear_data() {
+  data_.Clear();
+}
+const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::data(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return data_.Get(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_data(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return data_.Mutable(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_data() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return data_.Add();
+}
+::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_data() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return &data_;
+}
+const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::data() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return data_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
+int ReorderInfo_FixupInfo::datarel_size() const {
+  return datarel_.size();
+}
+void ReorderInfo_FixupInfo::clear_datarel() {
+  datarel_.Clear();
+}
+const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::datarel(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return datarel_.Get(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_datarel(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return datarel_.Mutable(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_datarel() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return datarel_.Add();
+}
+::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_datarel() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return &datarel_;
+}
+const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::datarel() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return datarel_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
+int ReorderInfo_FixupInfo::initarray_size() const {
+  return initarray_.size();
+}
+void ReorderInfo_FixupInfo::clear_initarray() {
+  initarray_.Clear();
+}
+const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::initarray(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return initarray_.Get(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_initarray(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return initarray_.Mutable(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_initarray() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return initarray_.Add();
+}
+::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_initarray() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return &initarray_;
+}
+const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::initarray() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return initarray_;
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int ReorderInfo_SourceInfo::kSrcTypeFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+ReorderInfo_SourceInfo::ReorderInfo_SourceInfo()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_InitDefaults_shuffleInfo_2eproto();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo.SourceInfo)
+}
+ReorderInfo_SourceInfo::ReorderInfo_SourceInfo(const ReorderInfo_SourceInfo& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0),
+      src_type_(from.src_type_) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo.SourceInfo)
+}
+
+void ReorderInfo_SourceInfo::SharedCtor() {
+  _cached_size_ = 0;
+}
+
+ReorderInfo_SourceInfo::~ReorderInfo_SourceInfo() {
+  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo.SourceInfo)
+  SharedDtor();
+}
+
+void ReorderInfo_SourceInfo::SharedDtor() {
+}
+
+void ReorderInfo_SourceInfo::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* ReorderInfo_SourceInfo::descriptor() {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[4].descriptor;
+}
+
+const ReorderInfo_SourceInfo& ReorderInfo_SourceInfo::default_instance() {
+  protobuf_InitDefaults_shuffleInfo_2eproto();
+  return *internal_default_instance();
+}
+
+ReorderInfo_SourceInfo* ReorderInfo_SourceInfo::New(::google::protobuf::Arena* arena) const {
+  ReorderInfo_SourceInfo* n = new ReorderInfo_SourceInfo;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void ReorderInfo_SourceInfo::Clear() {
+// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  src_type_.Clear();
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool ReorderInfo_SourceInfo::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // repeated uint32 src_type = 1;
+      case 1: {
+        if (tag == 8u) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 1, 8u, input, this->mutable_src_type())));
+        } else if (tag == 10u) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, this->mutable_src_type())));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo.SourceInfo)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo.SourceInfo)
+  return false;
+#undef DO_
+}
+
+void ReorderInfo_SourceInfo::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  // repeated uint32 src_type = 1;
+  for (int i = 0; i < this->src_type_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
+      1, this->src_type(i), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo.SourceInfo)
+}
+
+::google::protobuf::uint8* ReorderInfo_SourceInfo::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  (void)deterministic; // Unused
+  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  // repeated uint32 src_type = 1;
+  for (int i = 0; i < this->src_type_size(); i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      WriteUInt32ToArray(1, this->src_type(i), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo.SourceInfo)
+  return target;
+}
+
+size_t ReorderInfo_SourceInfo::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // repeated uint32 src_type = 1;
+  {
+    size_t data_size = 0;
+    unsigned int count = this->src_type_size();
+    for (unsigned int i = 0; i < count; i++) {
+      data_size += ::google::protobuf::internal::WireFormatLite::
+        UInt32Size(this->src_type(i));
+    }
+    total_size += 1 *
+                  ::google::protobuf::internal::FromIntSize(this->src_type_size());
+    total_size += data_size;
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void ReorderInfo_SourceInfo::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  const ReorderInfo_SourceInfo* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo_SourceInfo>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo.SourceInfo)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo.SourceInfo)
+    MergeFrom(*source);
+  }
+}
+
+void ReorderInfo_SourceInfo::MergeFrom(const ReorderInfo_SourceInfo& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  src_type_.MergeFrom(from.src_type_);
+}
+
+void ReorderInfo_SourceInfo::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void ReorderInfo_SourceInfo::CopyFrom(const ReorderInfo_SourceInfo& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo.SourceInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ReorderInfo_SourceInfo::IsInitialized() const {
+  return true;
+}
+
+void ReorderInfo_SourceInfo::Swap(ReorderInfo_SourceInfo* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void ReorderInfo_SourceInfo::InternalSwap(ReorderInfo_SourceInfo* other) {
+  src_type_.UnsafeArenaSwap(&other->src_type_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata ReorderInfo_SourceInfo::GetMetadata() const {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[4];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// ReorderInfo_SourceInfo
+
+// repeated uint32 src_type = 1;
+int ReorderInfo_SourceInfo::src_type_size() const {
+  return src_type_.size();
+}
+void ReorderInfo_SourceInfo::clear_src_type() {
+  src_type_.Clear();
+}
+::google::protobuf::uint32 ReorderInfo_SourceInfo::src_type(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+  return src_type_.Get(index);
+}
+void ReorderInfo_SourceInfo::set_src_type(int index, ::google::protobuf::uint32 value) {
+  src_type_.Set(index, value);
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+}
+void ReorderInfo_SourceInfo::add_src_type(::google::protobuf::uint32 value) {
+  src_type_.Add(value);
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+}
+const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
+ReorderInfo_SourceInfo::src_type() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+  return src_type_;
+}
+::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
+ReorderInfo_SourceInfo::mutable_src_type() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+  return &src_type_;
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int ReorderInfo::kBinFieldNumber;
+const int ReorderInfo::kLayoutFieldNumber;
+const int ReorderInfo::kFixupFieldNumber;
+const int ReorderInfo::kSourceFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+ReorderInfo::ReorderInfo()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_InitDefaults_shuffleInfo_2eproto();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:ShuffleInfo.ReorderInfo)
+}
+ReorderInfo::ReorderInfo(const ReorderInfo& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0),
+      layout_(from.layout_),
+      fixup_(from.fixup_) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  if (from.has_bin()) {
+    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo(*from.bin_);
+  } else {
+    bin_ = NULL;
+  }
+  if (from.has_source()) {
+    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo(*from.source_);
+  } else {
+    source_ = NULL;
+  }
+  // @@protoc_insertion_point(copy_constructor:ShuffleInfo.ReorderInfo)
+}
+
+void ReorderInfo::SharedCtor() {
+  _cached_size_ = 0;
+  ::memset(&bin_, 0, reinterpret_cast<char*>(&source_) -
+    reinterpret_cast<char*>(&bin_) + sizeof(source_));
+}
+
+ReorderInfo::~ReorderInfo() {
+  // @@protoc_insertion_point(destructor:ShuffleInfo.ReorderInfo)
+  SharedDtor();
+}
+
+void ReorderInfo::SharedDtor() {
+  if (this != internal_default_instance()) {
+    delete bin_;
+  }
+  if (this != internal_default_instance()) {
+    delete source_;
+  }
+}
+
+void ReorderInfo::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* ReorderInfo::descriptor() {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[5].descriptor;
+}
+
+const ReorderInfo& ReorderInfo::default_instance() {
+  protobuf_InitDefaults_shuffleInfo_2eproto();
+  return *internal_default_instance();
+}
+
+ReorderInfo* ReorderInfo::New(::google::protobuf::Arena* arena) const {
+  ReorderInfo* n = new ReorderInfo;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void ReorderInfo::Clear() {
+// @@protoc_insertion_point(message_clear_start:ShuffleInfo.ReorderInfo)
+  layout_.Clear();
+  fixup_.Clear();
+  if (_has_bits_[0 / 32] & 3u) {
+    if (has_bin()) {
+      GOOGLE_DCHECK(bin_ != NULL);
+      bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
+    }
+    if (has_source()) {
+      GOOGLE_DCHECK(source_ != NULL);
+      source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
+    }
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool ReorderInfo::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:ShuffleInfo.ReorderInfo)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
+      case 1: {
+        if (tag == 10u) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_bin()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
+      case 2: {
+        if (tag == 18u) {
+          DO_(input->IncrementRecursionDepth());
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
+                input, add_layout()));
+        } else {
+          goto handle_unusual;
+        }
+        input->UnsafeDecrementRecursionDepth();
+        break;
+      }
+
+      // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
+      case 3: {
+        if (tag == 26u) {
+          DO_(input->IncrementRecursionDepth());
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
+                input, add_fixup()));
+        } else {
+          goto handle_unusual;
+        }
+        input->UnsafeDecrementRecursionDepth();
+        break;
+      }
+
+      // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
+      case 4: {
+        if (tag == 34u) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_source()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:ShuffleInfo.ReorderInfo)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:ShuffleInfo.ReorderInfo)
+  return false;
+#undef DO_
+}
+
+void ReorderInfo::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:ShuffleInfo.ReorderInfo)
+  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
+  if (has_bin()) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      1, *this->bin_, output);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
+  for (unsigned int i = 0, n = this->layout_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      2, this->layout(i), output);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
+  for (unsigned int i = 0, n = this->fixup_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      3, this->fixup(i), output);
+  }
+
+  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
+  if (has_source()) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      4, *this->source_, output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:ShuffleInfo.ReorderInfo)
+}
+
+::google::protobuf::uint8* ReorderInfo::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  (void)deterministic; // Unused
+  // @@protoc_insertion_point(serialize_to_array_start:ShuffleInfo.ReorderInfo)
+  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
+  if (has_bin()) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        1, *this->bin_, false, target);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
+  for (unsigned int i = 0, n = this->layout_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        2, this->layout(i), false, target);
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
+  for (unsigned int i = 0, n = this->fixup_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        3, this->fixup(i), false, target);
+  }
+
+  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
+  if (has_source()) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        4, *this->source_, false, target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:ShuffleInfo.ReorderInfo)
+  return target;
+}
+
+size_t ReorderInfo::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:ShuffleInfo.ReorderInfo)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
+  {
+    unsigned int count = this->layout_size();
+    total_size += 1UL * count;
+    for (unsigned int i = 0; i < count; i++) {
+      total_size +=
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->layout(i));
+    }
+  }
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
+  {
+    unsigned int count = this->fixup_size();
+    total_size += 1UL * count;
+    for (unsigned int i = 0; i < count; i++) {
+      total_size +=
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->fixup(i));
+    }
+  }
+
+  if (_has_bits_[0 / 32] & 3u) {
+    // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
+    if (has_bin()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->bin_);
+    }
+
+    // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
+    if (has_source()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->source_);
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void ReorderInfo::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:ShuffleInfo.ReorderInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  const ReorderInfo* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const ReorderInfo>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShuffleInfo.ReorderInfo)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShuffleInfo.ReorderInfo)
+    MergeFrom(*source);
+  }
+}
+
+void ReorderInfo::MergeFrom(const ReorderInfo& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:ShuffleInfo.ReorderInfo)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  layout_.MergeFrom(from.layout_);
+  fixup_.MergeFrom(from.fixup_);
+  if (from._has_bits_[0 / 32] & 3u) {
+    if (from.has_bin()) {
+      mutable_bin()->::ShuffleInfo::ReorderInfo_BinaryInfo::MergeFrom(from.bin());
+    }
+    if (from.has_source()) {
+      mutable_source()->::ShuffleInfo::ReorderInfo_SourceInfo::MergeFrom(from.source());
+    }
+  }
+}
+
+void ReorderInfo::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:ShuffleInfo.ReorderInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void ReorderInfo::CopyFrom(const ReorderInfo& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:ShuffleInfo.ReorderInfo)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool ReorderInfo::IsInitialized() const {
+  if (!::google::protobuf::internal::AllAreInitialized(this->fixup())) return false;
+  return true;
+}
+
+void ReorderInfo::Swap(ReorderInfo* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void ReorderInfo::InternalSwap(ReorderInfo* other) {
+  layout_.UnsafeArenaSwap(&other->layout_);
+  fixup_.UnsafeArenaSwap(&other->fixup_);
+  std::swap(bin_, other->bin_);
+  std::swap(source_, other->source_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata ReorderInfo::GetMetadata() const {
+  protobuf_AssignDescriptorsOnce();
+  return file_level_metadata[5];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// ReorderInfo
+
+// optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
+bool ReorderInfo::has_bin() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void ReorderInfo::set_has_bin() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void ReorderInfo::clear_has_bin() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void ReorderInfo::clear_bin() {
+  if (bin_ != NULL) bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
+  clear_has_bin();
+}
+const ::ShuffleInfo::ReorderInfo_BinaryInfo& ReorderInfo::bin() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.bin)
+  return bin_ != NULL ? *bin_
+                         : *::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance();
+}
+::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::mutable_bin() {
+  set_has_bin();
+  if (bin_ == NULL) {
+    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo;
+  }
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.bin)
+  return bin_;
+}
+::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::release_bin() {
+  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.bin)
+  clear_has_bin();
+  ::ShuffleInfo::ReorderInfo_BinaryInfo* temp = bin_;
+  bin_ = NULL;
+  return temp;
+}
+void ReorderInfo::set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin) {
+  delete bin_;
+  bin_ = bin;
+  if (bin) {
+    set_has_bin();
+  } else {
+    clear_has_bin();
+  }
+  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.bin)
+}
+
+// repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
+int ReorderInfo::layout_size() const {
+  return layout_.size();
+}
+void ReorderInfo::clear_layout() {
+  layout_.Clear();
+}
+const ::ShuffleInfo::ReorderInfo_LayoutInfo& ReorderInfo::layout(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.layout)
+  return layout_.Get(index);
+}
+::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::mutable_layout(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.layout)
+  return layout_.Mutable(index);
+}
+::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::add_layout() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.layout)
+  return layout_.Add();
+}
+::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
+ReorderInfo::mutable_layout() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.layout)
+  return &layout_;
+}
+const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
+ReorderInfo::layout() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.layout)
+  return layout_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
+int ReorderInfo::fixup_size() const {
+  return fixup_.size();
+}
+void ReorderInfo::clear_fixup() {
+  fixup_.Clear();
+}
+const ::ShuffleInfo::ReorderInfo_FixupInfo& ReorderInfo::fixup(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.fixup)
+  return fixup_.Get(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::mutable_fixup(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.fixup)
+  return fixup_.Mutable(index);
+}
+::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::add_fixup() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.fixup)
+  return fixup_.Add();
+}
+::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
+ReorderInfo::mutable_fixup() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.fixup)
+  return &fixup_;
+}
+const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
+ReorderInfo::fixup() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.fixup)
+  return fixup_;
+}
+
+// optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
+bool ReorderInfo::has_source() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void ReorderInfo::set_has_source() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void ReorderInfo::clear_has_source() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void ReorderInfo::clear_source() {
+  if (source_ != NULL) source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
+  clear_has_source();
+}
+const ::ShuffleInfo::ReorderInfo_SourceInfo& ReorderInfo::source() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.source)
+  return source_ != NULL ? *source_
+                         : *::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance();
+}
+::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::mutable_source() {
+  set_has_source();
+  if (source_ == NULL) {
+    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo;
+  }
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.source)
+  return source_;
+}
+::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::release_source() {
+  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.source)
+  clear_has_source();
+  ::ShuffleInfo::ReorderInfo_SourceInfo* temp = source_;
+  source_ = NULL;
+  return temp;
+}
+void ReorderInfo::set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source) {
+  delete source_;
+  source_ = source;
+  if (source) {
+    set_has_source();
+  } else {
+    clear_has_source();
+  }
+  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.source)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// @@protoc_insertion_point(namespace_scope)
+
+}  // namespace ShuffleInfo
+
+// @@protoc_insertion_point(global_scope)
diff --git a/shuffleInfo.pb.h b/shuffleInfo.pb.h
new file mode 100644
index 0000000..aea266f
--- /dev/null
+++ b/shuffleInfo.pb.h
@@ -0,0 +1,1771 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: shuffleInfo.proto
+
+#ifndef PROTOBUF_shuffleInfo_2eproto__INCLUDED
+#define PROTOBUF_shuffleInfo_2eproto__INCLUDED
+
+#include <string>
+
+#include <google/protobuf/stubs/common.h>
+
+#if GOOGLE_PROTOBUF_VERSION < 3001000
+#error This file was generated by a newer version of protoc which is
+#error incompatible with your Protocol Buffer headers.  Please update
+#error your headers.
+#endif
+#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
+#error This file was generated by an older version of protoc which is
+#error incompatible with your Protocol Buffer headers.  Please
+#error regenerate this file with a newer version of protoc.
+#endif
+
+#include <google/protobuf/arena.h>
+#include <google/protobuf/arenastring.h>
+#include <google/protobuf/generated_message_util.h>
+#include <google/protobuf/metadata.h>
+#include <google/protobuf/message.h>
+#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
+#include <google/protobuf/extension_set.h>  // IWYU pragma: export
+#include <google/protobuf/unknown_field_set.h>
+// @@protoc_insertion_point(includes)
+namespace ShuffleInfo {
+class ReorderInfo;
+class ReorderInfoDefaultTypeInternal;
+extern ReorderInfoDefaultTypeInternal _ReorderInfo_default_instance_;
+class ReorderInfo_BinaryInfo;
+class ReorderInfo_BinaryInfoDefaultTypeInternal;
+extern ReorderInfo_BinaryInfoDefaultTypeInternal _ReorderInfo_BinaryInfo_default_instance_;
+class ReorderInfo_FixupInfo;
+class ReorderInfo_FixupInfoDefaultTypeInternal;
+extern ReorderInfo_FixupInfoDefaultTypeInternal _ReorderInfo_FixupInfo_default_instance_;
+class ReorderInfo_FixupInfo_FixupTuple;
+class ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal;
+extern ReorderInfo_FixupInfo_FixupTupleDefaultTypeInternal _ReorderInfo_FixupInfo_FixupTuple_default_instance_;
+class ReorderInfo_LayoutInfo;
+class ReorderInfo_LayoutInfoDefaultTypeInternal;
+extern ReorderInfo_LayoutInfoDefaultTypeInternal _ReorderInfo_LayoutInfo_default_instance_;
+class ReorderInfo_SourceInfo;
+class ReorderInfo_SourceInfoDefaultTypeInternal;
+extern ReorderInfo_SourceInfoDefaultTypeInternal _ReorderInfo_SourceInfo_default_instance_;
+}  // namespace ShuffleInfo
+
+namespace ShuffleInfo {
+
+// Internal implementation detail -- do not call these.
+void protobuf_AddDesc_shuffleInfo_2eproto();
+void protobuf_InitDefaults_shuffleInfo_2eproto();
+
+// ===================================================================
+
+class ReorderInfo_BinaryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.BinaryInfo) */ {
+ public:
+  ReorderInfo_BinaryInfo();
+  virtual ~ReorderInfo_BinaryInfo();
+
+  ReorderInfo_BinaryInfo(const ReorderInfo_BinaryInfo& from);
+
+  inline ReorderInfo_BinaryInfo& operator=(const ReorderInfo_BinaryInfo& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const ReorderInfo_BinaryInfo& default_instance();
+
+  static inline const ReorderInfo_BinaryInfo* internal_default_instance() {
+    return reinterpret_cast<const ReorderInfo_BinaryInfo*>(
+               &_ReorderInfo_BinaryInfo_default_instance_);
+  }
+
+  void Swap(ReorderInfo_BinaryInfo* other);
+
+  // implements Message ----------------------------------------------
+
+  inline ReorderInfo_BinaryInfo* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  ReorderInfo_BinaryInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const ReorderInfo_BinaryInfo& from);
+  void MergeFrom(const ReorderInfo_BinaryInfo& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
+      const PROTOBUF_FINAL {
+    return InternalSerializeWithCachedSizesToArray(false, output);
+  }
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(ReorderInfo_BinaryInfo* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional uint32 rand_obj_offset = 1;
+  bool has_rand_obj_offset() const;
+  void clear_rand_obj_offset();
+  static const int kRandObjOffsetFieldNumber = 1;
+  ::google::protobuf::uint32 rand_obj_offset() const;
+  void set_rand_obj_offset(::google::protobuf::uint32 value);
+
+  // optional uint32 main_addr_offset = 2;
+  bool has_main_addr_offset() const;
+  void clear_main_addr_offset();
+  static const int kMainAddrOffsetFieldNumber = 2;
+  ::google::protobuf::uint32 main_addr_offset() const;
+  void set_main_addr_offset(::google::protobuf::uint32 value);
+
+  // optional uint32 obj_sz = 3;
+  bool has_obj_sz() const;
+  void clear_obj_sz();
+  static const int kObjSzFieldNumber = 3;
+  ::google::protobuf::uint32 obj_sz() const;
+  void set_obj_sz(::google::protobuf::uint32 value);
+
+  // optional uint32 src_type = 4;
+  bool has_src_type() const;
+  void clear_src_type();
+  static const int kSrcTypeFieldNumber = 4;
+  ::google::protobuf::uint32 src_type() const;
+  void set_src_type(::google::protobuf::uint32 value);
+
+  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.BinaryInfo)
+ private:
+  void set_has_rand_obj_offset();
+  void clear_has_rand_obj_offset();
+  void set_has_main_addr_offset();
+  void clear_has_main_addr_offset();
+  void set_has_obj_sz();
+  void clear_has_obj_sz();
+  void set_has_src_type();
+  void clear_has_src_type();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::uint32 rand_obj_offset_;
+  ::google::protobuf::uint32 main_addr_offset_;
+  ::google::protobuf::uint32 obj_sz_;
+  ::google::protobuf::uint32 src_type_;
+  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
+  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
+  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
+  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
+
+};
+// -------------------------------------------------------------------
+
+class ReorderInfo_LayoutInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.LayoutInfo) */ {
+ public:
+  ReorderInfo_LayoutInfo();
+  virtual ~ReorderInfo_LayoutInfo();
+
+  ReorderInfo_LayoutInfo(const ReorderInfo_LayoutInfo& from);
+
+  inline ReorderInfo_LayoutInfo& operator=(const ReorderInfo_LayoutInfo& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const ReorderInfo_LayoutInfo& default_instance();
+
+  static inline const ReorderInfo_LayoutInfo* internal_default_instance() {
+    return reinterpret_cast<const ReorderInfo_LayoutInfo*>(
+               &_ReorderInfo_LayoutInfo_default_instance_);
+  }
+
+  void Swap(ReorderInfo_LayoutInfo* other);
+
+  // implements Message ----------------------------------------------
+
+  inline ReorderInfo_LayoutInfo* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  ReorderInfo_LayoutInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const ReorderInfo_LayoutInfo& from);
+  void MergeFrom(const ReorderInfo_LayoutInfo& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
+      const PROTOBUF_FINAL {
+    return InternalSerializeWithCachedSizesToArray(false, output);
+  }
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(ReorderInfo_LayoutInfo* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional uint32 bb_size = 1;
+  bool has_bb_size() const;
+  void clear_bb_size();
+  static const int kBbSizeFieldNumber = 1;
+  ::google::protobuf::uint32 bb_size() const;
+  void set_bb_size(::google::protobuf::uint32 value);
+
+  // optional uint32 type = 2;
+  bool has_type() const;
+  void clear_type();
+  static const int kTypeFieldNumber = 2;
+  ::google::protobuf::uint32 type() const;
+  void set_type(::google::protobuf::uint32 value);
+
+  // optional uint32 num_fixups = 3;
+  bool has_num_fixups() const;
+  void clear_num_fixups();
+  static const int kNumFixupsFieldNumber = 3;
+  ::google::protobuf::uint32 num_fixups() const;
+  void set_num_fixups(::google::protobuf::uint32 value);
+
+  // optional bool bb_fallthrough = 4;
+  bool has_bb_fallthrough() const;
+  void clear_bb_fallthrough();
+  static const int kBbFallthroughFieldNumber = 4;
+  bool bb_fallthrough() const;
+  void set_bb_fallthrough(bool value);
+
+  // optional string section_name = 5;
+  bool has_section_name() const;
+  void clear_section_name();
+  static const int kSectionNameFieldNumber = 5;
+  const ::std::string& section_name() const;
+  void set_section_name(const ::std::string& value);
+  #if LANG_CXX11
+  void set_section_name(::std::string&& value);
+  #endif
+  void set_section_name(const char* value);
+  void set_section_name(const char* value, size_t size);
+  ::std::string* mutable_section_name();
+  ::std::string* release_section_name();
+  void set_allocated_section_name(::std::string* section_name);
+
+  // optional uint32 offset = 6;
+  bool has_offset() const;
+  void clear_offset();
+  static const int kOffsetFieldNumber = 6;
+  ::google::protobuf::uint32 offset() const;
+  void set_offset(::google::protobuf::uint32 value);
+
+  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.LayoutInfo)
+ private:
+  void set_has_bb_size();
+  void clear_has_bb_size();
+  void set_has_type();
+  void clear_has_type();
+  void set_has_num_fixups();
+  void clear_has_num_fixups();
+  void set_has_bb_fallthrough();
+  void clear_has_bb_fallthrough();
+  void set_has_section_name();
+  void clear_has_section_name();
+  void set_has_offset();
+  void clear_has_offset();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::internal::ArenaStringPtr section_name_;
+  ::google::protobuf::uint32 bb_size_;
+  ::google::protobuf::uint32 type_;
+  ::google::protobuf::uint32 num_fixups_;
+  bool bb_fallthrough_;
+  ::google::protobuf::uint32 offset_;
+  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
+  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
+  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
+  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
+
+};
+// -------------------------------------------------------------------
+
+class ReorderInfo_FixupInfo_FixupTuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple) */ {
+ public:
+  ReorderInfo_FixupInfo_FixupTuple();
+  virtual ~ReorderInfo_FixupInfo_FixupTuple();
+
+  ReorderInfo_FixupInfo_FixupTuple(const ReorderInfo_FixupInfo_FixupTuple& from);
+
+  inline ReorderInfo_FixupInfo_FixupTuple& operator=(const ReorderInfo_FixupInfo_FixupTuple& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const ReorderInfo_FixupInfo_FixupTuple& default_instance();
+
+  static inline const ReorderInfo_FixupInfo_FixupTuple* internal_default_instance() {
+    return reinterpret_cast<const ReorderInfo_FixupInfo_FixupTuple*>(
+               &_ReorderInfo_FixupInfo_FixupTuple_default_instance_);
+  }
+
+  void Swap(ReorderInfo_FixupInfo_FixupTuple* other);
+
+  // implements Message ----------------------------------------------
+
+  inline ReorderInfo_FixupInfo_FixupTuple* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  ReorderInfo_FixupInfo_FixupTuple* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const ReorderInfo_FixupInfo_FixupTuple& from);
+  void MergeFrom(const ReorderInfo_FixupInfo_FixupTuple& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
+      const PROTOBUF_FINAL {
+    return InternalSerializeWithCachedSizesToArray(false, output);
+  }
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(ReorderInfo_FixupInfo_FixupTuple* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // required uint32 offset = 1;
+  bool has_offset() const;
+  void clear_offset();
+  static const int kOffsetFieldNumber = 1;
+  ::google::protobuf::uint32 offset() const;
+  void set_offset(::google::protobuf::uint32 value);
+
+  // required uint32 deref_sz = 2;
+  bool has_deref_sz() const;
+  void clear_deref_sz();
+  static const int kDerefSzFieldNumber = 2;
+  ::google::protobuf::uint32 deref_sz() const;
+  void set_deref_sz(::google::protobuf::uint32 value);
+
+  // required bool is_rela = 3;
+  bool has_is_rela() const;
+  void clear_is_rela();
+  static const int kIsRelaFieldNumber = 3;
+  bool is_rela() const;
+  void set_is_rela(bool value);
+
+  // optional uint32 type = 4;
+  bool has_type() const;
+  void clear_type();
+  static const int kTypeFieldNumber = 4;
+  ::google::protobuf::uint32 type() const;
+  void set_type(::google::protobuf::uint32 value);
+
+  // optional string section_name = 5;
+  bool has_section_name() const;
+  void clear_section_name();
+  static const int kSectionNameFieldNumber = 5;
+  const ::std::string& section_name() const;
+  void set_section_name(const ::std::string& value);
+  #if LANG_CXX11
+  void set_section_name(::std::string&& value);
+  #endif
+  void set_section_name(const char* value);
+  void set_section_name(const char* value, size_t size);
+  ::std::string* mutable_section_name();
+  ::std::string* release_section_name();
+  void set_allocated_section_name(::std::string* section_name);
+
+  // optional uint32 num_jt_entries = 6;
+  bool has_num_jt_entries() const;
+  void clear_num_jt_entries();
+  static const int kNumJtEntriesFieldNumber = 6;
+  ::google::protobuf::uint32 num_jt_entries() const;
+  void set_num_jt_entries(::google::protobuf::uint32 value);
+
+  // optional uint32 jt_entry_sz = 7;
+  bool has_jt_entry_sz() const;
+  void clear_jt_entry_sz();
+  static const int kJtEntrySzFieldNumber = 7;
+  ::google::protobuf::uint32 jt_entry_sz() const;
+  void set_jt_entry_sz(::google::protobuf::uint32 value);
+
+  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple)
+ private:
+  void set_has_offset();
+  void clear_has_offset();
+  void set_has_deref_sz();
+  void clear_has_deref_sz();
+  void set_has_is_rela();
+  void clear_has_is_rela();
+  void set_has_type();
+  void clear_has_type();
+  void set_has_section_name();
+  void clear_has_section_name();
+  void set_has_num_jt_entries();
+  void clear_has_num_jt_entries();
+  void set_has_jt_entry_sz();
+  void clear_has_jt_entry_sz();
+
+  // helper for ByteSizeLong()
+  size_t RequiredFieldsByteSizeFallback() const;
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::internal::ArenaStringPtr section_name_;
+  ::google::protobuf::uint32 offset_;
+  ::google::protobuf::uint32 deref_sz_;
+  bool is_rela_;
+  ::google::protobuf::uint32 type_;
+  ::google::protobuf::uint32 num_jt_entries_;
+  ::google::protobuf::uint32 jt_entry_sz_;
+  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
+  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
+  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
+  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
+
+};
+// -------------------------------------------------------------------
+
+class ReorderInfo_FixupInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.FixupInfo) */ {
+ public:
+  ReorderInfo_FixupInfo();
+  virtual ~ReorderInfo_FixupInfo();
+
+  ReorderInfo_FixupInfo(const ReorderInfo_FixupInfo& from);
+
+  inline ReorderInfo_FixupInfo& operator=(const ReorderInfo_FixupInfo& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const ReorderInfo_FixupInfo& default_instance();
+
+  static inline const ReorderInfo_FixupInfo* internal_default_instance() {
+    return reinterpret_cast<const ReorderInfo_FixupInfo*>(
+               &_ReorderInfo_FixupInfo_default_instance_);
+  }
+
+  void Swap(ReorderInfo_FixupInfo* other);
+
+  // implements Message ----------------------------------------------
+
+  inline ReorderInfo_FixupInfo* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  ReorderInfo_FixupInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const ReorderInfo_FixupInfo& from);
+  void MergeFrom(const ReorderInfo_FixupInfo& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
+      const PROTOBUF_FINAL {
+    return InternalSerializeWithCachedSizesToArray(false, output);
+  }
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(ReorderInfo_FixupInfo* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  typedef ReorderInfo_FixupInfo_FixupTuple FixupTuple;
+
+  // accessors -------------------------------------------------------
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
+  int text_size() const;
+  void clear_text();
+  static const int kTextFieldNumber = 1;
+  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& text(int index) const;
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_text(int index);
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_text();
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+      mutable_text();
+  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+      text() const;
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
+  int rodata_size() const;
+  void clear_rodata();
+  static const int kRodataFieldNumber = 2;
+  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& rodata(int index) const;
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_rodata(int index);
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_rodata();
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+      mutable_rodata();
+  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+      rodata() const;
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
+  int data_size() const;
+  void clear_data();
+  static const int kDataFieldNumber = 3;
+  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& data(int index) const;
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_data(int index);
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_data();
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+      mutable_data();
+  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+      data() const;
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
+  int datarel_size() const;
+  void clear_datarel();
+  static const int kDatarelFieldNumber = 4;
+  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& datarel(int index) const;
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_datarel(int index);
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_datarel();
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+      mutable_datarel();
+  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+      datarel() const;
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
+  int initarray_size() const;
+  void clear_initarray();
+  static const int kInitarrayFieldNumber = 5;
+  const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& initarray(int index) const;
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* mutable_initarray(int index);
+  ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* add_initarray();
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+      mutable_initarray();
+  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+      initarray() const;
+
+  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.FixupInfo)
+ private:
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > text_;
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > rodata_;
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > data_;
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > datarel_;
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple > initarray_;
+  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
+  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
+  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
+  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
+
+};
+// -------------------------------------------------------------------
+
+class ReorderInfo_SourceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo.SourceInfo) */ {
+ public:
+  ReorderInfo_SourceInfo();
+  virtual ~ReorderInfo_SourceInfo();
+
+  ReorderInfo_SourceInfo(const ReorderInfo_SourceInfo& from);
+
+  inline ReorderInfo_SourceInfo& operator=(const ReorderInfo_SourceInfo& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const ReorderInfo_SourceInfo& default_instance();
+
+  static inline const ReorderInfo_SourceInfo* internal_default_instance() {
+    return reinterpret_cast<const ReorderInfo_SourceInfo*>(
+               &_ReorderInfo_SourceInfo_default_instance_);
+  }
+
+  void Swap(ReorderInfo_SourceInfo* other);
+
+  // implements Message ----------------------------------------------
+
+  inline ReorderInfo_SourceInfo* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  ReorderInfo_SourceInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const ReorderInfo_SourceInfo& from);
+  void MergeFrom(const ReorderInfo_SourceInfo& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
+      const PROTOBUF_FINAL {
+    return InternalSerializeWithCachedSizesToArray(false, output);
+  }
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(ReorderInfo_SourceInfo* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // repeated uint32 src_type = 1;
+  int src_type_size() const;
+  void clear_src_type();
+  static const int kSrcTypeFieldNumber = 1;
+  ::google::protobuf::uint32 src_type(int index) const;
+  void set_src_type(int index, ::google::protobuf::uint32 value);
+  void add_src_type(::google::protobuf::uint32 value);
+  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
+      src_type() const;
+  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
+      mutable_src_type();
+
+  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo.SourceInfo)
+ private:
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > src_type_;
+  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
+  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
+  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
+  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
+
+};
+// -------------------------------------------------------------------
+
+class ReorderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShuffleInfo.ReorderInfo) */ {
+ public:
+  ReorderInfo();
+  virtual ~ReorderInfo();
+
+  ReorderInfo(const ReorderInfo& from);
+
+  inline ReorderInfo& operator=(const ReorderInfo& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const ReorderInfo& default_instance();
+
+  static inline const ReorderInfo* internal_default_instance() {
+    return reinterpret_cast<const ReorderInfo*>(
+               &_ReorderInfo_default_instance_);
+  }
+
+  void Swap(ReorderInfo* other);
+
+  // implements Message ----------------------------------------------
+
+  inline ReorderInfo* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  ReorderInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const ReorderInfo& from);
+  void MergeFrom(const ReorderInfo& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
+      const PROTOBUF_FINAL {
+    return InternalSerializeWithCachedSizesToArray(false, output);
+  }
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(ReorderInfo* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  typedef ReorderInfo_BinaryInfo BinaryInfo;
+  typedef ReorderInfo_LayoutInfo LayoutInfo;
+  typedef ReorderInfo_FixupInfo FixupInfo;
+  typedef ReorderInfo_SourceInfo SourceInfo;
+
+  // accessors -------------------------------------------------------
+
+  // optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
+  bool has_bin() const;
+  void clear_bin();
+  static const int kBinFieldNumber = 1;
+  const ::ShuffleInfo::ReorderInfo_BinaryInfo& bin() const;
+  ::ShuffleInfo::ReorderInfo_BinaryInfo* mutable_bin();
+  ::ShuffleInfo::ReorderInfo_BinaryInfo* release_bin();
+  void set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin);
+
+  // repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
+  int layout_size() const;
+  void clear_layout();
+  static const int kLayoutFieldNumber = 2;
+  const ::ShuffleInfo::ReorderInfo_LayoutInfo& layout(int index) const;
+  ::ShuffleInfo::ReorderInfo_LayoutInfo* mutable_layout(int index);
+  ::ShuffleInfo::ReorderInfo_LayoutInfo* add_layout();
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
+      mutable_layout();
+  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
+      layout() const;
+
+  // repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
+  int fixup_size() const;
+  void clear_fixup();
+  static const int kFixupFieldNumber = 3;
+  const ::ShuffleInfo::ReorderInfo_FixupInfo& fixup(int index) const;
+  ::ShuffleInfo::ReorderInfo_FixupInfo* mutable_fixup(int index);
+  ::ShuffleInfo::ReorderInfo_FixupInfo* add_fixup();
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
+      mutable_fixup();
+  const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
+      fixup() const;
+
+  // optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
+  bool has_source() const;
+  void clear_source();
+  static const int kSourceFieldNumber = 4;
+  const ::ShuffleInfo::ReorderInfo_SourceInfo& source() const;
+  ::ShuffleInfo::ReorderInfo_SourceInfo* mutable_source();
+  ::ShuffleInfo::ReorderInfo_SourceInfo* release_source();
+  void set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source);
+
+  // @@protoc_insertion_point(class_scope:ShuffleInfo.ReorderInfo)
+ private:
+  void set_has_bin();
+  void clear_has_bin();
+  void set_has_source();
+  void clear_has_source();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo > layout_;
+  ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo > fixup_;
+  ::ShuffleInfo::ReorderInfo_BinaryInfo* bin_;
+  ::ShuffleInfo::ReorderInfo_SourceInfo* source_;
+  friend void  protobuf_InitDefaults_shuffleInfo_2eproto_impl();
+  friend void  protobuf_AddDesc_shuffleInfo_2eproto_impl();
+  friend const ::google::protobuf::uint32* protobuf_Offsets_shuffleInfo_2eproto();
+  friend void protobuf_ShutdownFile_shuffleInfo_2eproto();
+
+};
+// ===================================================================
+
+
+// ===================================================================
+
+#if !PROTOBUF_INLINE_NOT_IN_HEADERS
+// ReorderInfo_BinaryInfo
+
+// optional uint32 rand_obj_offset = 1;
+inline bool ReorderInfo_BinaryInfo::has_rand_obj_offset() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void ReorderInfo_BinaryInfo::set_has_rand_obj_offset() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void ReorderInfo_BinaryInfo::clear_has_rand_obj_offset() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void ReorderInfo_BinaryInfo::clear_rand_obj_offset() {
+  rand_obj_offset_ = 0u;
+  clear_has_rand_obj_offset();
+}
+inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::rand_obj_offset() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
+  return rand_obj_offset_;
+}
+inline void ReorderInfo_BinaryInfo::set_rand_obj_offset(::google::protobuf::uint32 value) {
+  set_has_rand_obj_offset();
+  rand_obj_offset_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.rand_obj_offset)
+}
+
+// optional uint32 main_addr_offset = 2;
+inline bool ReorderInfo_BinaryInfo::has_main_addr_offset() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void ReorderInfo_BinaryInfo::set_has_main_addr_offset() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void ReorderInfo_BinaryInfo::clear_has_main_addr_offset() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void ReorderInfo_BinaryInfo::clear_main_addr_offset() {
+  main_addr_offset_ = 0u;
+  clear_has_main_addr_offset();
+}
+inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::main_addr_offset() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
+  return main_addr_offset_;
+}
+inline void ReorderInfo_BinaryInfo::set_main_addr_offset(::google::protobuf::uint32 value) {
+  set_has_main_addr_offset();
+  main_addr_offset_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.main_addr_offset)
+}
+
+// optional uint32 obj_sz = 3;
+inline bool ReorderInfo_BinaryInfo::has_obj_sz() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void ReorderInfo_BinaryInfo::set_has_obj_sz() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void ReorderInfo_BinaryInfo::clear_has_obj_sz() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void ReorderInfo_BinaryInfo::clear_obj_sz() {
+  obj_sz_ = 0u;
+  clear_has_obj_sz();
+}
+inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::obj_sz() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
+  return obj_sz_;
+}
+inline void ReorderInfo_BinaryInfo::set_obj_sz(::google::protobuf::uint32 value) {
+  set_has_obj_sz();
+  obj_sz_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.obj_sz)
+}
+
+// optional uint32 src_type = 4;
+inline bool ReorderInfo_BinaryInfo::has_src_type() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void ReorderInfo_BinaryInfo::set_has_src_type() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void ReorderInfo_BinaryInfo::clear_has_src_type() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void ReorderInfo_BinaryInfo::clear_src_type() {
+  src_type_ = 0u;
+  clear_has_src_type();
+}
+inline ::google::protobuf::uint32 ReorderInfo_BinaryInfo::src_type() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
+  return src_type_;
+}
+inline void ReorderInfo_BinaryInfo::set_src_type(::google::protobuf::uint32 value) {
+  set_has_src_type();
+  src_type_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.BinaryInfo.src_type)
+}
+
+// -------------------------------------------------------------------
+
+// ReorderInfo_LayoutInfo
+
+// optional uint32 bb_size = 1;
+inline bool ReorderInfo_LayoutInfo::has_bb_size() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void ReorderInfo_LayoutInfo::set_has_bb_size() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void ReorderInfo_LayoutInfo::clear_has_bb_size() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void ReorderInfo_LayoutInfo::clear_bb_size() {
+  bb_size_ = 0u;
+  clear_has_bb_size();
+}
+inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::bb_size() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
+  return bb_size_;
+}
+inline void ReorderInfo_LayoutInfo::set_bb_size(::google::protobuf::uint32 value) {
+  set_has_bb_size();
+  bb_size_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_size)
+}
+
+// optional uint32 type = 2;
+inline bool ReorderInfo_LayoutInfo::has_type() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void ReorderInfo_LayoutInfo::set_has_type() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void ReorderInfo_LayoutInfo::clear_has_type() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void ReorderInfo_LayoutInfo::clear_type() {
+  type_ = 0u;
+  clear_has_type();
+}
+inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::type() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.type)
+  return type_;
+}
+inline void ReorderInfo_LayoutInfo::set_type(::google::protobuf::uint32 value) {
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.type)
+}
+
+// optional uint32 num_fixups = 3;
+inline bool ReorderInfo_LayoutInfo::has_num_fixups() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void ReorderInfo_LayoutInfo::set_has_num_fixups() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void ReorderInfo_LayoutInfo::clear_has_num_fixups() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void ReorderInfo_LayoutInfo::clear_num_fixups() {
+  num_fixups_ = 0u;
+  clear_has_num_fixups();
+}
+inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::num_fixups() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
+  return num_fixups_;
+}
+inline void ReorderInfo_LayoutInfo::set_num_fixups(::google::protobuf::uint32 value) {
+  set_has_num_fixups();
+  num_fixups_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.num_fixups)
+}
+
+// optional bool bb_fallthrough = 4;
+inline bool ReorderInfo_LayoutInfo::has_bb_fallthrough() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+inline void ReorderInfo_LayoutInfo::set_has_bb_fallthrough() {
+  _has_bits_[0] |= 0x00000010u;
+}
+inline void ReorderInfo_LayoutInfo::clear_has_bb_fallthrough() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+inline void ReorderInfo_LayoutInfo::clear_bb_fallthrough() {
+  bb_fallthrough_ = false;
+  clear_has_bb_fallthrough();
+}
+inline bool ReorderInfo_LayoutInfo::bb_fallthrough() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
+  return bb_fallthrough_;
+}
+inline void ReorderInfo_LayoutInfo::set_bb_fallthrough(bool value) {
+  set_has_bb_fallthrough();
+  bb_fallthrough_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.bb_fallthrough)
+}
+
+// optional string section_name = 5;
+inline bool ReorderInfo_LayoutInfo::has_section_name() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void ReorderInfo_LayoutInfo::set_has_section_name() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void ReorderInfo_LayoutInfo::clear_has_section_name() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void ReorderInfo_LayoutInfo::clear_section_name() {
+  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_section_name();
+}
+inline const ::std::string& ReorderInfo_LayoutInfo::section_name() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+  return section_name_.GetNoArena();
+}
+inline void ReorderInfo_LayoutInfo::set_section_name(const ::std::string& value) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+#if LANG_CXX11
+inline void ReorderInfo_LayoutInfo::set_section_name(::std::string&& value) {
+  set_has_section_name();
+  section_name_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+#endif
+inline void ReorderInfo_LayoutInfo::set_section_name(const char* value) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+inline void ReorderInfo_LayoutInfo::set_section_name(const char* value, size_t size) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+inline ::std::string* ReorderInfo_LayoutInfo::mutable_section_name() {
+  set_has_section_name();
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* ReorderInfo_LayoutInfo::release_section_name() {
+  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+  clear_has_section_name();
+  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void ReorderInfo_LayoutInfo::set_allocated_section_name(::std::string* section_name) {
+  if (section_name != NULL) {
+    set_has_section_name();
+  } else {
+    clear_has_section_name();
+  }
+  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
+  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.LayoutInfo.section_name)
+}
+
+// optional uint32 offset = 6;
+inline bool ReorderInfo_LayoutInfo::has_offset() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+inline void ReorderInfo_LayoutInfo::set_has_offset() {
+  _has_bits_[0] |= 0x00000020u;
+}
+inline void ReorderInfo_LayoutInfo::clear_has_offset() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+inline void ReorderInfo_LayoutInfo::clear_offset() {
+  offset_ = 0u;
+  clear_has_offset();
+}
+inline ::google::protobuf::uint32 ReorderInfo_LayoutInfo::offset() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
+  return offset_;
+}
+inline void ReorderInfo_LayoutInfo::set_offset(::google::protobuf::uint32 value) {
+  set_has_offset();
+  offset_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.LayoutInfo.offset)
+}
+
+// -------------------------------------------------------------------
+
+// ReorderInfo_FixupInfo_FixupTuple
+
+// required uint32 offset = 1;
+inline bool ReorderInfo_FixupInfo_FixupTuple::has_offset() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_has_offset() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_offset() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_offset() {
+  offset_ = 0u;
+  clear_has_offset();
+}
+inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::offset() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
+  return offset_;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_offset(::google::protobuf::uint32 value) {
+  set_has_offset();
+  offset_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.offset)
+}
+
+// required uint32 deref_sz = 2;
+inline bool ReorderInfo_FixupInfo_FixupTuple::has_deref_sz() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_has_deref_sz() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_deref_sz() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_deref_sz() {
+  deref_sz_ = 0u;
+  clear_has_deref_sz();
+}
+inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::deref_sz() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
+  return deref_sz_;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_deref_sz(::google::protobuf::uint32 value) {
+  set_has_deref_sz();
+  deref_sz_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.deref_sz)
+}
+
+// required bool is_rela = 3;
+inline bool ReorderInfo_FixupInfo_FixupTuple::has_is_rela() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_has_is_rela() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_is_rela() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_is_rela() {
+  is_rela_ = false;
+  clear_has_is_rela();
+}
+inline bool ReorderInfo_FixupInfo_FixupTuple::is_rela() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
+  return is_rela_;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_is_rela(bool value) {
+  set_has_is_rela();
+  is_rela_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.is_rela)
+}
+
+// optional uint32 type = 4;
+inline bool ReorderInfo_FixupInfo_FixupTuple::has_type() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_has_type() {
+  _has_bits_[0] |= 0x00000010u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_type() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_type() {
+  type_ = 0u;
+  clear_has_type();
+}
+inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::type() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
+  return type_;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_type(::google::protobuf::uint32 value) {
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.type)
+}
+
+// optional string section_name = 5;
+inline bool ReorderInfo_FixupInfo_FixupTuple::has_section_name() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_has_section_name() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_section_name() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_section_name() {
+  section_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_section_name();
+}
+inline const ::std::string& ReorderInfo_FixupInfo_FixupTuple::section_name() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+  return section_name_.GetNoArena();
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const ::std::string& value) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+#if LANG_CXX11
+inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(::std::string&& value) {
+  set_has_section_name();
+  section_name_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+#endif
+inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_section_name(const char* value, size_t size) {
+  set_has_section_name();
+  section_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+inline ::std::string* ReorderInfo_FixupInfo_FixupTuple::mutable_section_name() {
+  set_has_section_name();
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+  return section_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* ReorderInfo_FixupInfo_FixupTuple::release_section_name() {
+  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+  clear_has_section_name();
+  return section_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_allocated_section_name(::std::string* section_name) {
+  if (section_name != NULL) {
+    set_has_section_name();
+  } else {
+    clear_has_section_name();
+  }
+  section_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section_name);
+  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.section_name)
+}
+
+// optional uint32 num_jt_entries = 6;
+inline bool ReorderInfo_FixupInfo_FixupTuple::has_num_jt_entries() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_has_num_jt_entries() {
+  _has_bits_[0] |= 0x00000020u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_num_jt_entries() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_num_jt_entries() {
+  num_jt_entries_ = 0u;
+  clear_has_num_jt_entries();
+}
+inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::num_jt_entries() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
+  return num_jt_entries_;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_num_jt_entries(::google::protobuf::uint32 value) {
+  set_has_num_jt_entries();
+  num_jt_entries_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.num_jt_entries)
+}
+
+// optional uint32 jt_entry_sz = 7;
+inline bool ReorderInfo_FixupInfo_FixupTuple::has_jt_entry_sz() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_has_jt_entry_sz() {
+  _has_bits_[0] |= 0x00000040u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_has_jt_entry_sz() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::clear_jt_entry_sz() {
+  jt_entry_sz_ = 0u;
+  clear_has_jt_entry_sz();
+}
+inline ::google::protobuf::uint32 ReorderInfo_FixupInfo_FixupTuple::jt_entry_sz() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
+  return jt_entry_sz_;
+}
+inline void ReorderInfo_FixupInfo_FixupTuple::set_jt_entry_sz(::google::protobuf::uint32 value) {
+  set_has_jt_entry_sz();
+  jt_entry_sz_ = value;
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple.jt_entry_sz)
+}
+
+// -------------------------------------------------------------------
+
+// ReorderInfo_FixupInfo
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple text = 1;
+inline int ReorderInfo_FixupInfo::text_size() const {
+  return text_.size();
+}
+inline void ReorderInfo_FixupInfo::clear_text() {
+  text_.Clear();
+}
+inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::text(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return text_.Get(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_text(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return text_.Mutable(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_text() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return text_.Add();
+}
+inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_text() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return &text_;
+}
+inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::text() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.text)
+  return text_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple rodata = 2;
+inline int ReorderInfo_FixupInfo::rodata_size() const {
+  return rodata_.size();
+}
+inline void ReorderInfo_FixupInfo::clear_rodata() {
+  rodata_.Clear();
+}
+inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::rodata(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return rodata_.Get(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_rodata(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return rodata_.Mutable(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_rodata() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return rodata_.Add();
+}
+inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_rodata() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return &rodata_;
+}
+inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::rodata() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.rodata)
+  return rodata_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple data = 3;
+inline int ReorderInfo_FixupInfo::data_size() const {
+  return data_.size();
+}
+inline void ReorderInfo_FixupInfo::clear_data() {
+  data_.Clear();
+}
+inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::data(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return data_.Get(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_data(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return data_.Mutable(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_data() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return data_.Add();
+}
+inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_data() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return &data_;
+}
+inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::data() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.data)
+  return data_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple datarel = 4;
+inline int ReorderInfo_FixupInfo::datarel_size() const {
+  return datarel_.size();
+}
+inline void ReorderInfo_FixupInfo::clear_datarel() {
+  datarel_.Clear();
+}
+inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::datarel(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return datarel_.Get(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_datarel(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return datarel_.Mutable(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_datarel() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return datarel_.Add();
+}
+inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_datarel() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return &datarel_;
+}
+inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::datarel() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.datarel)
+  return datarel_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo.FixupTuple initarray = 5;
+inline int ReorderInfo_FixupInfo::initarray_size() const {
+  return initarray_.size();
+}
+inline void ReorderInfo_FixupInfo::clear_initarray() {
+  initarray_.Clear();
+}
+inline const ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple& ReorderInfo_FixupInfo::initarray(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return initarray_.Get(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::mutable_initarray(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return initarray_.Mutable(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple* ReorderInfo_FixupInfo::add_initarray() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return initarray_.Add();
+}
+inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >*
+ReorderInfo_FixupInfo::mutable_initarray() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return &initarray_;
+}
+inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo_FixupTuple >&
+ReorderInfo_FixupInfo::initarray() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.FixupInfo.initarray)
+  return initarray_;
+}
+
+// -------------------------------------------------------------------
+
+// ReorderInfo_SourceInfo
+
+// repeated uint32 src_type = 1;
+inline int ReorderInfo_SourceInfo::src_type_size() const {
+  return src_type_.size();
+}
+inline void ReorderInfo_SourceInfo::clear_src_type() {
+  src_type_.Clear();
+}
+inline ::google::protobuf::uint32 ReorderInfo_SourceInfo::src_type(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+  return src_type_.Get(index);
+}
+inline void ReorderInfo_SourceInfo::set_src_type(int index, ::google::protobuf::uint32 value) {
+  src_type_.Set(index, value);
+  // @@protoc_insertion_point(field_set:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+}
+inline void ReorderInfo_SourceInfo::add_src_type(::google::protobuf::uint32 value) {
+  src_type_.Add(value);
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+}
+inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
+ReorderInfo_SourceInfo::src_type() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+  return src_type_;
+}
+inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
+ReorderInfo_SourceInfo::mutable_src_type() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.SourceInfo.src_type)
+  return &src_type_;
+}
+
+// -------------------------------------------------------------------
+
+// ReorderInfo
+
+// optional .ShuffleInfo.ReorderInfo.BinaryInfo bin = 1;
+inline bool ReorderInfo::has_bin() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void ReorderInfo::set_has_bin() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void ReorderInfo::clear_has_bin() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void ReorderInfo::clear_bin() {
+  if (bin_ != NULL) bin_->::ShuffleInfo::ReorderInfo_BinaryInfo::Clear();
+  clear_has_bin();
+}
+inline const ::ShuffleInfo::ReorderInfo_BinaryInfo& ReorderInfo::bin() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.bin)
+  return bin_ != NULL ? *bin_
+                         : *::ShuffleInfo::ReorderInfo_BinaryInfo::internal_default_instance();
+}
+inline ::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::mutable_bin() {
+  set_has_bin();
+  if (bin_ == NULL) {
+    bin_ = new ::ShuffleInfo::ReorderInfo_BinaryInfo;
+  }
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.bin)
+  return bin_;
+}
+inline ::ShuffleInfo::ReorderInfo_BinaryInfo* ReorderInfo::release_bin() {
+  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.bin)
+  clear_has_bin();
+  ::ShuffleInfo::ReorderInfo_BinaryInfo* temp = bin_;
+  bin_ = NULL;
+  return temp;
+}
+inline void ReorderInfo::set_allocated_bin(::ShuffleInfo::ReorderInfo_BinaryInfo* bin) {
+  delete bin_;
+  bin_ = bin;
+  if (bin) {
+    set_has_bin();
+  } else {
+    clear_has_bin();
+  }
+  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.bin)
+}
+
+// repeated .ShuffleInfo.ReorderInfo.LayoutInfo layout = 2;
+inline int ReorderInfo::layout_size() const {
+  return layout_.size();
+}
+inline void ReorderInfo::clear_layout() {
+  layout_.Clear();
+}
+inline const ::ShuffleInfo::ReorderInfo_LayoutInfo& ReorderInfo::layout(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.layout)
+  return layout_.Get(index);
+}
+inline ::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::mutable_layout(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.layout)
+  return layout_.Mutable(index);
+}
+inline ::ShuffleInfo::ReorderInfo_LayoutInfo* ReorderInfo::add_layout() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.layout)
+  return layout_.Add();
+}
+inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >*
+ReorderInfo::mutable_layout() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.layout)
+  return &layout_;
+}
+inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_LayoutInfo >&
+ReorderInfo::layout() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.layout)
+  return layout_;
+}
+
+// repeated .ShuffleInfo.ReorderInfo.FixupInfo fixup = 3;
+inline int ReorderInfo::fixup_size() const {
+  return fixup_.size();
+}
+inline void ReorderInfo::clear_fixup() {
+  fixup_.Clear();
+}
+inline const ::ShuffleInfo::ReorderInfo_FixupInfo& ReorderInfo::fixup(int index) const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.fixup)
+  return fixup_.Get(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::mutable_fixup(int index) {
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.fixup)
+  return fixup_.Mutable(index);
+}
+inline ::ShuffleInfo::ReorderInfo_FixupInfo* ReorderInfo::add_fixup() {
+  // @@protoc_insertion_point(field_add:ShuffleInfo.ReorderInfo.fixup)
+  return fixup_.Add();
+}
+inline ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >*
+ReorderInfo::mutable_fixup() {
+  // @@protoc_insertion_point(field_mutable_list:ShuffleInfo.ReorderInfo.fixup)
+  return &fixup_;
+}
+inline const ::google::protobuf::RepeatedPtrField< ::ShuffleInfo::ReorderInfo_FixupInfo >&
+ReorderInfo::fixup() const {
+  // @@protoc_insertion_point(field_list:ShuffleInfo.ReorderInfo.fixup)
+  return fixup_;
+}
+
+// optional .ShuffleInfo.ReorderInfo.SourceInfo source = 4;
+inline bool ReorderInfo::has_source() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void ReorderInfo::set_has_source() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void ReorderInfo::clear_has_source() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void ReorderInfo::clear_source() {
+  if (source_ != NULL) source_->::ShuffleInfo::ReorderInfo_SourceInfo::Clear();
+  clear_has_source();
+}
+inline const ::ShuffleInfo::ReorderInfo_SourceInfo& ReorderInfo::source() const {
+  // @@protoc_insertion_point(field_get:ShuffleInfo.ReorderInfo.source)
+  return source_ != NULL ? *source_
+                         : *::ShuffleInfo::ReorderInfo_SourceInfo::internal_default_instance();
+}
+inline ::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::mutable_source() {
+  set_has_source();
+  if (source_ == NULL) {
+    source_ = new ::ShuffleInfo::ReorderInfo_SourceInfo;
+  }
+  // @@protoc_insertion_point(field_mutable:ShuffleInfo.ReorderInfo.source)
+  return source_;
+}
+inline ::ShuffleInfo::ReorderInfo_SourceInfo* ReorderInfo::release_source() {
+  // @@protoc_insertion_point(field_release:ShuffleInfo.ReorderInfo.source)
+  clear_has_source();
+  ::ShuffleInfo::ReorderInfo_SourceInfo* temp = source_;
+  source_ = NULL;
+  return temp;
+}
+inline void ReorderInfo::set_allocated_source(::ShuffleInfo::ReorderInfo_SourceInfo* source) {
+  delete source_;
+  source_ = source;
+  if (source) {
+    set_has_source();
+  } else {
+    clear_has_source();
+  }
+  // @@protoc_insertion_point(field_set_allocated:ShuffleInfo.ReorderInfo.source)
+}
+
+#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+
+// @@protoc_insertion_point(namespace_scope)
+
+
+}  // namespace ShuffleInfo
+
+// @@protoc_insertion_point(global_scope)
+
+#endif  // PROTOBUF_shuffleInfo_2eproto__INCLUDED
diff --git a/shuffleInfo.proto b/shuffleInfo.proto
new file mode 100644
index 0000000..802826d
--- /dev/null
+++ b/shuffleInfo.proto
@@ -0,0 +1,63 @@
+// This file defines the buffer protocol of the shuffleInfo for reordering.
+// The following command automatically generates both the declaration 
+// and the implementation of shuffleInfo class.
+//    $ protoc --cpp_out=$DST_DIR shuffleInfo.proto       # C++
+//    $ protoc --python_out=$DST_DIR shuffleInfo.proto    # Python
+// The following command generates the shared object.
+//    $ c++ -fPIC -shared shuffleInfo.pb.cc -o shuffleInfo.so `pkg-config --cflags --libs protobuf`
+// Revised: 4/22/18
+
+syntax = "proto2";
+package ShuffleInfo;
+
+message ReorderInfo {
+  // Binary info from ld or ld.gold; reordering range and main offset
+  message BinaryInfo {
+    optional uint32 rand_obj_offset = 1;  // PLACEHOLDER FOR LINKER
+    optional uint32 main_addr_offset = 2; // PLACEHOLDER FOR LINKER
+    optional uint32 obj_sz = 3;           // Verification purpose
+    optional uint32 src_type = 4;         // See the SourceInfo message
+  }
+
+  // Code layout Info (.text) from LLVM
+  // Embeded info ([#func|#fixup]/obj, [#bbk|#fixup]/func, objSz/ea, funcSz/ea)
+  message LayoutInfo {
+    optional uint32 bb_size = 1;          // UPDATE AT LINKTIME WITH OBJ ALIGNMENTs
+                                          // All alignments between fn/bbl are included here
+    optional uint32 type = 2;             // Represents the end of [OBJ|FUN|BBL]
+    optional uint32 num_fixups = 3;
+    optional bool bb_fallthrough = 4;
+    optional string section_name = 5;     // section identifier for c++ mutiple sections
+    optional uint32 offset = 6; // update at linking when combining sections
+    optional uint32 padding_size = 7;
+  }
+
+  // Fixup info in ELF from LLVM
+  message FixupInfo {
+    message FixupTuple {
+      required uint32 offset = 1;         // UPDATE AT LINKTIME WHEN COMBINING SECTIONS
+      required uint32 deref_sz = 2;
+      required bool   is_rela = 3;
+      optional uint32 type = 4;           // c2c, c2d, d2c, d2d = (0-3)
+      optional string section_name = 5;   // section identifier for c++ mutiple sections
+                                          // fixup has a jump table (.rodata) for pic/pie use
+      optional uint32 num_jt_entries = 6; // number of the jump table entries
+      optional uint32 jt_entry_sz = 7;    // size of each jump table entry in byte
+    }
+    repeated FixupTuple text = 1;
+    repeated FixupTuple rodata = 2;
+    repeated FixupTuple data = 3;
+    repeated FixupTuple datarel = 4;
+    repeated FixupTuple initarray = 5;
+  }
+  
+  // Source info [generalSource(=0) | hasInlineAssembly(=1) | standaloneAssembly(=2)]
+  message SourceInfo {
+    repeated uint32 src_type = 1;         // the src_type placeholder for linker
+  }
+
+  optional BinaryInfo bin = 1;
+  repeated LayoutInfo layout = 2;
+  repeated FixupInfo fixup = 3;
+  optional SourceInfo source = 4;
+}
diff --git a/struc-symbol.h b/struc-symbol.h
index c016848..44957f2 100644
--- a/struc-symbol.h
+++ b/struc-symbol.h
@@ -104,6 +104,16 @@ struct symbol
 #ifdef TARGET_SYMBOL_FIELDS
   TARGET_SYMBOL_FIELDS
 #endif
+
+// binpang add
+// jump table related information, we only add the related information in i386/x86_64 architecture
+#if defined(__i386__) || defined(__x86_64__)
+   struct jump_table{
+      unsigned int table_size; // the jump table size(number of jump table entry)
+      unsigned int entry_size; // the jump table entry size
+   } jmp_table;
+#endif
+
 };
 
 /* A pointer in the symbol may point to either a complete symbol
@@ -144,6 +154,12 @@ struct local_symbol
 #ifdef TC_LOCAL_SYMFIELD_TYPE
   TC_LOCAL_SYMFIELD_TYPE lsy_tc;
 #endif
+
+// binpang add
+// jump table related information, we only add the related information in i386/x86_64 architecture
+#if defined(__i386__) || defined(__x86_64__)
+struct jump_table jmp_table;
+#endif
 };
 
 #define local_symbol_converted_p(l) ((l)->lsy_section == reg_section)
diff --git a/symbols.c b/symbols.c
index d16e804..863d60a 100644
--- a/symbols.c
+++ b/symbols.c
@@ -2213,6 +2213,38 @@ S_GET_NAME (symbolS *s)
   return s->bsym->name;
 }
 
+/*
+ * binpang, add
+ * get and set jump table related element
+ */
+unsigned S_GET_JMPTBL_SIZE(symbolS *s)
+{
+  if (LOCAL_SYMBOL_CHECK (s))
+    return ((struct local_symbol *) s)->jmp_table.table_size;
+  return s->jmp_table.table_size;
+}
+
+unsigned S_GET_JMPTBL_ENTRY_SZ(symbolS *s)
+{
+  if (LOCAL_SYMBOL_CHECK (s))
+    return ((struct local_symbol *) s)->jmp_table.entry_size;
+  return s->jmp_table.entry_size;
+}
+
+void S_SET_JMPTBL_SIZE(symbolS *s, unsigned size){
+  if (LOCAL_SYMBOL_CHECK (s))
+    ((struct local_symbol *) s)->jmp_table.table_size = size;
+  else
+    s->jmp_table.table_size = size;
+}
+
+void S_SET_JMPTBL_ENTRY_SZ(symbolS *s, unsigned size){
+  if (LOCAL_SYMBOL_CHECK (s))
+    ((struct local_symbol *) s)->jmp_table.entry_size = size;
+  else
+    s->jmp_table.entry_size = size;
+}
+
 segT
 S_GET_SEGMENT (symbolS *s)
 {
diff --git a/symbols.h b/symbols.h
index cb316b5..5b125e2 100644
--- a/symbols.h
+++ b/symbols.h
@@ -84,6 +84,15 @@ char *fb_label_name (long n, long augend);
 
 extern void copy_symbol_attributes (symbolS *, symbolS *);
 
+/*
+ * binpang, add
+ * get and set jump table struct
+ */
+extern unsigned S_GET_JMPTBL_SIZE(symbolS*);
+extern unsigned S_GET_JMPTBL_ENTRY_SZ(symbolS*);
+extern void S_SET_JMPTBL_SIZE(symbolS*, unsigned);
+extern void S_SET_JMPTBL_ENTRY_SZ(symbolS*, unsigned);
+
 /* Get and set the values of symbols.  These used to be macros.  */
 extern valueT S_GET_VALUE (symbolS *);
 extern void S_SET_VALUE (symbolS *, valueT);
diff --git a/write.c b/write.c
index 2869660..6b1f176 100644
--- a/write.c
+++ b/write.c
@@ -27,6 +27,10 @@
 #include "dwarf2dbg.h"
 #include "compress-debug.h"
 
+#if defined(__i386__) || defined(__x86_64__)
+#include "bbInfoHandle.h"
+#endif
+
 #ifndef TC_FORCE_RELOCATION
 #define TC_FORCE_RELOCATION(FIX)		\
   (generic_force_reloc (FIX))
@@ -549,6 +553,84 @@ relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx)
     info->changed = 1;
 }
 
+/*
+ *  binpang, add.
+ *  update basic block size.
+ */
+#if defined(__i386__) || defined(__x86_64__)
+static void update_basic_block_size(bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx ATTRIBUTE_UNUSED)
+{
+  const char* sec_name = sec->name;
+  // we only handle the basic block in .text.xxx section
+  char* tmp_pointer = NULL;
+  tmp_pointer = strstr(sec_name, ".text");
+  if (!(tmp_pointer && tmp_pointer == sec_name))
+    return;
+  segment_info_type *seginfo = seg_info (sec);
+  struct frag *seg_frag_root = seginfo->frchainP->frch_root;
+  struct frag *fragP;
+  bbinfo_mbb *mbbP;
+  
+  for (fragP = seg_frag_root; fragP;
+    fragP = fragP->fr_next){
+    fragP->parent = sec;
+    // update the basic block size
+    mbbP = fragP->last_bb;
+    
+    if (mbbP && fragP->last_bb_added_size){
+      mbbP->size += fragP->last_bb_added_size;
+    }
+    
+   }
+}
+
+static void update_basic_block_size_from_frag(bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx ATTRIBUTE_UNUSED)
+{
+  const char* sec_name = sec->name;
+  // we only handle the basic block in .text.xxx section
+  char* tmp_pointer = NULL;
+  tmp_pointer = strstr(sec_name, ".text");
+  if (!(tmp_pointer && tmp_pointer == sec_name))
+    return;
+
+  segment_info_type *seginfo = seg_info (sec);
+  struct frag *seg_frag_root = seginfo->frchainP->frch_root;
+  struct frag *fragP;
+  bbinfo_mbb *mbbP;
+  struct frag *last_frag = NULL;
+  
+  for (fragP = seg_frag_root; fragP;
+    fragP = fragP->fr_next){
+    
+    mbbP = fragP->last_bb;
+    if (last_frag && last_frag->last_bb){
+      int frag_offset = fragP->fr_address - last_frag->last_bb->offset;
+   // update the basic block size according to the fragment offset
+      if (frag_offset > last_frag->last_bb->size){
+	last_frag->last_bb->size = frag_offset;}
+    }
+
+    if (mbbP)
+      last_frag = fragP;
+   }
+}
+// update basic block offset
+static void update_basic_block_offset(void){
+  for (bbinfo_mbb *cur_mbb = mbbs_list_head; cur_mbb;
+      		cur_mbb = cur_mbb->next)
+  {
+    if (!cur_mbb->parent_frag)
+    {
+      //as_warn(_("[bbInfo warning]: Basic block %d don't have parent fragment, its size %d"), cur_mbb->ID, cur_mbb->size);
+      continue;
+    }
+    cur_mbb->offset += cur_mbb->parent_frag->fr_address;
+    cur_mbb->sec = cur_mbb->parent_frag->parent;
+  }
+}
+#endif
+
+
 static void
 size_seg (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
 {
@@ -1149,6 +1231,52 @@ fix_segment (bfd *abfd ATTRIBUTE_UNUSED,
   fixup_segment (seginfo->fix_root, sec);
 }
 
+/*
+ * binpang, add. 
+ * collect fixup information before fixup resolved.
+ */
+static void 
+bbinfo_update_fixp (bfd *abfd ATTRIBUTE_UNUSED,
+    	     asection *sec,
+	     void *xxx ATTRIBUTE_UNUSED)
+{
+
+  fixS *fixp;
+  segment_info_type *seginfo = seg_info (sec);
+
+  if (!seginfo->fix_root)
+    return;
+
+  char is_new_sec = bbinfo_is_collect_sec(sec);
+  
+  // we only collect .text, .rodata, .init_array, .data, .data.rel.ro sections
+  if (!is_new_sec)
+    return;
+  
+ /*
+  * TODO(binpang), add relocation information that .realoc directive defined
+  * which is stored in reloc_list.
+  *  may refer to what write_relocs fucntion does
+  */
+  for(fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
+  {
+    int offset = fixp->fx_frag->fr_address + fixp->fx_where; 
+   // bbinfo_fixup* tmp_fixp = bbinfo_init_fixup(fixups_list_head, fixups_list_tail);
+    bbinfo_fixup* tmp_fixp = bbinfo_init_insert_fixup(sec, offset);
+    tmp_fixp->sec = sec;
+    tmp_fixp->offset = offset;
+    tmp_fixp->is_rela = (unsigned char)fixp->fx_pcrel;
+    tmp_fixp->size = fixp->fx_size;
+    // FIXME. Here I only consider fixp->fx_addsy
+    symbolS* tmp_sym = fixp->fx_addsy;
+    if(tmp_sym){
+      tmp_fixp->table_size = S_GET_JMPTBL_SIZE(tmp_sym);
+      tmp_fixp->entry_size = S_GET_JMPTBL_ENTRY_SZ(tmp_sym);
+    }
+    tmp_fixp->is_new_section = 0;
+  }
+
+}
 static void
 install_reloc (asection *sec, arelent *reloc, fragS *fragp,
 	       const char *file, unsigned int line)
@@ -1578,6 +1706,20 @@ write_contents (bfd *abfd ATTRIBUTE_UNUSED,
   segment_info_type *seginfo = seg_info (sec);
   addressT offset = 0;
   fragS *f;
+  
+  /*
+   * binpang, add
+   * output the section .rand
+   */ 
+  if (!strcmp(sec->name, ".rand")){
+    unsigned result = bfd_set_section_contents(stdoutput, sec, bbinfo_shuffle_info_buf, 
+			(file_ptr) 0, (bfd_size_type) bbinfo_shuffle_info_buf_len);
+    
+  if(!result)
+    as_warn(_("can't write data into .rand"));
+
+  return;
+  }
 
   /* Write out the frags.  */
   if (seginfo == NULL
@@ -1916,6 +2058,14 @@ write_object_file (void)
 	break;
     }
 
+// binpang, add 
+// update basic block size and offset
+#if defined(__i386__) || defined(__x86_64__)
+  bfd_map_over_sections (stdoutput, update_basic_block_size, (void*)0);
+  update_basic_block_offset();
+  //bfd_map_over_sections (stdoutput, update_basic_block_size_from_frag, (void*)0);
+#endif
+
   /* Note - Most ports will use the default value of
      TC_FINALIZE_SYMS_BEFORE_SIZE_SEG, which 1.  This will force
      local symbols to be resolved, removing their frag information.
@@ -2040,6 +2190,12 @@ write_object_file (void)
   }
 #endif /* not WORKING_DOT_WORD  */
 
+  /*
+   * binpang, add
+   * collect all fixup
+   */
+  bfd_map_over_sections (stdoutput, bbinfo_update_fixp, (char *) 0);
+
   /* Resolve symbol values.  This needs to be done before processing
      the relocations.  */
   if (symbol_rootP)
@@ -2255,7 +2411,32 @@ write_object_file (void)
       bfd_map_over_sections (stdoutput, compress_debug, (char *) 0);
     }
 
+  /*
+   * binpang, add
+   * create .rand section
+   */
+  asection* rand_sec = bfd_make_section (stdoutput, ".rand");
+  bfd_set_section_flags(stdoutput, rand_sec, SEC_HAS_CONTENTS);
+  bbinfo_update_shuffle_info();
+  // BUG? why should at here specify size. But in write_contents fuction, it can't work.
+  rand_sec->size = bbinfo_shuffle_info_buf_len;
+
   bfd_map_over_sections (stdoutput, write_contents, (char *) 0);
+
+// binpang, add. debug.
+//#if defined(__i386__) || defined(__x86_64__)
+//  int tmp_index = 0;
+//  printf("after relaxing....\n");
+//  for(bbinfo_mbb* cur_bb = mbbs_list_head; cur_bb; cur_bb = cur_bb->next)
+//    printf("basic block#%d: basic block offset %x, size %d, fall_through %d, its section name is %s\n", 
+//	tmp_index++, cur_bb->offset, cur_bb->size, cur_bb->fall_through, cur_bb->sec->name);
+//
+//  printf("fixup information\n");
+//  tmp_index = 0;
+//  for(bbinfo_fixup* cur_fixp = fixups_list_head; cur_fixp; cur_fixp = cur_fixp->next)
+//    printf("fixup#%d: fixup offset %x, size %d, section %s, is rela %d, table size %d, entry size %d\n ", 
+//	tmp_index++, cur_fixp->offset, cur_fixp->size, cur_fixp->sec->name, cur_fixp->is_rela, cur_fixp->table_size, cur_fixp->entry_size);
+//#endif
 }
 
 #ifdef TC_GENERIC_RELAX_TABLE
@@ -2407,6 +2588,14 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
   int region;
   int ret;
 
+// binpang add
+// use last_frag to record the last fragS
+// handle the situation that before alignment fragS
+#if defined(__i386__) || defined(__x86_64__)
+struct frag *last_frag = NULL;
+bbinfo_mbb *frag_last_bb = NULL;
+#endif
+
   /* In case md_estimate_size_before_relax() wants to make fixSs.  */
   subseg_change (segment, 0);
 
@@ -2423,10 +2612,28 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
       fragP->fr_address = address;
       address += fragP->fr_fix;
 
+// binpang, add.
+#if defined(__i386__) || defined(__x86_64__)
+      frag_last_bb = NULL;
+      // may do many times relax pass. every time reset last_bb_added_size.
+      fragP->last_bb_added_size = fragP->last_bb_added_fix_size;
+      if (fragP->last_bb && fragP->last_bb->alignment)
+	fragP->last_bb->alignment = 0;
+#endif
+
       switch (fragP->fr_type)
 	{
 	case rs_fill:
-	  address += fragP->fr_offset * fragP->fr_var;
+	  {int addedBytes = fragP->fr_offset * fragP->fr_var;
+
+#if defined(__i386__) || defined(__x86_64__) 
+	  frag_last_bb = fragP->last_bb;
+	  if (frag_last_bb){
+	    fragP->last_bb_added_size += addedBytes;
+	  }
+#endif
+	  address += addedBytes;
+	}
 	  break;
 
 	case rs_align:
@@ -2449,8 +2656,31 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
 			      (unsigned long) offset, (long) fragP->fr_var);
 		offset -= (offset % fragP->fr_var);
 	      }
-
 	    address += offset;
+	 
+// add the alignment bytes to the last basic block
+// TODO(binpang). Seperate the alignment fragment into a seperate basic block.
+#if defined(__i386__) || defined(__x86_64__)
+	    struct frag* tmp_frag = NULL;
+	      /*
+	       * FIXME. If the current frag has fix bytes, then append the alignment to the current frag.
+	       * Otherwise, append the alignment to the last frag.
+	       */
+	      if(fragP && fragP->fr_fix)
+	       	tmp_frag = fragP;
+	      else 
+			tmp_frag = last_frag;
+
+	      // make sure the tmp_frag contains basic block
+	      if (tmp_frag && tmp_frag->last_bb)
+		  	//    && (!bbinfo_handwritten_file || tmp_frag->fr_fix <= (tmp_frag->last_bb->offset + tmp_frag->last_bb->size)))
+	      {
+			tmp_frag->last_bb_added_size += offset;
+			tmp_frag->last_bb->alignment += offset;
+	        //printf("[bbInfo]: alignment add size %d, frag address %x\n", offset, fragP->fr_address);
+	      }
+	      
+#endif
 	    region += 1;
 	  }
 	  break;
@@ -2470,7 +2700,18 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
 	  if (fragP->fr_symbol)
 	    resolve_symbol_value (fragP->fr_symbol);
 
-	  address += md_estimate_size_before_relax (fragP, segment);
+	  int added_bytes = md_estimate_size_before_relax (fragP, segment);
+	  address += added_bytes;
+
+	  //binpang, add. update the last basic block's size
+#if defined(__i386__) || defined(__x86_64__)
+	  frag_last_bb = fragP->last_bb;
+	  if (frag_last_bb && added_bytes)
+	  {
+	    fragP->last_bb_added_size += added_bytes;
+	  }
+#endif
+	  
 	  break;
 
 #ifndef WORKING_DOT_WORD
@@ -2497,6 +2738,11 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
 	  BAD_CASE (fragP->fr_type);
 	  break;
 	}
+
+#if defined(__i386__) || defined(__x86_64__)
+        if (fragP->last_bb)
+	  		last_frag = fragP;
+#endif
     }
 
   /* Do relax().  */
@@ -2549,12 +2795,18 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
     if (max_iterations < frag_count)
       max_iterations = frag_count;
 
+
     ret = 0;
     do
       {
 	stretch = 0;
 	stretched = 0;
 
+// binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+   last_frag = NULL; 
+#endif
+
 	for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
 	  {
 	    offsetT growth = 0;
@@ -2663,6 +2915,29 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
 
 		  growth = newoff - oldoff;
 
+/* 
+ * binpang, add.
+ * update the fragment's last basic block size. Similar to up.
+ * TODO(binpang). maybe seperate the alignment fragment in code segment into a basic block.
+*/
+#if defined(__i386__) || defined(__x86_64__)
+		  struct frag* tmp_frag = NULL;
+		  if (fragP && fragP->fr_fix)
+		    tmp_frag = fragP;
+		  else
+		  {
+		    tmp_frag = last_frag;
+		  }
+		    // tmp_frag has basic block. exclude data fragment.
+		  if (tmp_frag && tmp_frag->last_bb)
+		    {
+		      tmp_frag->last_bb_added_size += growth;
+		      tmp_frag->last_bb->alignment += growth;
+		   // debug
+		   // printf("[bbInfo]: alignment add size %d, frag address is %x\n", growth, fragP->fr_address);
+		    }
+#endif
+
 		  /* If this align happens to follow a leb128 and
 		     we have determined that the leb128 is bouncing
 		     in size, then break the cycle by inserting an
@@ -2801,6 +3076,7 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
 		break;
 
 	      case rs_machine_dependent:
+		{
 #ifdef md_relax_frag
 		growth = md_relax_frag (segment, fragP, stretch);
 #else
@@ -2809,6 +3085,19 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
 		   TC_GENERIC_RELAX_TABLE.  */
 		growth = relax_frag (segment, fragP, stretch);
 #endif /* TC_GENERIC_RELAX_TABLE  */
+#endif
+		
+		// binpang, add
+		// update the relaxed basic block size
+#if defined(__i386__) || defined(__x86_64__)
+		frag_last_bb = fragP->last_bb;
+		if (frag_last_bb && growth)
+		{
+		  fragP->last_bb_added_size += growth;
+		  // debug
+		  //printf("[bbInfo]: machine dependent add size %d, frag address is %x. Hello?\n", growth, fragP->fr_address);
+		}
+             }
 #endif
 		break;
 
@@ -2849,6 +3138,13 @@ relax_segment (struct frag *segment_frag_root, segT segment, int pass)
 		else
 		  rs_leb128_fudge = 0;
 	      }
+
+// binpang, add
+#if defined(__i386__) || defined(__x86_64__)
+	    if (fragP->last_bb)
+	      last_frag = fragP;
+#endif
+
 	  }
 
 	if (stretch == 0
